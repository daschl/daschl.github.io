<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on daschl writes. sometimes.</title>
    <link>https://nitschinger.at/post/</link>
    <description>Recent content in Posts on daschl writes. sometimes.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 02 Jan 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://nitschinger.at/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Rust on the WiFi Pineapple (and OpenWrt)</title>
      <link>https://nitschinger.at/Rust-on-the-Wifi-Pineapple-and-OpenWRT/</link>
      <pubDate>Mon, 02 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Rust-on-the-Wifi-Pineapple-and-OpenWRT/</guid>
      <description>Over the holidays I wanted to get a very simple Rust application running on my WiFi Pineapple Nano. Since I don&amp;rsquo;t have much experience with embedded systems and cross-compilation, it sounded like something fun to do and I was sure I might learn a thing or two. Many hours later and lots of frustration, I ended up with a simple solution that I&amp;rsquo;d like to share in this post.</description>
    </item>
    
    <item>
      <title>Text Analysis in Rust - Tokenization</title>
      <link>https://nitschinger.at/Text-Analysis-in-Rust-Tokenization/</link>
      <pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Text-Analysis-in-Rust-Tokenization/</guid>
      <description>I work for Couchbase where we are currently developing full text search capabilities based on bleve. Bleve is implemented in go and inspired by Apache Lucene, the reference implementation when it comes to full text search. While I am not directly involved in developing bleve I was curious about how it works internally and did take a look at the analyzers it provides.
Analyzers take your free form text and turn it into tokens which can then be used for indexing or queries.</description>
    </item>
    
    <item>
      <title>Scheduling Timers on OS X with Rust and Kqueue</title>
      <link>https://nitschinger.at/Scheduling-Timers-on-OS-X-with-Rust-and-Kqueue/</link>
      <pubDate>Wed, 15 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Scheduling-Timers-on-OS-X-with-Rust-and-Kqueue/</guid>
      <description>As a more or less POSIX compatible system I would&amp;rsquo;ve expected timer_create and friends to be available on OS X, but it turns out those functions are not available (at least I couldn&amp;rsquo;t find them after hours of research).
Looking into alternatives (spoiler: there are not many I think if you want to work from C/Rust) I settled on Kqueue. It doesn&amp;rsquo;t have all the features that the timer_ functions provide, but for what I need it seems to be good enough.</description>
    </item>
    
    <item>
      <title>First Steps with Rust and JNI</title>
      <link>https://nitschinger.at/First-Steps-with-Rust-and-JNI/</link>
      <pubDate>Fri, 19 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/First-Steps-with-Rust-and-JNI/</guid>
      <description>The first steps are always the hardest, at least thats how the saying goes. But it turns out that calling into Rust from Java is easier than I originally thought.
The following blog post shows you how to setup and compile a Rust library which can be called from Java userland. Note that everything you see in this post, while being functional, is very simplistic. Real world JNI has lots of nitty gritty details and pitfalls, but we need to start somewhere right?</description>
    </item>
    
    <item>
      <title>Binding Threads And Processes to CPUs in Rust</title>
      <link>https://nitschinger.at/Binding-Threads-And-Processes-to-CPUs-in-Rust/</link>
      <pubDate>Thu, 11 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Binding-Threads-And-Processes-to-CPUs-in-Rust/</guid>
      <description>In the previous post I&amp;rsquo;ve introduced the hwloc-rs library, which allows you to discover and manage hardware topologies. Discovering the capabilities of a machine is insightful, but it gets more interesting if you can perform certain actions based on those insights.
Binding threads or processes to distinct CPU cores is very important in high performance applications to isolate workloads, keep inter-core messaging latency to a minimum and also to prevent the operating system from relocating your threads between cores as it sees fit.</description>
    </item>
    
    <item>
      <title>Discovering Hardware Topology in Rust</title>
      <link>https://nitschinger.at/Discovering-Hardware-Topology-in-Rust/</link>
      <pubDate>Fri, 08 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Discovering-Hardware-Topology-in-Rust/</guid>
      <description>Todays programming languages and operation systems provide a bunch of abstraction layers over our hardware. Most of the time this is great, since we can write code quickly and make it run on lots of different machines. The opportunity cost with abstraction is (most of the time) performance and a lack of understanding.
To get the best performance out of hour hardware, it is important to understand it. Concepts like cache locality matter a lot, especially in modern NUMA architectures.</description>
    </item>
    
    <item>
      <title>Debugging Concurrency Issues with OpenJDK Jcstress</title>
      <link>https://nitschinger.at/Debugging-Concurrency-Issues-with-Open-JDK-Jcstress/</link>
      <pubDate>Tue, 27 May 2014 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Debugging-Concurrency-Issues-with-Open-JDK-Jcstress/</guid>
      <description>I fell in love with the Java Microbenchmarking Harness (JMH) a few months ago since (in my opinion) it is the only sane way to do microbenchmarks of JVM code right now. I also poked around on their website for other tools they provide, and found that there is another very interesting tool called jcstress. It stands for Java Concurrency Stress tests and is used mainly by the OpenJDK people itself to make sure their code works correctly with regards to concurrency.</description>
    </item>
    
    <item>
      <title>Bootstrapping from DNS SRV records in Java</title>
      <link>https://nitschinger.at/Bootstrapping-from-DNS-SRV-records-in-Java/</link>
      <pubDate>Wed, 29 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Bootstrapping-from-DNS-SRV-records-in-Java/</guid>
      <description>I know this topic has a very narrow audience, but I hope that one or two people out there scratching their heads will benefit from it.
Here&amp;rsquo;s the itch we&amp;rsquo;re trying to scratch: is there an easy way to determine hostnames for - let&amp;rsquo;s say - a database connection? There are many ways to do this, like hardcoding it, providing them through a properties file and so on. All this techniques (maybe aside from fetching it over the network from a central storage) require some modifications on the server once one of the hostnames changes.</description>
    </item>
    
    <item>
      <title>Using JMH for Java Microbenchmarking</title>
      <link>https://nitschinger.at/Using-JMH-for-Java-Microbenchmarking/</link>
      <pubDate>Fri, 22 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Using-JMH-for-Java-Microbenchmarking/</guid>
      <description>So before we dive in, let&amp;rsquo;s rule two things out. First, I&amp;rsquo;m not a JVM expert and second, microbenchmarking is hard. The bigger problem is that it isn&amp;rsquo;t only hard but also looks very easy if you start. You put your test code in a loop, use System.nanoTime or something similar to measure the total time of the run and divide it by the number of runs. Doing it that way, you could very well let your cat estimate the results (mine would do it for proper catnip).</description>
    </item>
    
    <item>
      <title>What&#39;s new in the Couchbase Java SDK 1.2</title>
      <link>https://nitschinger.at/What-s-new-in-the-Couchbase-Java-SDK-1-2/</link>
      <pubDate>Fri, 11 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/What-s-new-in-the-Couchbase-Java-SDK-1-2/</guid>
      <description>For all users of our Java SDK, we prepared some nice additions for you. This post covers them in detail and shows how you can get more productive.
Note that this blog post assumes you are running the 1.2.1 release, because there have been some slight changes between 1.2.0 and 1.2.1 that affect for example the listener support and metrics collection.
Maven Central Distribution From the 1.2.0 release forward, the Java SDK is distributed directly from Maven Central.</description>
    </item>
    
  </channel>
</rss>