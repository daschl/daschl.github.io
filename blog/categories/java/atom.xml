<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Nitschinger.at]]></title>
  <link href="http://daschl.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://daschl.github.io/"/>
  <updated>2013-12-19T10:31:42+01:00</updated>
  <id>http://daschl.github.io/</id>
  <author>
    <name><![CDATA[Michael Nitschinger]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using JMH for Java Microbenchmarking]]></title>
    <link href="http://daschl.github.io/Using-JMH-for-Java-Microbenchmarking"/>
    <updated>2013-11-22T13:49:48+01:00</updated>
    <id>http://daschl.github.io/Using-JMH-for-Java-Microbenchmarking</id>
    <content type="html"><![CDATA[<p>Larger companies like Google started their own projects to remedy all kinds of pitfalls and libraries like <a href="https://code.google.com/p/caliper/">Caliper</a> popped out of that. Now finally, some fine folks of the OpenJDK team thought they&rsquo;ll do their own and share it for everyone to use. The tool is called <a href="http://openjdk.java.net/projects/code-tools/jmh/">jmh</a> or also known as &ldquo;Java Microbenchmarking Harness&rdquo;.</p>

<p>In this post I just show you how to get started, but there are still lots of things you need to think about. I really recommend you to watch <a href="http://vimeo.com/78900556">the talk by Aleksey Shipilev</a> which dives into concepts and pitfalls. You can also find the slides <a href="http://shipilev.net/pub/talks/devoxx-Nov2013-benchmarking.pdf">here</a>.</p>

<h2>Using JMH</h2>

<p>There are a few ways to use it and all of them are explained on the official website linked above. In general, you want to use the self-contained jar and run them on the command line, but there is also an easy way to run them directly out of your IDE &ndash; this is what I&rsquo;m showing you in a second. If you just want to run it from the command line, you do it like (but you need to build the jar first):</p>

<pre><code>$ java -jar target/microbenchmarks.jar -h
</code></pre>

<p>Let&rsquo;s start a maven project in our IDE and add the following dependency (mad props to <a href="https://twitter.com/_godin_/status/403668134206242817">Evgeny Mandrikov</a> for putting it on maven central recently):</p>

<p>``` xml
<dependency></p>

<pre><code>&lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;
&lt;artifactId&gt;jmh-core&lt;/artifactId&gt;
&lt;version&gt;0.1&lt;/version&gt;
</code></pre>

<p></dependency>
```</p>

<p>Now let&rsquo;s write a main method that calls the underlying method of JMH so we can run it easily form our IDE:</p>

<p>``` java
import org.openjdk.jmh.Main;
public class Start {</p>

<pre><code>public static void main(String... args) {
    Main.main(args);
}
</code></pre>

<p>}
```</p>

<p>If we hit run, all we&rsquo;ll see is:</p>

<pre><code>No matching benchmarks. Miss-spelled regexp? Use -v for verbose output.
</code></pre>

<p>Which is good, because we know JMH is working and looking for our benchmarks. Let&rsquo;s write an empty one to get a feeling of how it works.</p>

<p>``` java
package benchmarks;
import org.openjdk.jmh.annotations.GenerateMicroBenchmark;</p>

<p>public class HelloWorld {</p>

<pre><code>@GenerateMicroBenchmark
public void helloWorld() {
}
</code></pre>

<p>}
```</p>

<p>JMH will automatically pick it up from the CLASSPATH and start to run our benchmark. You will see lots of output (forks, warmup runs), but be patient until the end and you&rsquo;ll see something like this:</p>

<pre><code># Fork: 1 of 1
# Warmup: 20 iterations, 1 s each
# Measurement: 10 iterations, 1 s each
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Running: benchmarks.HelloWorld.helloWorld
# Warmup Iteration   1: 3034307.449 ops/ms
# Warmup Iteration   2: 3108187.599 ops/ms
# Warmup Iteration   3: 3117686.141 ops/ms
# Warmup Iteration   4: 3121382.926 ops/ms
# Warmup Iteration   5: 3100218.889 ops/ms
# Warmup Iteration   6: 3117158.492 ops/ms
*** snip ***
Iteration   7: 2906090.682 ops/ms
Iteration   8: 3053047.149 ops/ms
Iteration   9: 3055673.541 ops/ms
Iteration  10: 3113494.893 ops/ms

Result : 3073969.337 ±(95%) 45679.588 ±(99%) 65631.592 ops/ms
Statistics: (min, avg, max) = (2906090.682, 3073969.337, 3120910.177), stdev = 63860.098
Confidence intervals: 95% [3028289.749, 3119648.926], 99% [3008337.745, 3139600.930]

Benchmark                   Mode Thr     Count  Sec         Mean   Mean error    Units
b.HelloWorld.helloWorld    thrpt   1        10    1  3073969.337    65631.592   ops/ms
</code></pre>

<p>Note that both the output and the results may look different on your machine. To not fork as often and don&rsquo;t do so many measure runs (for demo purposes), you can apply the following flags for the command in your IDE: <code>-i 10 -f 1</code>. This will only run one fork and do 10 iterations after warming up. There are dozens of flags you can tune to your needs.</p>

<h2>Benchmarking real code</h2>

<p>Now all is fun, but let&rsquo;s test some real code. In Spymemcached, before we put a document on the wire we check that the key is not longer than allowed and &ndash; for ascii based operations &ndash; also check if they do not contain whitespace and so on. The code in question currently looks like this:</p>

<p>``` java
public static void validateKey(String key, boolean binary) {</p>

<pre><code>byte[] keyBytes = KeyUtil.getKeyBytes(key);
if (keyBytes.length &gt; MemcachedClientIF.MAX_KEY_LENGTH) {
  throw new IllegalArgumentException("Key is too long (maxlen = "
      + MemcachedClientIF.MAX_KEY_LENGTH + ")");
}
if (keyBytes.length == 0) {
  throw new IllegalArgumentException(
      "Key must contain at least one character.");
}
if(!binary) {
  // Validate the key
  for (byte b : keyBytes) {
    if (b == ' ' || b == '\n' || b == '\r' || b == 0) {
      throw new IllegalArgumentException(
          "Key contains invalid characters:  ``" + key + "''");
    }
  }
}
</code></pre>

<p>}
```</p>

<p>Let&rsquo;s say we don&rsquo;t care about optimizing it yet, but we want to see how it performs if the &ldquo;binary&rdquo; flag is applied or not. Obviously less work is done but we want to see how that turns out in practice. Let&rsquo;s add the dependency so we can use the static method directly from the code:</p>

<p>``` xml
<dependency></p>

<pre><code>&lt;groupId&gt;net.spy&lt;/groupId&gt;
&lt;artifactId&gt;spymemcached&lt;/artifactId&gt;
&lt;version&gt;2.10.2&lt;/version&gt;
</code></pre>

<p></dependency>
```</p>

<p>And write a new benchmark that compares both approaches with variation.</p>

<p>``` java
package benchmarks;</p>

<p>import net.spy.memcached.util.StringUtils;
import org.openjdk.jmh.annotations.GenerateMicroBenchmark;</p>

<p>public class KeyBench {</p>

<pre><code>/**
 * 12 chars long
 */
private static final String SHORT_KEY = "user:michael";

/**
 * 240 chars long
 */
private static final String LONG_KEY = "thisIsAFunkyKeyWith_underscores_AndAlso334" +
    "3252545345NumberslthisIsAFunkyKeyWith_underscores_AndAlso3343252545345Numbe" +
    "rslthisIsAFunkyKeyWith_underscores_AndAlso3343252545345NumberslthisIsAFunkyK" +
    "eyWith_underscores_AndAlso3343252545345Numbersl";

@GenerateMicroBenchmark
public void validateShortKeyBinary() {
    StringUtils.validateKey(SHORT_KEY, true);
}

@GenerateMicroBenchmark
public void validateShortKeyAscii() {
    StringUtils.validateKey(SHORT_KEY, false);
}

@GenerateMicroBenchmark
public void validateLongKeyBinary() {
    StringUtils.validateKey(LONG_KEY, true);
}

@GenerateMicroBenchmark
public void validateLongKeyAscii() {
    StringUtils.validateKey(LONG_KEY, false);
}
</code></pre>

<p>}
```</p>

<p>We also see how the performance differs for long and short keys. The first run we do is with 10 iterations and 1 fork:</p>

<pre><code>Result : 18093.561 ±(95%) 65.824 ±(99%) 94.575 ops/ms
  Statistics: (min, avg, max) = (17920.967, 18093.561, 18240.197), stdev = 92.022
  Confidence intervals: 95% [18027.737, 18159.385], 99% [17998.986, 18188.136]


Benchmark                             Mode Thr     Count  Sec         Mean   Mean error    Units
b.KeyBench.validateLongKeyAscii      thrpt   1        10    1     1718.532        8.504   ops/ms
b.KeyBench.validateLongKeyBinary     thrpt   1        10    1     3632.664       24.579   ops/ms
b.KeyBench.validateShortKeyAscii     thrpt   1        10    1    13198.597       71.557   ops/ms
b.KeyBench.validateShortKeyBinary    thrpt   1        10    1    18093.561       94.575   ops/ms
</code></pre>

<p>The first observation we can make is that &ndash; without surprise &ndash; shorter keys are faster than longer keys. But we can also see that the results are much more consistent for longer keys than shorter ones. So let&rsquo;s grab a coffee (this test took over 10 minutes to complete) and run the results with 20 iterations and 10 forks:</p>

<pre><code>Result : 17796.673 ±(95%) 56.110 ±(99%) 76.699 ops/ms
  Statistics: (min, avg, max) = (17441.465, 17796.673, 17947.702), stdev = 119.891
  Confidence intervals: 95% [17740.563, 17852.783], 99% [17719.974, 17873.371]


Benchmark                             Mode Thr     Count  Sec         Mean   Mean error    Units
b.KeyBench.validateLongKeyAscii      thrpt   1       200    1     1719.010        2.160   ops/ms
b.KeyBench.validateLongKeyBinary     thrpt   1       200    1     3745.221       12.101   ops/ms
b.KeyBench.validateShortKeyAscii     thrpt   1       200    1    13144.629       16.918   ops/ms
b.KeyBench.validateShortKeyBinary    thrpt   1       200    1    17886.628       31.513   ops/ms
</code></pre>

<p>We get similar results, but our mean error rate went down which gives us further confidence in our numbers.</p>

<p>Now here comes the important part: while microbenchmarking definitely helps to find bottlenecks and shows you pointers where to go fix your code, it (I think more importantly) shows you code that you do not need to optimize. Say if the numbers shown above fit our application purpose we can &ldquo;check them off&rdquo; the list and go look somewhere else to optimize.</p>

<p>Also, if you are running those benchmarks on your notebook (and not on the servers, where you should too), make sure you don&rsquo;t enable power management so your CPUs work full steam during the full runs. Also, close all other programs that are not essential and leave it alone until the benchmark finishes. That way you reduce the probability of other tasks inferring with your benchmark results and helping you to get more consistent ones.</p>

<h2>Further Considerations</h2>

<p>Funny enough, JMH not only makes your microbenchmarks more accurate, I think they are also much easier to write. You don&rsquo;t need to fight with things happening in the JVM and your operating system while the tests run. You can integrate those benchmarks into your CI runs when someone checks in a new piece of code and look at historically accurate performance numbers (for crucial pieces in your codebase).</p>

<p>One thing I need to tell you before finishing this post. Please go watch the video shown above, since there is still a lot to consider, even with JMH. Also a very good pointer is the examples section located <a href="http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/">here</a>. You should especially be on the lookout for dead code elimination, and the proper use of black holes in JMH.</p>

<p>Please share your findings and additions in the comments section below!</p>

<h2>Additional Information</h2>

<p>As <a href="https://twitter.com/shipilev">Aleksey Shipilёv</a> points out in the comments, there is also a nice Java API that you can use, instead of just proxying &ldquo;main&rdquo; and emulating the command line. Here is an example that shows how to use it. Note that iterating the MAP is optional, but it gives you a code-readable way of the results. If you just call <code>new Runner(opts).run();</code>, you will see the identical output as above.</p>

<p>``` java
public static void main(String&hellip; args) throws Exception {</p>

<pre><code>Options opts = new OptionsBuilder()
    .include(".*")
    .warmupIterations(10)
    .measurementIterations(10)
    .jvmArgs("-server")
    .forks(1)
    .outputFormat(OutputFormatType.TextReport)
    .build();

Map&lt;BenchmarkRecord,RunResult&gt; records = new Runner(opts).run();
for (Map.Entry&lt;BenchmarkRecord, RunResult&gt; result : records.entrySet()) {
    Result r = result.getValue().getPrimaryResult();
    System.out.println("API replied benchmark score: "
        + r.getScore() + " "
        + r.getScoreUnit() + " over "
        + r.getStatistics().getN() + " iterations");
}
</code></pre>

<p>}</p>

<p>```</p>

<p>Also, the constant keys used in the above example are subject to constant optimizations. To work around that, there is the @State annotation for the class and the static fields need to be instance variables. Here is the updated code sample for clarity, the numbers don&rsquo;t change for the purpose of this post.</p>

<p>``` java
package benchmarks;</p>

<p>import net.spy.memcached.util.StringUtils;
import org.openjdk.jmh.annotations.GenerateMicroBenchmark;
import org.openjdk.jmh.annotations.State;</p>

<p>@State
public class KeyBench {</p>

<pre><code>/**
 * 12 chars long
 */
private String SHORT_KEY = "user:michael";

/**
 * 240 chars long
 */
private String LONG_KEY = "thisIsAFunkyKeyWith_underscores_AndAlso334" +
    "3252545345NumberslthisIsAFunkyKeyWith_underscores_AndAlso3343252545345Numbe" +
    "rslthisIsAFunkyKeyWith_underscores_AndAlso3343252545345NumberslthisIsAFunkyK" +
    "eyWith_underscores_AndAlso3343252545345Numbersl";

@GenerateMicroBenchmark
public void validateShortKeyBinary() {
    StringUtils.validateKey(SHORT_KEY, true);
}

@GenerateMicroBenchmark
public void validateShortKeyAscii() {
    StringUtils.validateKey(SHORT_KEY, false);
}

@GenerateMicroBenchmark
public void validateLongKeyBinary() {
    StringUtils.validateKey(LONG_KEY, true);
}

@GenerateMicroBenchmark
public void validateLongKeyAscii() {
    StringUtils.validateKey(LONG_KEY, false);
}
</code></pre>

<p>}
```</p>

<p>Thanks for pointing it out Aleksey!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What's New in the Couchbase Java SDK 1.2]]></title>
    <link href="http://daschl.github.io/What-s-new-in-the-Couchbase-Java-SDK-1-2"/>
    <updated>2013-10-11T14:49:48+02:00</updated>
    <id>http://daschl.github.io/What-s-new-in-the-Couchbase-Java-SDK-1-2</id>
    <content type="html"><![CDATA[<p>For all users of our Java SDK, we prepared some nice additions for you. This post covers them in detail and shows how you can get more productive.</p>

<p>Note that this blog post assumes you are running the 1.2.1 release, because there have been some slight changes between 1.2.0 and 1.2.1 that affect for example the listener support and metrics collection.</p>

<h2>Maven Central Distribution</h2>

<p>From the 1.2.0 release forward, the Java SDK is distributed directly from Maven Central. This means that you don&rsquo;t need to include the Couchbase repository anymore. The following maven code is enough to get started (note that the groupId has changed):</p>

<p>``` xml
<dependencies></p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.couchbase.client&lt;/groupId&gt;
    &lt;artifactId&gt;couchbase-client&lt;/artifactId&gt;
    &lt;version&gt;1.2.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p></dependencies>
```</p>

<p>This will automatically load the latest spymemcached dependency in as well (for 1.2.0 it&rsquo;s 2.10.0). Before we dig into what has changed, <a href="http://docs.couchbase.com/couchbase-sdk-java-1.2/#release-notes-for-couchbase-client-library-java-120-ga-13-september-2013">here</a> are the release notes for a quick reference.</p>

<h2>Listener Support</h2>

<p>Until now, there were two ways to get the result of an asynchronous request. Either by blocking the current thread like so:</p>

<p>``` java
// do an async operation (returns immediately)
OperationFuture<Boolean> setFuture = client.set(&ldquo;key&rdquo;, &ldquo;value&rdquo;);</p>

<p>// block the current thread
Boolean result = setFuture.get();
```</p>

<p>Or to loop on the non-blocking future methods. This is especially helpful if you are dealing with a list of futures.</p>

<p>``` java
List&lt;OperationFuture<Boolean>> futures = new ArrayList&lt;OperationFuture<Boolean>>();
for (int i = 0; i &lt; 100; i++) {
  futures.add(client.set(&ldquo;key-&rdquo; + i, &ldquo;value&rdquo;));
}</p>

<p>while (!futures.isEmpty()) {
  Iterator&lt;OperationFuture<Boolean>> iter = futures.iterator();
  while (iter.hasNext()) {</p>

<pre><code>OperationFuture&lt;Boolean&gt; future = iter.next();
if (future.isDone()) {
  iter.remove();
}
</code></pre>

<p>  }
}
```</p>

<p>Now since 1.2.0, there is a new way to deal with responses &ndash; adding listeners. The idea is to supply a callback to the future which will be executed once the operation is done. A simple example is shown here:</p>

<p>``` java
OperationFuture<Boolean> setFuture = client.set(&ldquo;key&rdquo;, &ldquo;value&rdquo;);
setFuture.addListener(new OperationCompletionListener() {
  @Override
  public void onComplete(OperationFuture&lt;?> future) throws Exception {</p>

<pre><code>System.out.println(future.get());
</code></pre>

<p>  }
});
```</p>

<p>Note that the <code>.get()</code> method on the future will not block anymore because the result is already computed. Whatever you put in the callback method will be executed asynchronously on the thread pool. To see how flexible that approach is, let&rsquo;s rewrite the example from above waiting until the 100 futures are done.</p>

<p>``` java
final CountDownLatch latch = new CountDownLatch(100);
for (int i = 0; i &lt; 100; i++) {
  OperationFuture<Boolean> future = client.set(&ldquo;key-&rdquo; + i, &ldquo;value&rdquo;);
  future.addListener(new OperationCompletionListener() {</p>

<pre><code>@Override
public void onComplete(OperationFuture&lt;?&gt; future) throws Exception {
  latch.countDown();
}
</code></pre>

<p>  });
}
latch.await();
```</p>

<p>Here we are using a <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html">CountDownLatch</a> which waits on the current thread as long as it has been counted down a hundred times. Exactly what we need in our situation, but the code is much easier to read. More importantly, its much more flexible because other things like firing off a new request, querying a web service or calculating a result can be done.</p>

<p>It is also possible to override the default <code>ExecutorService</code> implementation with a custom one. This may be needed if the default behavior (Basically a upper-bounded cachedThreadPool) does not suite your needs. Also, you should use this approach if you create a bunch of <code>CouchbaseClient</code> instances so you can share the same service across all of them.</p>

<p>``` java
// Create the Builder
CouchbaseConnectionFactoryBuilder builder = new CouchbaseConnectionFactoryBuilder();</p>

<p>// Create a thread pool of 5 fixed threads
ExecutorService service = Executors.newFixedThreadPool(5);
// Set it in the builder
builder.setListenerExecutorService(service);</p>

<p>// Create the instance
CouchbaseClient client = new CouchbaseClient(builder.buildCouchbaseConnection(&hellip;));
```</p>

<h2>Enhanced Profiling Capabilities</h2>

<p>Getting insight into a running application is always difficult, so we set out to make it easier for you. We incorporated a library called <a href="http://metrics.codahale.com/">metrics</a> that profiles, depending on the configuration level chosen.</p>

<p>Before you can use it, you need to add this optional dependency:</p>

<p>``` xml
<dependency></p>

<pre><code>&lt;groupId&gt;com.codahale.metrics&lt;/groupId&gt;
&lt;artifactId&gt;metrics-core&lt;/artifactId&gt;
&lt;version&gt;3.0.1&lt;/version&gt;
</code></pre>

<p></dependency>
```</p>

<p>On the builder, there is a method that allows you to activate the the profiler:</p>

<p>``` java
CouchbaseConnectionFactoryBuilder builder = new CouchbaseConnectionFactoryBuilder();</p>

<p>// enable metric collection
builder.setEnableMetrics(MetricType.PERFORMANCE);
```</p>

<p>If you look at the <code>MetricType</code> enumeration you can see that there are three types of values you can choose from: OFF (which keeps metric collection off), PERFORMANCE (which only collects performance-relevant metrics) and DEBUG (which collects all kinds of metrics, including the performance ones). While the metrics library is quite efficient, keep in mind that metric collection takes some resources away from your application.</p>

<p>By default, the metric information will be printed out on the console every 30 seconds. You can run the following test code from your IDE and see how it looks:</p>

<p>``` java
CouchbaseConnectionFactoryBuilder builder = new CouchbaseConnectionFactoryBuilder();
builder.setEnableMetrics(MetricType.PERFORMANCE);</p>

<p>CouchbaseConnectionFactory cf =
  builder.buildCouchbaseConnection(Arrays.asList(new URI(&ldquo;<a href="http://127.0.0.1:8091/pools">http://127.0.0.1:8091/pools</a>&rdquo;)), &ldquo;default&rdquo;, &ldquo;&rdquo;);</p>

<p>CouchbaseClient client = new CouchbaseClient(cf);</p>

<p>while(true) {
  client.set(&ldquo;foo&rdquo;, &ldquo;bar&rdquo;);
  Thread.sleep(100);
}
```</p>

<p>Now wait 30 seconds and you&rsquo;ll see output like this in the console:</p>

<pre><code>10/8/13 12:04:14 PM ============================================================

-- Histograms ------------------------------------------------------------------
[MEM] Average Bytes read from OS per read
             count = 893
               min = 24
               max = 24
              mean = 24.00
            stddev = 0.00
            median = 24.00
              75% &lt;= 24.00
              95% &lt;= 24.00
              98% &lt;= 24.00
              99% &lt;= 24.00
            99.9% &lt;= 24.00
[MEM] Average Bytes written to OS per write
             count = 893
               min = 38
               max = 38
              mean = 38.00
            stddev = 0.00
            median = 38.00
              75% &lt;= 38.00
              95% &lt;= 38.00
              98% &lt;= 38.00
              99% &lt;= 38.00
            99.9% &lt;= 38.00
[MEM] Average Time on wire for operations (Âµs)
             count = 893
               min = 179
               max = 1730
              mean = 263.80
            stddev = 75.43
            median = 251.00
              75% &lt;= 280.00
              95% &lt;= 351.90
              98% &lt;= 425.36
              99% &lt;= 559.70
            99.9% &lt;= 1730.00

-- Meters ----------------------------------------------------------------------
[MEM] Request Rate: All
             count = 893
         mean rate = 9.92 events/second
     1-minute rate = 9.85 events/second
     5-minute rate = 9.68 events/second
    15-minute rate = 9.63 events/second
[MEM] Response Rate: All (Failure + Success + Retry)
             count = 893
         mean rate = 9.92 events/second
     1-minute rate = 9.85 events/second
     5-minute rate = 9.68 events/second
    15-minute rate = 9.63 events/second
</code></pre>

<p>I won&rsquo;t go into detail of all these metrics in this blog post, please refer to the documentation for a more complete picture. One more thing I want to show you is that the metrics library is also able to expose these metrics through JMX. All you need to do is set a system property that changes the output mode: <code>net.spy.metrics.reporter.type=jmx</code>. Other possible settings are <code>csv</code> and <code>slf4j</code>. If you choose a logger that prints out information at a given interval you can change it by setting <code>net.spy.metrics.reporter.interval</code> to anything else than 30.</p>

<p>So if you put the line <code>System.setProperty("net.spy.metrics.reporter.type", "jmx");</code> before the code shown above, you can open (for example) jConsole and switch to the MBeans tab of the application. You&rsquo;ll see a <code>metrics</code> subsection exposed that contains the same metrics as they would show up in the logs.</p>

<h2>CAS with Timeout</h2>

<p>Before 1.2.0, it was not possible in one command to do a <code>cas</code> update and set a new timeout at the same time. You had to do a second <code>touch</code> operation which was not efficient nor atomic. Now, the API exposes a new <code>cas()</code> method that allows you to pass in the timeout at the same time. It is easy to use:</p>

<p><code>java
client.cas("key", cas, nexExpiration, value);
</code></p>

<p>The asynchronous variations have been exposed since 1.2.1 as well.</p>

<h2>Initializing through Properties</h2>

<p>One thing that comes in handy if your cluster ip addresses change often is that you can now initialize a <code>CouchbaseClient</code> object based on system properties. Here is an example:</p>

<p>``` java
System.setProperty(&ldquo;cbclient.nodes&rdquo;, &ldquo;<a href="http://127.0.0.1:8091/pools">http://127.0.0.1:8091/pools</a>&rdquo;);
System.setProperty(&ldquo;cbclient.bucket&rdquo;, &ldquo;default&rdquo;);
System.setProperty(&ldquo;cbclient.password&rdquo;, &ldquo;&rdquo;);</p>

<p>CouchbaseConnectionFactoryBuilder builder = new CouchbaseConnectionFactoryBuilder();
CouchbaseConnectionFactory cf = builder.buildCouchbaseConnection();
CouchbaseClient client = new CouchbaseClient(cf);
```</p>

<p>Of course you can set these properties in your application container or during startup, so it&rsquo;s very flexible and not tied into your code directly. Note that if you forget to set one of these properties, the code will warn you like this:</p>

<pre><code>Exception in thread "main" java.lang.IllegalArgumentException: System property cbclient.nodes not set or empty
    at com.couchbase.client.CouchbaseConnectionFactory.&lt;init&gt;(CouchbaseConnectionFactory.java:160)
    at com.couchbase.client.CouchbaseConnectionFactoryBuilder$2.&lt;init&gt;(CouchbaseConnectionFactoryBuilder.java:318)
    at com.couchbase.client.CouchbaseConnectionFactoryBuilder.buildCouchbaseConnection(CouchbaseConnectionFactoryBuilder.java:318)
    at Main.main(Main.java:33)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:601)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)
</code></pre>

<h2>Other Changes</h2>

<p>In addition to the enhancements shown above, the release includes &ndash; as always &ndash; numerous smaller bugfixes. The default poll interval for <code>ReplicateTo</code> and <code>PersistTo</code> has been lowered to <code>10ms</code> to account for performance changes that went into the Couchbase Sever 2.2 release. Also, the client now uses the <code>CRAM-MD5</code> authentication mechanism automatically if the server supports it (since 2.2 as well).</p>

<p>These awesome new features should be enough reason to upgrade right now! If anything pops up that doesn&rsquo;t work as expected, please ask customer support or open a ticket <a href="http://www.couchbase.com/issues/browse/JCBC">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using the Reactor Processor for High-Performance TCP]]></title>
    <link href="http://daschl.github.io/Using-the-Reactor-Processor-for-High-Performance-TCP"/>
    <updated>2013-08-13T14:49:48+02:00</updated>
    <id>http://daschl.github.io/Using-the-Reactor-Processor-for-High-Performance-TCP</id>
    <content type="html"><![CDATA[<p>First, a disclaimer: the all-new <a href="https://github.com/reactor/reactor">Reactor</a> framework is still under heavy development, but it already provides a very promising basement for applications and libraries that need high throughput and low latency. We at <a href="http://www.couchbase.com/">Couchbase</a> aim to provide the highest throughput at the lowest latency, so it is very critical to build upon an infrastructure that can provide it. Current, we are performing early investigations for a possible &ldquo;next generation Java SDK&rdquo; and Reactor seems very promising so far.</p>

<p>This blog post shows you how to quickly set up a Processor (we&rsquo;ll see in a minute what that is) that dispatches requests to Consumers (also a very common term in Reactor). In our case, the Consumer is actually a TCP socket. Please note that the actual numbers, while impressive, can&rsquo;t be used for real world measurements. What you&rsquo;ll see here is a raw throughput test to define a baseline what can be expected under ideal conditions. We are also using localhost here to avoid network latency (which is the bottleneck for most network applications).</p>

<p>I&rsquo;m going to use a Couchbase server as an endpoint, but feel free to use whatever you want instead. The whole API is very generic and the consumers can be exchanged easily.</p>

<h2>Setup</h2>

<p>Before we can get started, all we need to do is include the <code>reactor-tcp</code> artifact from maven. Now you can do this through gradle, maven, ivy or what you want, but at this point, I would recommend you to check out the <a href="https://github.com/reactor/reactor">reactor</a> project directly from github and build it on your own, so you&rsquo;ll have the latest and greatest code in your local repository:</p>

<pre><code>$ git clone https://github.com/reactor/reactor.git
$ cd reactor
$ ./gradlew install
</code></pre>

<p>This will download and install everything you need. The next step is to create a maven or gradle project in your IDE, but I&rsquo;ll leave that part up to the reader. The maven dependency you need to include is:</p>

<p>``` xml
<dependency></p>

<pre><code>&lt;groupId&gt;org.projectreactor&lt;/groupId&gt;
&lt;artifactId&gt;reactor-tcp&lt;/artifactId&gt;
&lt;version&gt;1.0.0.BUILD-SNAPSHOT&lt;/version&gt;
</code></pre>

<p></dependency>
```</p>

<p>Or, for all gradle folks:</p>

<p>``` groovy
dependencies {</p>

<pre><code>compile 'org.projectreactor:reactor-tcp:1.0.0.BUILD-SNAPSHOT'
</code></pre>

<p>}
```</p>

<h2>The Processor</h2>

<p>Now, let&rsquo;s get to some actual code. The Processor is a very lightweight abstraction over the <a href="https://github.com/LMAX-Exchange/disruptor">LMAX Disruptor</a> a high performant RingBuffer. A RingBuffer provides much better characteristics than a normal Queue, and the Disruptor is heavily optimized for dispatching tasks in the nanosecond area (which means millions of operations per second). I recommend you to read <a href="https://github.com/LMAX-Exchange/disruptor/blob/master/docs/Disruptor.docx">this paper</a> and also check out talks by <a href="http://mechanical-sympathy.blogspot.co.at/">Martin Thompson</a> if you are interested.</p>

<p>The basic idea is that we decouple consumers from producers, so that each of them can work on their own pace (not blocking each other) and also benefiting from batching if the producers are faster than the consumers. We&rsquo;ll see why this is particularly important with TCP in a second.</p>

<p>A <code>Processor</code> can be created by instantiating a <code>ProcessorSpec</code> and defining some mandatory options. Then, the <code>Processor</code> is built for us.</p>

<p>``` java
ProcessorSpec&lt;Event<Buffer>> writeProcessor = new ProcessorSpec&lt;Event<Buffer>>()</p>

<pre><code>.dataSupplier(new Supplier&lt;Event&lt;Buffer&gt;&gt;() {
    @Override
    public Event&lt;Buffer&gt; get() {
      return new Event&lt;Buffer&gt;(new Buffer());
    }
})
.consume(new Node("127.0.0.1", environment))
.get();
</code></pre>

<p>```</p>

<p>Note that this <code>Spec</code> pattern is very common in reactor, as it allows for very easy and yet flexible object creation. There are a few things that we need to cover.</p>

<p>First, the generic type here is <code>Event&lt;Buffer&gt;</code>. The producers will wrap the payload (here we use raw <code>Buffers</code>) in an <code>Event</code> and the consumers will unwrap and use it properly. The <code>Event</code> type also allows for headers that can be used for custom routing, but we won&rsquo;t cover that here.</p>

<p>Second, the <code>dataSupplier</code> is a speciality of the Disruptor RingBuffer. In order to minimize garbage collection and make effective use of memory layout, we need to pre-allocate our container objects. They will be reused throughout the application and will never be garbage collected.</p>

<p>Third, through the <code>consume</code> method we can tell the <code>Processor</code> who will be notified when new data is added to the RingBuffer. In our case, the <code>Node</code> represents the TCP client which we&rsquo;ll build in a second.</p>

<p>Now, how do we write to the Processor? Let&rsquo;s add a simple method that does it for us:</p>

<p>``` java
public void write(final Buffer data) {</p>

<pre><code>final Operation&lt;Event&lt;Buffer&gt;&gt; op = writeProcessor.get();
op.get().setData(data);
op.commit();
</code></pre>

<p>}
```</p>

<p>Here, we get a <code>Operation</code> out of the processor (that wraps our data) and override it with the data that we actually want to store this time. You can see that we are not allocating new objects in the RingBuffer, we just use the old one that has been provided for us. With the <code>commit</code> method we put it back into the RingBuffer. Actually, behind the scenes, it makes use of Sequences and Barriers inside the RingBuffer, but this is completely hidden from us.</p>

<p>Here is the full code for the lazy reader:</p>

<p>``` java
import reactor.core.Environment;
import reactor.core.processor.Operation;
import reactor.core.processor.Processor;
import reactor.core.processor.spec.ProcessorSpec;
import reactor.event.Event;
import reactor.function.Supplier;
import reactor.io.Buffer;</p>

<p>public class MessageDispatcher {</p>

<p>  private final Environment environment;</p>

<p>  private final Processor&lt;Event<Buffer>> writeProcessor;</p>

<p>  public MessageDispatcher() {</p>

<pre><code>this(new Environment());
</code></pre>

<p>  }</p>

<p>  MessageDispatcher(final Environment env) {</p>

<pre><code>environment = env;

writeProcessor = new ProcessorSpec&lt;Event&lt;Buffer&gt;&gt;()
  .dataSupplier(new Supplier&lt;Event&lt;Buffer&gt;&gt;() {
    @Override
    public Event&lt;Buffer&gt; get() {
      return new Event&lt;Buffer&gt;(new Buffer());
    }
  })
  .consume(new Node("127.0.0.1", environment))
  .get();
</code></pre>

<p>  }</p>

<p>  public void write(final Buffer data) {</p>

<pre><code>final Operation&lt;Event&lt;Buffer&gt;&gt; op = writeProcessor.get();
op.get().setData(data);
op.commit();
</code></pre>

<p>  }</p>

<p>}
```</p>

<p>One final note before we move on: did you spot the <code>Environment</code> here? This is also a common theme in the Reactor framework. The <code>Environment</code> is used in many places to signal information about &ndash; who would have thought that &ndash; the JVM environment. The general recommendation is to create only one <code>Environment</code> instance per JVM, so we happily pass it around in our small application.</p>

<h2>The Consumer</h2>

<p>Before we get into the nitty-gritty network details, let&rsquo;s add a consumer that just prints out the data that he &ldquo;sees&rdquo;. If you want to try this sample, make sure to change the previous code temporarily from <code>.consume(new Node(...))</code> to <code>.consume(new EchoConsumer())</code>.</p>

<p>``` java
public class EchoConsumer implements Consumer&lt;Event<Buffer>> {</p>

<p>  @Override
  public void accept(final Event<Buffer> bufferEvent) {</p>

<pre><code>System.out.println(Arrays.toString(bufferEvent.getData().asBytes()));
</code></pre>

<p>  }</p>

<p>}
```</p>

<p>The <code>accept</code> method is always called once there is information available on the Processor. Let&rsquo;s add a simple test case to verify that this works:</p>

<p>``` java
import org.junit.Test;
import reactor.io.Buffer;</p>

<p>public class MessageDispatcherTest {</p>

<p>  @Test
  public void echoSomeGarbage() {</p>

<pre><code>MessageDispatcher dispatcher = new MessageDispatcher();
dispatcher.write(Buffer.wrap("Hello World!"));
</code></pre>

<p>  }</p>

<p>}
```</p>

<p>Now if we run this test, we should see <code>[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]</code> printed on the console &ndash; great! This is the byte array representation of our wrapped buffer. Of course we could make our lives easier and use <code>Strings</code> instead of <code>Buffer</code> in our implementation, but the <code>Buffer</code> works much better with network communication.</p>

<p>The next step would be to send the data over the network. Let&rsquo;s replace our Consumer with a more intelligent one. Be aware that the <code>TcpClient</code> that you&rsquo;ll see doesn&rsquo;t communicate with Java NIO directly &ndash; it makes use of the excellent <a href="http://netty.io/">Netty</a> project which provides a convenient and performant wrapper around NIO and OIO (we use NIO here).</p>

<p>``` java
public class Node implements Consumer&lt;Event<Buffer>> {</p>

<p>  private final TcpClient&lt;Buffer, Buffer> client;
  private TcpConnection&lt;Buffer, Buffer> conn = null;</p>

<p>  public Node(String hostname, Environment env) {</p>

<pre><code>client = new TcpClientSpec&lt;Buffer, Buffer&gt;(NettyTcpClient.class)
  .env(env)
  .connect(hostname, 11210)
  .get();

try {
  conn = client.open().await();
} catch (InterruptedException e) {
  e.printStackTrace();
}
</code></pre>

<p>  }</p>

<p>  @Override
  public void accept(final Event<Buffer> bufferEvent) {</p>

<pre><code>Buffer buf = bufferEvent.getData();

final CountDownLatch latch = new CountDownLatch(1);
conn.send(buf, new Consumer&lt;Boolean&gt;() {
  @Override
  public void accept(final Boolean success) {
    latch.countDown();
  }
});

try {
  latch.await(1, TimeUnit.SECONDS);
} catch (final Exception ex) {
  throw new RuntimeException("Something went wrong while waiting :(", ex);
}
</code></pre>

<p>  }</p>

<p>}
```</p>

<p>While this might seem like a lot of code, it&rsquo;s not so bad. We do two things here. During object construction, we create a new <code>TcpClient</code> through the <code>TcpClientSpec</code> (see the Spec again?) and pass it the environment and the socket to connect to. The next thing we need to do is actually open the connection and wait until finished.</p>

<p>Now that we have an open connection, we can write to it. Since everything is non-blocking in Reactor, so is socket writing. In order to not overwhelm the underlying infrastructure, we have to wait until it is actually finished before moving on to handle the next <code>Event</code> in the Processor. We do this by using a <code>CountDownLatch</code>, which will be counted down once the writing has finished. In our simple example we just fail if it took longer than one second. In a real application, one could report errors or retry with Backoff.</p>

<p>Before we can run that code, we need to add a test case to make it all work.</p>

<p>``` java
Buffer[] buffers = new Buffer[10];</p>

<p>@Before
public void initBuffers() {</p>

<pre><code>for (int i = 0; i &lt; 10; i++)  {
    Buffer buf = new Buffer(30, false);
    buf.append((byte)0x80); // Magic Byte
    buf.append((byte)0x09); // GETQ Opcode
    buf.append(new byte[] {0x00, 0x03}); // 3 byte keylength (KEY)
    buf.append((byte)0x00); // Extra Length
    buf.append((byte)0x00); // data type
    buf.append(new byte[] {0x00, 0x00}); // reserved
    buf.append(new byte[] {0x00, 0x00, 0x00, 0x03}); // total body size
    buf.append(new byte[] {0x00, 0x00, 0x00, 0x00}); // Opaque
    buf.append(new byte[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}); // CAS
    buf.append(new byte[] {0x65, 0x6F, (byte)(i % 9)});
    buffers[i] = buf;
}
</code></pre>

<p>}</p>

<p>@Test
public void giveItSomeLoad() {</p>

<pre><code>MessageDispatcher dispatcher = new MessageDispatcher();

long amountOfOps = 100000000;
for (long i = 0; i &lt; amountOfOps; i++) {
    dispatcher.write(new Buffer(buffers[(int)(i % 9)]).flip());
}
</code></pre>

<p>}
```</p>

<p>To actually simulate something real, this test creates ten buffer instances with Couchbase messages. Those familiar with the memcached binary protocol can identify it as a GETQ request. This means it does not return anything when the key is not found (which is what we want, because in this case we want to benchmark the upper limit for write throughput and not concern us with parsing of error responses). Once the data is created, we run a given amount of operations and call the <code>write</code> method on the <code>MessageDispatcher</code>.</p>

<h2>Batch all the things!</h2>

<p>If we run this, we get a &ndash; very disappointing &ndash; number of only 50K ops/s. In addition, we get lots of CPU usage on the Java process (100% and more on a quad core processor here). Why is it so slow? The answer is: network overhead. In our case, we send out 27 byte chunks over the network. With all the TCP, IP and Ethernet headers, there is lots of unnecessary overhead involved that puts down our performance. The answer to that is batching! If our producers are faster than the consumers, we can batch the intermediate data up into a buffer and send it over the wire in one chunk. This will give us a much better goodput ratio.</p>

<p>To help us with batching the Disruptor and the Processor expose the start end end of a batching phase to our consumer. To get this information, we need to extend from the <code>BatchConsumer</code> instead of the regular <code>Consumer</code>. Let&rsquo;s refactor our node and add some batching characteristics:</p>

<p>``` java
public class BatchingNode implements BatchConsumer&lt;Event<Buffer>> {</p>

<p>  private final TcpClient&lt;Buffer, Buffer> client;
  private TcpConnection&lt;Buffer, Buffer> conn = null;
  private Buffer writeBuffer;</p>

<p>  public BatchingNode(String hostname, Environment env) {</p>

<pre><code>client = new TcpClientSpec&lt;Buffer, Buffer&gt;(NettyTcpClient.class)
  .env(env)
  .connect(hostname, 11210)
  .get();

try {
  conn = client.open().await();
} catch (InterruptedException e) {
  e.printStackTrace();
}

writeBuffer = new Buffer(1500, true);
</code></pre>

<p>  }</p>

<p>  @Override
  public void start() {
  }</p>

<p>  @Override
  public void end() {</p>

<pre><code>flush();
</code></pre>

<p>  }</p>

<p>  @Override
  public void accept(final Event<Buffer> bufferEvent) {</p>

<pre><code>Buffer buf = bufferEvent.getData();

if (writeBuffer.remaining() &lt;= buf.remaining()) {
  flush();
}

writeBuffer.append(buf);
</code></pre>

<p>  }</p>

<p>  private void flush() {</p>

<pre><code>final CountDownLatch latch = new CountDownLatch(1);
writeBuffer.flip();
conn.send(writeBuffer, new Consumer&lt;Boolean&gt;() {
  @Override
  public void accept(final Boolean success) {
    latch.countDown();
  }
});
try {
  latch.await(1, TimeUnit.SECONDS);
} catch (final Exception ex) {
  throw new RuntimeException("got ex", ex);
}
writeBuffer.clear();
</code></pre>

<p>  }</p>

<p>}
```</p>

<p>The code here is not much different. Note that we refactored the writing part out into the <code>flush</code> method. In the <code>accept</code> method, we write to the network if the buffer is full, otherwise we just add it to our write buffer. Note that we also need to <code>flush</code> if the batching is over (notified through the <code>end</code> method), otherwise we would potentially keep data around for a longer time than needed (and latency is still important to us).</p>

<p>Let&rsquo;s run the test case again&hellip; now we get 500k ops/s with only 40% CPU load on the java process! Now that&rsquo;s what I call an improvement!</p>

<h2>Summary</h2>

<p>This was a very quick introduction into the Processor, just one piece in the very promising Reactor framework. There is so much more to blog about in the future, so stay tuned!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Useful Couchbase Resources & Blog Posts]]></title>
    <link href="http://daschl.github.io/Useful-Couchbase-Resources-Blog-Posts"/>
    <updated>2013-08-06T14:49:48+02:00</updated>
    <id>http://daschl.github.io/Useful-Couchbase-Resources-Blog-Posts</id>
    <content type="html"><![CDATA[<p>The following list is a convenient way to get access to lots of resources, blog posts and material that have been shared throughout the past months. I tried to separate them by area, but of course lots of them overlap to some extent.</p>

<p>They are sorted by date (so you&rsquo;ll find the most recent ones on top) and include the author where possible. Be aware that some of the older articles may already be outdated  or not 100% accurate.</p>

<p>I&rsquo;ll try to update this page as new articles get published, so it may pay off to come back here from time to time and check out the topmost ones. If you want to see your article included, post them in the comments!</p>

<h2>Starting Out</h2>

<ul>
<li><a href="http://www.couchbase.com/docs/couchbase-manual-2.1.0/">Official Couchbase Server 2.1 Manual</a>: The official manual and a good starting point for all kinds of general-purpose and architectural questions.</li>
<li><a href="http://www.couchbase.com/docs/couchbase-devguide-2.1.0/">Couchbase Server 2.1 Developer Guide</a>: The developer guide is particularly useful for developers that are new to document modeling and general app-related questions.</li>
<li><a href="http://www.couchbase.com/communities">The Community Portal</a>: Starting point for all SDK-related questions and links.</li>
<li>2013-04-24 <a href="http://blog.couchbase.com/top-10-things-ops-sys-admin-must-know-about-couchbase">Top 10 things an Ops / Sys admin must know about Couchbase</a>: Ten short rules that sys admins that maintain Couchbase clusters should keep in mind.</li>
<li>2012-07-06 <a href="http://tugdualgrall.blogspot.co.at/2012/07/couchbase-101-install-store-and-query.html">Couchbase 101 : Install, Store and Query Data (tgrall)</a>: A very basic introduction for people starting out, teaching the very basics in a hands-on fashion.</li>
</ul>


<h2>Installation &amp; Infrastructure</h2>

<ul>
<li><a href="http://www.couchbase.com/docs/couchbase-manual-2.1.0/couchbase-getting-started.html">Official Installation Guide for 2.1</a>: The official installation guide, read this before installing on production systems.</li>
<li>2013-08-05 <a href="http://trondn.blogspot.no/2013/08/running-couchbase-211-on-smartos.html">Running Couchbase 2.1.1 on SmartOS (trondn)</a>: Learn how to &ndash; step by step &ndash; compile and run a Couchbase cluster on SmartOS. This is for all the Solaris fans out there!</li>
<li>2013-07-22 <a href="http://blog.couchbase.com/deploying-couchbase-chef">Deploying Couchbase with Chef (ketakigangal)</a>: If you use Chef to automate your infrastructure, this blog post shows you how to integrate Couchbase with it.</li>
<li>2013-07-11 <a href="http://tugdualgrall.blogspot.co.at/2013/07/deploy-your-nodecouchbase-application.html">Deploy your Node/Couchbase application to the cloud with Clever Cloud (tgrall)</a>: You&rsquo;ll learn how to deploy your Node.JS app with Couchbase onto &ldquo;clever cloud&rdquo;, a PaaS provider.</li>
<li>2013-06-27 <a href="http://www.ebruakagunduz.com/2013/06/nagios-plugin-to-monitor-couchbase.html?spref=tw">Nagios plugin to monitor Couchbase (Ebru Akagündüz)</a>: If you are using Nagios to monitor your infrastructure, this post shows you how to integrate Couchbase with a single plugin.</li>
<li>2013-05-31 <a href="http://tugdualgrall.blogspot.co.at/2013/05/create-couchbase-cluster-in-one-command.html">Create a Couchbase cluster in less than a minute with Ansible (tgrall)</a>: Create a Couchbase cluster automatically with Ansible, a systems automation framework like chef.</li>
<li>2013-05-27 <a href="http://nitschinger.at/A-Couchbase-Cluster-in-Minutes-with-Vagrant-and-Puppet">A Couchbase Cluster in Minutes with Vagrant and Puppet (daschl)</a>: If you want to setup a 4 node cluster with couchbase in minutes, this blog post shows you how to do it.</li>
</ul>


<h2>Document Design &amp; Data Import/Export</h2>

<ul>
<li>2013-07-18 <a href="http://tugdualgrall.blogspot.co.at/2013/07/how-to-implement-document-versioning.html">How to implement Document Versioning with Couchbase (tgrall)</a>: See how to implement document versioning by using a key-based approach. Uses the Java SDK, but can be adapted for all languages.</li>
<li>2013-07-08 <a href="http://dev.theladders.com/2013/07/denormalize-the-datas-for-great-good">Denormalize the Datas for Great Good (John Connolly)</a>: See how TheLadders benefited from denormalizing its dataset and using Couchbase, greatly reducing their response times.</li>
<li>2013-07-03 <a href="http://tugdualgrall.blogspot.co.at/2013/07/sql-to-nosql-importing-data-from-rdbms.html">SQL to NoSQL : Copy your data from MySQL to Couchbase (tgrall)</a>: A Java-based tool to import data from a SQL database into Couchbase.</li>
</ul>


<h2>Views</h2>

<ul>
<li>2013-07-25 <a href="http://blog.couchbase.com/caching-queries-couchbase-high-performance">Caching queries in Couchbase for high performance (Alexis Roos)</a>: Learn how to cache view results for better performance.</li>
<li>2013-07-12 <a href="http://blog.couchbase.com/calculating-average-document-size-documents-stored-couchbase">Calculating average document size of documents stored in Couchbase. (Alexis Roos)</a>: With a simple map and a custom reduce function, one can easily calculate the average document size in the bucket.</li>
<li>2013-06-14 <a href="http://avsej.net/2013/analyzing-binary-data-in-couchbase">Analyzing Binary Data in Couchbase (avsej)</a>: Shows how to access binary (non-json) data from a View. Uses ruby to store the data, but can be adapted to any language.</li>
<li>2013-02-18 <a href="http://tugdualgrall.blogspot.co.at/2013/02/how-to-get-latest-document-by-datetime.html">How to get the latest document by date/time field (tgrall)</a>: A simple example on how to sort View-data based on a timestamp.</li>
<li>2013-02-13 <a href="http://tugdualgrall.blogspot.co.at/2013/02/introduction-to-collated-views-with.html">Introduction to Collated Views with Couchbase 2.0 (tgrall)</a>: Views can also be used to output &ldquo;master/detail&rdquo;-like scenarios. This post shows how.</li>
</ul>


<h2>Java SDK &amp; JVM</h2>

<ul>
<li><a href="http://www.couchbase.com/communities/java/getting-started">Getting Started &amp; Download</a>: The official &ldquo;Getting Started&rdquo; page for the Java SDK. Introduction, Tutorial and Downloads.</li>
<li>2013-05-16 <a href="http://nitschinger.at/Logging-with-the-Couchbase-Java-Client">Logging with the Couchbase Java Client (daschl)</a>: An in-depth post about how to correctly configure logging for the Java SDK (and the underlying spymemcached library).</li>
<li>2013-04-17 <a href="http://nitschinger.at/Couchbase-Java-SDK-Internals">Couchbase Java SDK Internals (daschl)</a>: A very detailed post about the inner workings of the Java SDK. Recommended for advanced users who want to understand more of the internals.</li>
<li>2012-12-30 <a href="http://tugdualgrall.blogspot.co.at/2012/12/couchbase-101-create-views-mapreduce.html">Couchbase 101: Create views (MapReduce) from your Java application (tgrall)</a>: How to create views and design documents directly from the Java SDK.</li>
<li>2012-11-05 <a href="http://tugdualgrall.blogspot.co.at/2012/11/couchbase-create-large-dataset-using.html">Couchbase : Create a large dataset using Twitter and Java (tgrall)</a>: Feed data from Twitter directly into your Couchbase cluster through the Java SDK.</li>
<li>2012-04-26 <a href="http://nitschinger.at/Accessing-Couchbase-from-Scala">Accessing Couchbase from Scala (daschl)</a>: How to access the Couchbase Java SDK from the Scala programing language.</li>
</ul>


<h2>.NET</h2>

<ul>
<li><a href="http://www.couchbase.com/communities/net/getting-started">Getting Started &amp; Download</a>: The official &ldquo;Getting Started&rdquo; page for the .NET SDK. Introduction, Tutorial and Downloads.</li>
<li>2013-06-14 <a href="http://vimeo.com/68378224">Video: Code-First NoSQL with .NET and Couchbase (John Zablocki)</a>: A video where John Zablocki gives an introduction into NoSQL development and especially with Couchbase.</li>
<li>2013-03-06 <a href="http://blog.couchbase.com/net-couchbase-client-instrumentation-aspnet-and-glimpse">.NET Couchbase Client Instrumentation with ASP.NET and Glimpse (John Zablocki)</a>: See how to get your Couchbase server-side logging errors easily displayed in the browser console. Very helpful during development.</li>
<li>2013-02-01 <a href="http://blog.couchbase.com/moving-no-schema-stack-c-and-dynamic-types">Moving No Schema up the Stack with C# and Dynamic Types (John Zablocki)</a>: This blog post shows how to store schemaless data with both dictionaries and C#&rsquo;s dynamic typing.</li>
<li>2013-01-04 <a href="http://blog.couchbase.com/xdcr-aspnet-and-nancy">XDCR with ASP.NET and Nancy (John Zablocki)</a>: Learn how to build an XDCR endpoint (like ElasticSearch integration) and read the data through our XDCR mechanisms.</li>
<li>2012-10-23 <a href="http://blog.couchbase.com/using-c-domain-objects-define-couchbase-views">Using C# Domain Objects to Define Couchbase Views (John Zablocki)</a>: How to automatically create DesignDocuments based of C# domain objects.</li>
<li>2012-10-05 <a href="http://blog.couchbase.com/new-visual-studio-code-snippets-net-couchbase-client-library">New Visual Studio Code Snippets for the .NET Couchbase Client Library (John Zablocki)</a>: A collection of helpful snippets in the day-to-day development process.</li>
<li>2012-09-20 <a href="http://blog.couchbase.com/strongly-typed-views-net-client-library">Strongly Typed Views with the .NET Client Library (John Zablocki)</a>: Learn how to map View responses directly onto domain objects.</li>
<li>2012-08-01 <a href="http://blog.couchbase.com/introducing-couchbase-aspnet-outputcache-provider">Introducing the Couchbase ASP.NET OutputCache Provider (John Zablocki)</a>: A short post on how to use Couchbase for easy caching in the ASP.NET environment.</li>
</ul>


<h2>PHP</h2>

<p>(Note: some of these posts are outdated in the way that currently the &ldquo;way to go&rdquo; when installing the PHP SDK is through PECL. See the the <a href="http://www.couchbase.com/communities/php/getting-started">Getting Started &amp; Download</a> guide for more information.)</p>

<ul>
<li><a href="http://www.couchbase.com/communities/php/getting-started">Getting Started &amp; Download</a>: The official &ldquo;Getting Started&rdquo; page for the PHP SDK. Introduction, Tutorial and Downloads.</li>
<li>2013-04-02  <a href="http://trondn.blogspot.co.at/2013/04/couchbase-php-xampp-and-windows.html">Couchbase, PHP, XAMPP and Windows (trondn)</a>: A short post on how to use the PHP SDK from Microsoft Windows.</li>
<li>2013-04-01 <a href="http://trondn.blogspot.co.at/2013/04/building-couchbase-php-driver-on-ubuntu.html">Building Couchbase PHP driver on Ubuntu (trondn)</a>: Learn how to build the Couchbase driver on Ubuntu and use it in a simple program.</li>
<li>2013-02-04 <a href="http://trondn.blogspot.co.at/2013/02/accessing-couchbase-from-php-on-your-mac.html">Accessing Couchbase from PHP on your Mac! (trondn)</a> Building and running the SDK on your Mac is easy, learn how to do it in this post.</li>
<li>2012-11-01 <a href="http://trondn.blogspot.co.at/2012/11/building-php-extension-for-couchbase-on.html">Building the PHP extension for Couchbase on Microsoft Windows! (trondn)</a>: Learn how to compile the SDK on Windows using Visual Studio 2008.</li>
<li>2012-06-25 <a href="http://nitschinger.at/How-to-store-PHP-sessions-in-Couchbase">How to store PHP sessions in Couchbase (daschl)</a>: This post shows how to store PHP sessions in Couchbase using different mechanims (not only the official SDK).</li>
<li>2012-06-21 <a href="http://nitschinger.at/Using-Couchbase-as-a-flexible-session-store">Using Couchbase as a flexible session store (daschl)</a>: With Couchbase Server 2.0, JSON data and Views, its easy to run metrics over your sessions and identify user behavior. Learn how in this post.</li>
</ul>


<h2>C &amp; Go</h2>

<ul>
<li><a href="http://www.couchbase.com/communities/c/getting-started">Getting Started &amp; Download with the C SDK</a>: The official &ldquo;Getting Started&rdquo; page for the C SDK. Introduction, Tutorial and Downloads.</li>
<li><a href="https://github.com/couchbaselabs/go-couchbase">Official Go Client Repository</a>: The Go repository with code and simple examples.</li>
</ul>


<h2>Ruby</h2>

<ul>
<li><a href="http://www.couchbase.com/communities/ruby/getting-started">Getting Started &amp; Download</a>: The official &ldquo;Getting Started&rdquo; page for the Ruby SDK. Introduction, Tutorial and Downloads.</li>
<li>2013-02-23 <a href="http://avsej.net/links/2013/couchbase-and-rails/">Couchbase and Rails Talk (avsej)</a>: A presentation by our lead Ruby SDK developer on how to integrate it with Ruby on Rails.</li>
<li>2013-02-11 <a href="http://blog.couchbase.com/using-couchbase-ruby-gem-eventmachine">Using Couchbase Ruby Gem with EventMachine (avsej)</a>: This post shows how to use the Ruby SDK together with the high performance EventMachine (custom protocols and performance for TCP/IP) gem.</li>
</ul>


<h2>Node.JS</h2>

<ul>
<li>2013-03-06 <a href="http://tugdualgrall.blogspot.co.at/2013/03/easy-application-development-with.html">Easy application development with Couchbase, Angular and Node (tgrall)</a>: Storing Ideas and Votes in Couchbase with Angular and NodeJS.</li>
<li>2013-01-04 <a href="http://tugdualgrall.blogspot.co.at/2013/01/getting-started-with-couchbase-and.html">Getting started with Couchbase and node.js on Windows (tgrall)</a>: How to install and use the NodeJS Couchbase client library on Windows.</li>
<li>2012-11-13 <a href="http://tugdualgrall.blogspot.co.at/2012/11/building-chat-application-using-nodejs.html">Building a chat application using Node.js and Couchbase (tgrall)</a>: A nice chat application using Couchbase, NodeJS and socket.io for &ldquo;real time&rdquo; feeling.</li>
<li>2012-09-24 <a href="http://tugdualgrall.blogspot.co.at/2012/09/create-simple-nodejs-and-couchbase.html">Create a Simple Node.js and Couchbase application&hellip; on OS X (tgrall)</a> A simple (but maybe outdated) tutorial on how to use the NodeJS driver from OSX.</li>
</ul>


<h2>Python</h2>

<ul>
<li><a href="http://www.couchbase.com/communities/python/getting-started">Getting Started &amp; Download</a>: The official &ldquo;Getting Started&rdquo; page for the Python SDK. Introduction, Tutorial and Downloads.</li>
<li>2013-06-21 <a href="http://mnunberg.github.io/2013/python-extension-windows-binaries">Python Extension Windows Binaries (mnunberg)</a>: A tale by our maintainer of the Python SDK on how to upload Windows binaries to PyPi.</li>
<li>2013-05-30 <a href="http://blog.couchbase.com/whats-python-couchbase-sdk">What&rsquo;s up with the Python Couchbase SDK (volker)</a>: A rundown of the latest changes on the Python SDK.</li>
</ul>


<h2>Ecosystem</h2>

<ul>
<li>2013-07-31 <a href="http://www.ortussolutions.com/blog/couchbase-cluster-setup-orm-secondary-cache-introduction">Couchbase: Cluster Setup + ORM Secondary Cache Introduction (Brad Wood)</a>: Using ColdFusion and looking for a secondary cache implementation? Look no further.</li>
<li>2013-07-22 <a href="http://blog.jeroenreijn.com/2013/07/visitor-analysis-with-couchbase-elasticsearch.html">Real-time visitor analysis with Couchbase, Elasticsearch and Kibana (Jeroen Reijn)</a>: A great post on a customer&rsquo;s use case for real-time visitor analysis.</li>
</ul>


<h2>Troubleshooting</h2>

<ul>
<li><a href="http://www.couchbase.com/docs/couchbase-manual-2.1.0/couchbase-troubleshooting.html">Official troubleshooting Guide</a>: The best place to start if something goes wrong on the server and you don&rsquo;t know why.</li>
<li>2012-12-26 <a href="http://tugdualgrall.blogspot.co.at/2012/12/what-to-do-if-your-couchbase-server.html">What to do if your Couchbase Server does not start? (tgrall)</a>: If you have troubles getting older Couchbase Server 2.0 versions to run on Windows, this post is for you.</li>
</ul>


<h2>Fun Stuff</h2>

<ul>
<li><a href="https://github.com/couchbaselabs/DeveloperDay">Example code for lots of SDKs and Languages</a>: Our DeveloperDay material with hands-on code examples to try and learn.</li>
<li>2013-06-18 <a href="http://nitschinger.at/Fun-with-Couchbase-Views-and-Message-Pack">Fun with Couchbase Views and MessagePack (daschl)</a>: While JSON is tried and true, with a little twiggling and some fun you can get Couchbase Views to speak MessagePack!</li>
<li>2013-04-29 <a href="http://tugdualgrall.blogspot.co.at/2013/04/screencast-fun-with-couchbase-mapreduce.html">Screencast : Fun with Couchbase, MapReduce and Twitter (tgrall)</a>: A Screencast on importing Twitter data into Couchbase and analyzing it on the fly through Views.</li>
</ul>


<p>Last Updated: 2013-08-06 (daschl)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Printing JVM Generated Assembler on Mac OS X]]></title>
    <link href="http://daschl.github.io/Printing-JVM-generated-Assembler-on-Mac-OS-X"/>
    <updated>2013-06-24T14:49:48+02:00</updated>
    <id>http://daschl.github.io/Printing-JVM-generated-Assembler-on-Mac-OS-X</id>
    <content type="html"><![CDATA[<p>Thankfully, the JVM abstracts all of the nitty gritty details from us. Sometimes though, we need to peel off the first layers and see what&rsquo;s going on underneath. If you are curious (and here may be dragons) and want to learn about the actual <a href="http://en.wikipedia.org/wiki/Assembly_language">assembler</a> that your code is generating, the JVM provides mechanisms to inspect it.</p>

<p>Since I wanted to make it work on my development machine and didn&rsquo;t find something comprehensive for Mac, here is how to do it.</p>

<p>First, make sure to have a more or less recent JDK installed. Mac ships with Java 6, but I think you want to upgrade to 7. You can grab the JDK packages from <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html">here</a> if you haven&rsquo;t already.</p>

<pre><code>~ $ java -version
java version "1.7.0_17"
Java(TM) SE Runtime Environment (build 1.7.0_17-b02)
Java HotSpot(TM) 64-Bit Server VM (build 23.7-b01, mixed mode)
</code></pre>

<p>Now to enable the ASM output, you need to pass in two flags, namely <code>UnlockDiagnosticVMOptions</code> and <code>PrintAssembly</code>. Because the generated ASM is different for each runtime, you need to pass it to the <code>java</code> command and not <code>javac</code>.</p>

<p>Create a very simple script like this and name it <code>Main.java</code>:</p>

<p>``` java
public class Main {</p>

<pre><code>public static void main(String[] args) {
    System.out.println("Hello World");
}
</code></pre>

<p>}
```</p>

<p>Now, we&rsquo;re going to compile and run it with those options:</p>

<pre><code>michael@daschlbook ~/Downloads/java $ javac Main.java &amp;&amp; java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly Main
Java HotSpot(TM) 64-Bit Server VM warning: PrintAssembly is enabled; turning on DebugNonSafepoints to gain additional output
Could not load hsdis-amd64.dylib; library not loadable; PrintAssembly is disabled
Hello World
</code></pre>

<p>Woops, not what we expected. The code did compile properly, but HotSpot complains about <code>hsdis-amd64.dylib</code>. I had to google a bit to find it, but you can download <a href="https://kenai.com/projects/base-hsdis/downloads/download/gnu-versions/hsdis-amd64.dylib">the file</a> from <a href="https://kenai.com/projects/base-hsdis/downloads/directory/gnu-versions">here</a>.</p>

<p>Now we need to put it somewhere to make it loadable, and the easiest thing I found is to put it onto <code>LD_LIBRARY_PATH</code>. Make sure to not override any other settings, but in my case the variable was empty so its straightforward.</p>

<pre><code>export LD_LIBRARY_PATH=~/PathToFile/
</code></pre>

<p>If you run our command again from before, you should now see &ldquo;beautiful&rdquo; ASM code generated:</p>

<pre><code>michael@daschlbook ~/Downloads/java $ javac Main.java &amp;&amp; java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly Main
Java HotSpot(TM) 64-Bit Server VM warning: PrintAssembly is enabled; turning on DebugNonSafepoints to gain additional output
Loaded disassembler from hsdis-amd64.dylib
Decoding compiled method 0x000000010ac74150:
  0x000000010ac742ba: add   [eax], al
[Disassembling for mach='i386(base-hsdis)']
[Entry Point]
[Constants]
  # {method} 'hashCode' '()I' in 'java/lang/String'
  #           [sp+0x30]  (sp of caller)
  0x000000010ac742a0: inc   esp
  0x000000010ac742a1: mov   edx, [esi+0x8]
  0x000000010ac742a4: dec   ecx
  0x000000010ac742a5: shl   edx, 3
  0x000000010ac742a8: dec   ecx
  0x000000010ac742a9: cmp   eax, edx
  0x000000010ac742ab: jnz   0x000000000ac4ba60  ;   {runtime_call}
  0x000000010ac742b1: nop
  0x000000010ac742b4: invalid   0x0f #size=0
  0x000000010ac742b5: pop   ds
  0x000000010ac742b6: test  [eax], al
  0x000000010ac742b8: add   [eax], al
  0x000000010ac742ba: add   [eax], al
  0x000000010ac742bc: nop
[Verified Entry Point]
  0x000000010ac742c0: mov   [esp-0x14000], eax
  0x000000010ac742c7: push  ebp
  0x000000010ac742c8: dec   eax
  0x000000010ac742c9: sub   esp, 0x0000000000000020
                                                ;*synchronization entry
                                                ; - java.lang.String::hashCode@-1 (line 1446)
...
</code></pre>

<p>Now I guess this is were the real fun starts, happy debugging!</p>
]]></content>
  </entry>
  
</feed>
