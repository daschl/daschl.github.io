<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.77.0" />


<title>Binding Threads And Processes to CPUs in Rust â€“ daschl writes. sometimes.</title>



  
  <meta property="description" content="Using the hwloc library and the rust binding you&#39;ll learn how to bind your threads and processes to CPU cores.">
  




<link href="/atom.xml" rel="alternate" type="application/atom+xml" title="daschl writes. sometimes." />

<meta property="og:title" content="Binding Threads And Processes to CPUs in Rust" />
<meta property="og:description" content="Using the hwloc library and the rust binding you&#39;ll learn how to bind your threads and processes to CPU cores." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://nitschinger.at/Binding-Threads-And-Processes-to-CPUs-in-Rust/" />
<meta property="article:published_time" content="2016-02-11T00:00:00+00:00" />
<meta property="article:modified_time" content="2016-02-11T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Binding Threads And Processes to CPUs in Rust"/>
<meta name="twitter:description" content="Using the hwloc library and the rust binding you&#39;ll learn how to bind your threads and processes to CPU cores."/>

<meta itemprop="name" content="Binding Threads And Processes to CPUs in Rust">
<meta itemprop="description" content="Using the hwloc library and the rust binding you&#39;ll learn how to bind your threads and processes to CPU cores.">
<meta itemprop="datePublished" content="2016-02-11T00:00:00+00:00" />
<meta itemprop="dateModified" content="2016-02-11T00:00:00+00:00" />
<meta itemprop="wordCount" content="2462">



<meta itemprop="keywords" content="rust,hwloc,cpu," />


<link rel="stylesheet" href="https://nitschinger.at/css/main.css" media="all">
<link rel="stylesheet" href="https://nitschinger.at/css/fonts.css">

  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="https://nitschinger.at/" class="nav-logo">
    <img src="https://nitschinger.at/images/"
         width="" 
         height="" 
         alt="">
  </a>
  <a href="https://nitschinger.at/" class="nav-title">daschl writes. sometimes.</a>

  <ul class="nav-links">
    
    <li><a href="/tags">tags</a></li>
    
    <li><a href="/imprint/">imprint</a></li>
    
    <li><a href="https://twitter.com/daschl">-&gt; twitter</a></li>
    
    <li><a href="https://github.com/daschl">-&gt; github</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">
  <article class="article">
    <h1 class="article-title">Binding Threads And Processes to CPUs in Rust</h1>
    
    <span class="article-date">11 February 2016</span>
    

    <div class="article-content">
      <p>In the <a href="http://nitschinger.at/Discovering-Hardware-Topology-in-Rust">previous post</a> I&rsquo;ve introduced the <a href="https://github.com/daschl/hwloc-rs">hwloc-rs</a> library, which allows you to discover and manage hardware topologies. Discovering the capabilities of a machine is insightful, but it gets more interesting if you can perform certain actions based on those insights.</p>
<p>Binding threads or processes to distinct CPU cores is very important in high performance applications to isolate workloads, keep inter-core messaging latency to a minimum and also to prevent the operating system from relocating your threads between cores as it sees fit. This becomes even more important in <a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a> architectures, where the memory access latency depends on the memory location relative to the processors (binding memory chunks, while also supported by <code>hwloc</code> is not covered in this post).</p>
<p><a href="https://www.open-mpi.org/projects/hwloc/tutorials/20150921-EuroMPI-hwloc-tutorial.pdf">Example Benchmarks</a> with <a href="https://www.open-mpi.org/">OpenMPI</a> and <a href="https://software.intel.com/en-us/intel-mpi-library">Intel MPI</a> on a 12-core Xeon E5 show that the throughput and latency vary greatly when passing messages between cores. Between cores on the same NUMA node the latency is around 330ns with a throughput of 4220MiB/s, but once messages need to cross the boundaries between cores in different NUMA nodes the latency shoots up to 590ns and the throughput drops to 3410MiB/s.</p>
<p>As always with such low-level concerns like this, the APIs differ across operating systems and some platforms don&rsquo;t even support CPU binding at all. This is where <code>hwloc</code> shines again - it provides us with easy to use abstractions that we can readily use in our rust code. The following blog post explains the different options (checking for support, process binding, thread binding) in greater detail.</p>
<p>The <a href="http://nitschinger.at/hwloc-rs/rustdoc/0.3.0/hwloc/index.html">docs</a> provide helpful instructions to get started, but make sure you pick up at least version <code>0.3.0</code> if you want to try it out:</p>
<pre><code>[dependencies]
hwloc = &quot;0.3.0&quot;
</code></pre><h2 id="checking-for-support">Checking for Support</h2>
<p>Before even thinking about binding your thread or process to a specific core you need to check whether your target platform supports it. Spoiler: if you are thinking about trying this on OSX, you are out of luck. But this gives us a chance to compare the output of the following code on Linux and OSX:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">crate</span> hwloc;

<span style="color:#66d9ef">use</span> hwloc::Topology;

<span style="color:#e6db74">/// Example on how to check for specific topology support of a feature.
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> topo <span style="color:#f92672">=</span> Topology::new();

    <span style="color:#75715e">// Check if Process Binding for CPUs is supported
</span><span style="color:#75715e"></span>    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;CPU Binding (current process) supported: {}&#34;</span>, topo.support().cpu().set_current_process());
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;CPU Binding (any process) supported: {}&#34;</span>, topo.support().cpu().set_process());

    <span style="color:#75715e">// Check if Thread Binding for CPUs is supported
</span><span style="color:#75715e"></span>    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;CPU Binding (current thread) supported: {}&#34;</span>, topo.support().cpu().set_current_thread());
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;CPU Binding (any thread) supported: {}&#34;</span>, topo.support().cpu().set_thread());

    <span style="color:#75715e">// Debug Print all the Support Flags
</span><span style="color:#75715e"></span>    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;All Flags:\n{:?}&#34;</span>, topo.support());
}

</code></pre></td></tr></table>
</div>
</div><p>On Linux:</p>
<pre><code>CPU Binding (current process) supported: true
CPU Binding (any process) supported: true
CPU Binding (current thread) supported: true
CPU Binding (any thread) supported: true
All Flags:
TopologyDiscoverySupport { pu: 1 }, TopologyCpuBindSupport { set_thisproc_cpubind: 1, get_thisproc_cpubind: 1, set_proc_cpubind: 1, get_proc_cpubind: 1, set_thisthread_cpubind: 1, get_thisthread_cpubind: 1, set_thread_cpubind: 1, get_thread_cpubind: 1, get_thisproc_last_cpu_location: 1, get_proc_last_cpu_location: 1, get_thisthread_last_cpu_location: 1 }, TopologyMemBindSupport { (omitted) }
</code></pre><p>On OSX:</p>
<pre><code>CPU Binding (current process) supported: false
CPU Binding (any process) supported: false
CPU Binding (current thread) supported: false
CPU Binding (any thread) supported: false
All Flags:
TopologyDiscoverySupport { pu: 1 }, TopologyCpuBindSupport { set_thisproc_cpubind: 0, get_thisproc_cpubind: 0, set_proc_cpubind: 0, get_proc_cpubind: 0, set_thisthread_cpubind: 0, get_thisthread_cpubind: 0, set_thread_cpubind: 0, get_thread_cpubind: 0, get_thisproc_last_cpu_location: 0, get_proc_last_cpu_location: 0, get_thisthread_last_cpu_location: 0 }, TopologyMemBindSupport { (omitted) }
</code></pre><p>As a result, the following sections use a (virtual) Linux machine with 4 cores to demonstrate the binding capabilities. To give you some context, here is the <code>lstopo</code> output of the VM:</p>
<pre><code>$ uname -a
Linux vagrant-ubuntu-trusty-64 3.13.0-71-generic #114-Ubuntu SMP Tue Dec 1 02:34:22 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux

$ lstopo -p --no-io
Machine (490MB) + Socket P#0 + L2d (6144KB)
  L1d (32KB) + Core P#0 + PU P#0
  L1d (32KB) + Core P#1 + PU P#1
  L1d (32KB) + Core P#2 + PU P#2
  L1d (32KB) + Core P#3 + PU P#3  
</code></pre><h2 id="the-cpuset">The CpuSet</h2>
<p>One important type to know when performing CPU binding operations is the <a href="http://nitschinger.at/hwloc-rs/rustdoc/0.3.0/hwloc/type.CpuSet.html">CpuSet</a>. The <code>CpuSet</code> is just a type alias for a generic <a href="http://nitschinger.at/hwloc-rs/rustdoc/0.3.0/hwloc/struct.Bitmap.html">Bitmap</a> which has its bits set according to CPU physical OS indexes.</p>
<p>You can create a <code>CpuSets</code> instance too, but in general you will retrieve them through the topology or its objects, then copy/modify it and finally use it for your custom CPU binding. Every bitmap implements the <code>Display</code> and the <code>Debug</code> trait (amongst others), so printing their values is often a good idea. The next examples will make heavy use of <code>CpuSets</code>, so make sure to browse around the API a bit and make yourself familiar with it.</p>
<h2 id="process-binding">Process Binding</h2>
<p>If your platform supports it as well, <code>hwloc</code> provides two different ways to bind a process. You can either bind the current process or an arbitrary process identified by its process ID (commonly referred to as <code>pid</code>).</p>
<h3 id="binding-the-current-process">Binding the Current Process</h3>
<p>Here is an example which binds the current process to the last core available:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">crate</span> hwloc;

<span style="color:#66d9ef">use</span> hwloc::{Topology, TopologyObject, ObjectType, CPUBIND_PROCESS};

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> topo <span style="color:#f92672">=</span> Topology::new();

    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> cpuset <span style="color:#f92672">=</span> last_core(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> topo).cpuset().unwrap();
    cpuset.singlify();

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Cpu Binding before explicit bind: {:?}&#34;</span>, topo.get_cpubind(CPUBIND_PROCESS));
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Cpu Location before explicit bind: {:?}&#34;</span>, topo.get_cpu_location(CPUBIND_PROCESS));

    <span style="color:#66d9ef">match</span> topo.set_cpubind(cpuset, CPUBIND_PROCESS) {
        Ok(_) <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Correctly bound to last core&#34;</span>),
        Err(e) <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Failed to bind: {:?}&#34;</span>, e)
    }

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Cpu Binding after explicit bind: {:?}&#34;</span>, topo.get_cpubind(CPUBIND_PROCESS));
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Cpu Location after explicit bind: {:?}&#34;</span>, topo.get_cpu_location(CPUBIND_PROCESS));
}

<span style="color:#e6db74">/// Helper method to find the last core
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">last_core</span>(topo: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Topology) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">TopologyObject</span> {
    <span style="color:#66d9ef">let</span> core_depth <span style="color:#f92672">=</span> topo.depth_or_below_for_type(<span style="color:#f92672">&amp;</span>ObjectType::Core).unwrap();
    <span style="color:#66d9ef">let</span> all_cores <span style="color:#f92672">=</span> topo.objects_at_depth(core_depth);
    all_cores.last().unwrap()
}
</code></pre></td></tr></table>
</div>
</div><p>This prints the following on the linux machine:</p>
<pre><code>Cpu Binding before explicit bind: Some(0-3)
Cpu Location before explicit bind: Some(2)
Correctly bound to last core
Cpu Binding after explicit bind: Some(3)
Cpu Location after explicit bind: Some(3)
</code></pre><p>So let&rsquo;s break it apart a bit. The first thing we need to do is find the <code>CpuSet</code> for the last core so we have a reference to bind it to. Note that this <code>singlify</code> call here is useful so that the process does not have a chance of migrating between multiple logical CPUs in the original mask.</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> cpuset <span style="color:#f92672">=</span> last_core(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> topo).cpuset().unwrap();
cpuset.singlify();

<span style="color:#75715e">//...
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">last_core</span>(topo: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Topology) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">TopologyObject</span> {
    <span style="color:#66d9ef">let</span> core_depth <span style="color:#f92672">=</span> topo.depth_or_below_for_type(<span style="color:#f92672">&amp;</span>ObjectType::Core).unwrap();
    <span style="color:#66d9ef">let</span> all_cores <span style="color:#f92672">=</span> topo.objects_at_depth(core_depth);
    all_cores.last().unwrap()
}
</code></pre></td></tr></table>
</div>
</div><p>Now that we have our &ldquo;target&rdquo;, we can start binding the current process there. To visualise what&rsquo;s going on, we also print the binding and location for the current process before and after the explicit binding:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-rust" data-lang="rust">println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Cpu Binding before explicit bind: {:?}&#34;</span>, topo.get_cpubind(CPUBIND_PROCESS));
println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Cpu Location before explicit bind: {:?}&#34;</span>, topo.get_cpu_location(CPUBIND_PROCESS));

<span style="color:#66d9ef">match</span> topo.set_cpubind(cpuset, CPUBIND_PROCESS) {
    Ok(_) <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Correctly bound to last core&#34;</span>),
    Err(e) <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Failed to bind: {:?}&#34;</span>, e)
}

println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Cpu Binding after explicit bind: {:?}&#34;</span>, topo.get_cpubind(CPUBIND_PROCESS));
println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Cpu Location after explicit bind: {:?}&#34;</span>, topo.get_cpu_location(CPUBIND_PROCESS));
</code></pre></td></tr></table>
</div>
</div><p>The current <code>CpuSet</code> of the process (which you can retrieve through <code>get_cpubind(CPUBIND_PROCESS)</code>) contains all possibles cores where the operating system might dispatch the process on. In our case it prints <code>0-3</code> which means all four cores are possible. The call to <code>get_cpu_location()</code> gives us the current core location, but this can change between subsequent calls as the operating system moves the process around.</p>
<p>Finally we override the current binding with our custom one (the new <code>CpuSet</code> only contains the last core rather than all four) and apply some simple matching to make sure the binding didn&rsquo;t fail for some reason. The last <code>println!</code> calls are just there to visually validate the new binding.</p>
<h3 id="binding-an-arbitrary-process">Binding an Arbitrary Process</h3>
<p>Binding any process works very similar to binding the current process, but there is one difference - we need to find the <code>pid</code> of the process we want to bind. This is a little out of scope for this blog post, but since our own process also has a <code>pid</code> we can use that one for our examples. Unfortunately we need a little bit of unsafe <code>libc</code> magic there:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">crate</span> libc;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#75715e">//...
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">let</span> pid <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { libc::getpid() };
  <span style="color:#75715e">//...
</span><span style="color:#75715e"></span>}
</code></pre></td></tr></table>
</div>
</div><p>Once we have our pid, we will reuse the code from the last example to get the last core where we want to bind the process to:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#75715e">//...
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> cpuset <span style="color:#f92672">=</span> last_core(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> topo).cpuset().unwrap();
  <span style="color:#75715e">//...
</span><span style="color:#75715e"></span>}

<span style="color:#e6db74">/// Find the last core
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">last_core</span>(topo: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Topology) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">TopologyObject</span> {
    <span style="color:#66d9ef">let</span> core_depth <span style="color:#f92672">=</span> topo.depth_or_below_for_type(<span style="color:#f92672">&amp;</span>ObjectType::Core).unwrap();
    <span style="color:#66d9ef">let</span> all_cores <span style="color:#f92672">=</span> topo.objects_at_depth(core_depth);
    all_cores.last().unwrap()
}
</code></pre></td></tr></table>
</div>
</div><p>Now we can use the same methods as previously, but with the <code>for_process()</code> suffix. Here is the full example, again with some debug print statements to visualise what&rsquo;s going on:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">crate</span> hwloc;
<span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">crate</span> libc;

<span style="color:#66d9ef">use</span> hwloc::{Topology, CPUBIND_PROCESS, TopologyObject, ObjectType};

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> topo <span style="color:#f92672">=</span> Topology::new();

    <span style="color:#66d9ef">let</span> pid <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { libc::getpid() };
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Binding Process with PID {:?}&#34;</span>, pid);

    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> cpuset <span style="color:#f92672">=</span> last_core(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> topo).cpuset().unwrap();
    cpuset.singlify();

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Before Bind: {:?}&#34;</span>, topo.get_cpubind_for_process(pid, CPUBIND_PROCESS).unwrap());
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Last Known CPU Location: {:?}&#34;</span>, topo.get_cpu_location_for_process(pid, CPUBIND_PROCESS).unwrap());

    topo.set_cpubind_for_process(pid, cpuset, CPUBIND_PROCESS).unwrap();

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;After Bind: {:?}&#34;</span>, topo.get_cpubind_for_process(pid, CPUBIND_PROCESS).unwrap());
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Last Known CPU Location: {:?}&#34;</span>, topo.get_cpu_location_for_process(pid, CPUBIND_PROCESS).unwrap());
}

<span style="color:#e6db74">/// Find the last core
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">last_core</span>(topo: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Topology) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">TopologyObject</span> {
    <span style="color:#66d9ef">let</span> core_depth <span style="color:#f92672">=</span> topo.depth_or_below_for_type(<span style="color:#f92672">&amp;</span>ObjectType::Core).unwrap();
    <span style="color:#66d9ef">let</span> all_cores <span style="color:#f92672">=</span> topo.objects_at_depth(core_depth);
    all_cores.last().unwrap()
}
</code></pre></td></tr></table>
</div>
</div><p>If we run this on our linux box, this is the output:</p>
<pre><code>Binding Process with PID 3034
Before Bind: 0-3
Last Known CPU Location: 3
After Bind: 3
Last Known CPU Location: 3
</code></pre><p>So as long as you have the process ID available and the operating system supports it, you can bind every process to any number of cores you want. This is especially helpful if you need to bind forked processes or if you need to write some kind of babysitter service that needs to keep track and orchestrate a number of processes.</p>
<h2 id="thread-binding">Thread Binding</h2>
<p>In addition to bind the process as a whole, it is also possible to pin individual threads inside a process to cores. Every thread has a unique thread ID (<code>tid</code>) which is used to bind a thread to a core.</p>
<p>The following example will spawn one thread for each core in the system and then bind each thread to one of the cores. Here is the full code in its beauty, we&rsquo;ll break it apart afterwards:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">35
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">36
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">37
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">38
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">39
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">40
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">41
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">42
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">43
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">44
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">45
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">46
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">47
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">crate</span> hwloc;
<span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">crate</span> libc;

<span style="color:#66d9ef">use</span> hwloc::{Topology, ObjectType, CPUBIND_THREAD, CpuSet};
<span style="color:#66d9ef">use</span> std::thread;
<span style="color:#66d9ef">use</span> std::sync::{Arc,Mutex};

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> topo <span style="color:#f92672">=</span> Arc::new(Mutex::new(Topology::new()));

    <span style="color:#66d9ef">let</span> num_cores <span style="color:#f92672">=</span> {
        <span style="color:#66d9ef">let</span> topo_rc <span style="color:#f92672">=</span> topo.clone();
        <span style="color:#66d9ef">let</span> topo_locked <span style="color:#f92672">=</span> topo_rc.lock().unwrap();
        (<span style="color:#f92672">*</span>topo_locked).objects_with_type(<span style="color:#f92672">&amp;</span>ObjectType::Core).unwrap().len()
    };
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Found {} cores.&#34;</span>, num_cores);

    <span style="color:#66d9ef">let</span> handles: Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>..num_cores).map(<span style="color:#f92672">|</span>i<span style="color:#f92672">|</span> {
            <span style="color:#66d9ef">let</span> child_topo <span style="color:#f92672">=</span> topo.clone();
            thread::spawn(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
                <span style="color:#66d9ef">let</span> tid <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { libc::pthread_self() };
                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> locked_topo <span style="color:#f92672">=</span> child_topo.lock().unwrap();

                <span style="color:#66d9ef">let</span> before <span style="color:#f92672">=</span> locked_topo.get_cpubind_for_thread(tid, CPUBIND_THREAD);

                <span style="color:#66d9ef">let</span> bind_to <span style="color:#f92672">=</span> cpuset_for_core(<span style="color:#f92672">&amp;*</span>locked_topo, i);

                locked_topo.set_cpubind_for_thread(tid, bind_to, CPUBIND_THREAD).unwrap();

                <span style="color:#66d9ef">let</span> after <span style="color:#f92672">=</span> locked_topo.get_cpubind_for_thread(tid, CPUBIND_THREAD);

                println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Thread {}: Before {:?}, After {:?}&#34;</span>, i, before, after);
            })
        }).collect();

        <span style="color:#66d9ef">for</span> h <span style="color:#66d9ef">in</span> handles {
            h.join().unwrap();
        }
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">cpuset_for_core</span>(topology: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Topology</span>, idx: <span style="color:#66d9ef">usize</span>) -&gt; <span style="color:#a6e22e">CpuSet</span> {
    <span style="color:#66d9ef">let</span> cores <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>topology).objects_with_type(<span style="color:#f92672">&amp;</span>ObjectType::Core).unwrap();
    <span style="color:#66d9ef">match</span> cores.get(idx) {
        Some(val) <span style="color:#f92672">=&gt;</span> val.cpuset().unwrap(),
        None <span style="color:#f92672">=&gt;</span> panic<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;No Core found with id {}&#34;</span>, idx)
    }
}
</code></pre></td></tr></table>
</div>
</div><p>Before the binding we need to identify the number of cores - that&rsquo;s an easy task for <code>hwloc</code>:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> num_cores <span style="color:#f92672">=</span> {
    <span style="color:#66d9ef">let</span> topo_rc <span style="color:#f92672">=</span> topo.clone();
    <span style="color:#66d9ef">let</span> topo_locked <span style="color:#f92672">=</span> topo_rc.lock().unwrap();
    (<span style="color:#f92672">*</span>topo_locked).objects_with_type(<span style="color:#f92672">&amp;</span>ObjectType::Core).unwrap().len()
};
println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Found {} cores.&#34;</span>, num_cores);
</code></pre></td></tr></table>
</div>
</div><p>The code finds all cores through <code>objects_with_type(&amp;ObjectType::Core)</code> and counts them. Note that we need to do use proper rust synchronization mechanisms around our <code>Topology</code> since we are accessing it from multiple threads in the code.</p>
<p>The next piece spawns one thread for each core and joins on the main thread to wait until they complete:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> handles: Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>..num_cores).map(<span style="color:#f92672">|</span>i<span style="color:#f92672">|</span> {
        <span style="color:#66d9ef">let</span> child_topo <span style="color:#f92672">=</span> topo.clone();
        thread::spawn(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
            <span style="color:#75715e">// do our other stuff
</span><span style="color:#75715e"></span>        })
    }).collect();

    <span style="color:#66d9ef">for</span> h <span style="color:#66d9ef">in</span> handles {
        h.join().unwrap();
    }
</code></pre></td></tr></table>
</div>
</div><p>Next up we load the current thread ID through some <code>libc</code> unsafe magic, lock the <code>Topology</code> for safety and then read the current <code>CpuSet</code> for the thread (to print it out later):</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> tid <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { libc::pthread_self() };
<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> locked_topo <span style="color:#f92672">=</span> child_topo.lock().unwrap();

<span style="color:#66d9ef">let</span> before <span style="color:#f92672">=</span> locked_topo.get_cpubind_for_thread(tid, CPUBIND_THREAD);

</code></pre></td></tr></table>
</div>
</div><p>The next part is important:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> bind_to <span style="color:#f92672">=</span> cpuset_for_core(<span style="color:#f92672">&amp;*</span>locked_topo, i);

locked_topo.set_cpubind_for_thread(tid, bind_to, CPUBIND_THREAD).unwrap();
</code></pre></td></tr></table>
</div>
</div><p>The helper function <code>cpuset_for_core</code> accepts an integer which represents the thread number (not the <code>tid</code>) and loops through the cores available on the <code>Topology</code>. It then returns the right <code>CpuSet</code> for the given index, so the first thread will be pinned to Core 0, the second one to Core 1 and so forth. Then, we use the <code>set_cpubind_for_thread()</code> method to bass in the current thread id as well as the <code>CpuSet</code> to apply and the <code>CPUBIND_THREAD</code> identifier which is needed.</p>
<p>Finally we just collect the new binding and then print it out for visualisation:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> after <span style="color:#f92672">=</span> locked_topo.get_cpubind_for_thread(tid, CPUBIND_THREAD);

println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Thread {}: Before {:?}, After {:?}&#34;</span>, i, before, after);
</code></pre></td></tr></table>
</div>
</div><p>Running this on our 4-core machine prints:</p>
<pre><code>Found 4 cores.
Thread 0: Before Some(0-3), After Some(0)
Thread 1: Before Some(0-3), After Some(1)
Thread 2: Before Some(0-3), After Some(2)
Thread 3: Before Some(0-3), After Some(3)
</code></pre><h2 id="conclusion">Conclusion</h2>
<p>Which processes or threads to bind is purely an application concern, but the underlying mechanics are greatly simplified through the <code>hwloc</code> abstractions. Combining the topology discovery with the CPU binding support allows you to choose the most optimised deployment option at runtime and giving you reasonable fallback options if the most performant way is not supported on the target.</p>
<p>Looking ahead, the rust binding is pretty much complete on discovery and CPU binding (modulo some advanced APIs that are yet to come), but the big piece missing is memory binding. Since rust itself pretty much abstracts the whole memory management story, it&rsquo;s not as easy as exposing the custom memory allocation functions of <code>hwloc</code>. I&rsquo;m currently trying to wrap my head around good abstractions for this, so every input is very much appreciated! Please also let me know of any bugs you find or enhancements/clarifications you&rsquo;d like to see in the rust binding.</p>

    </div>

    <ul class="article-taxonomy">
      

      
      <li>
        <i class="fa fa-tags"></i><a
          href="/tags/rust">rust</a><a
          href="/tags/hwloc">hwloc</a><a
          href="/tags/cpu">cpu</a>
      </li>
      
  </article>

  <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "daschl" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</main>

<footer class="footer">
  <ul class="footer-links">
    <li>
      <a href="/atom.xml" type="application/atom+xml" target="_blank"><i class="fa fa-rss"></i> Atom feed</a>
    </li>
    <li>
      <a href="https://github.com/daschl"><i class="fa fa-github"></i> GitHub</a>
    </li>
    <li>
      <a href="https://twitter.com/daschl"><i class="fa fa-twitter"></i> Twitter</a>
    </li>
    <li>
      <a href="https://www.linkedin.com/in/michaelnitschinger/"><i class="fa fa-linkedin"></i> LinkedIn</a>
    </li>
  </ul>
</footer>

</div>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-19686689-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


</body>

</html>