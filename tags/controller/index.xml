<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Controller on daschl writes. sometimes.</title>
    <link>http://nitschinger.at/tags/controller/</link>
    <description>Recent content in Controller on daschl writes. sometimes.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 08 Jun 2011 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://nitschinger.at/tags/controller/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Securing Lithium Forms</title>
      <link>http://nitschinger.at/Securing-Lithium-Forms/</link>
      <pubDate>Wed, 08 Jun 2011 00:00:00 +0000</pubDate>
      
      <guid>http://nitschinger.at/Securing-Lithium-Forms/</guid>
      <description>&lt;p&gt;CSRF (Cross-Site-Request-Forgery) attacks work by sending arbitary (form) requests from a victim. Normally, the receiving site (in our case the &lt;code&gt;Controller&lt;/code&gt; who processes the form data) doesn&amp;rsquo;t know where the data comes from. The CSRF protection in Lithium aims to solve this problem in an elegant and secure way. You can read more about those attacks
&lt;a href=&#34;http://shiflett.org/articles/cross-site-request-forgeries&#34;&gt;here&lt;/a&gt;. Note that
you&amp;rsquo;ll need to clone the latest &lt;code&gt;master&lt;/code&gt; branch of Lithium if you want to
try it out now.&lt;/p&gt;

&lt;p&gt;CSRF protection in Lithium is twofold. First, you need to add a unique token to your forms and then check in your controller if the sent token is correct. As Lithium stores the generated &lt;code&gt;sessionKey&lt;/code&gt; in your session, make sure that you have session support enabled. If you don&amp;rsquo;t activate sessions, the &lt;code&gt;check&lt;/code&gt; method fails silently (which we&amp;rsquo;llsee later on). So uncomment the following line in &lt;code&gt;app/config/bootstrap.php&lt;/code&gt; (if you haven&amp;rsquo;t already):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * This file contains configuration for session (and/or cookie) storage, and user or web service
 * authentication.
 *
 */
//require __DIR__ . &#39;/bootstrap/session.php&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s look at the view layer first with a very simple form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?= $this-&amp;gt;form-&amp;gt;create(); ?&amp;gt;
    &amp;lt;?= $this-&amp;gt;security-&amp;gt;requestToken(); ?&amp;gt;
    &amp;lt;?= $this-&amp;gt;form-&amp;gt;field(&#39;title&#39;); ?&amp;gt;
    &amp;lt;?= $this-&amp;gt;form-&amp;gt;submit(&#39;Submit&#39;); ?&amp;gt;
&amp;lt;?= $this-&amp;gt;form-&amp;gt;end(); ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thanks to lazy loading, we don&amp;rsquo;t have to do anything special to
include our new &lt;code&gt;Security&lt;/code&gt; helper. The helper provides the
&lt;code&gt;requestToken()&lt;/code&gt; method that generates a unique token (a salted hash) and renders it in a hidden field. If you inspect your form, you should see
something like this (note that i&amp;rsquo;ve shortened the value attribute for better
readability):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;hidden&amp;quot; value=&amp;quot;$2a$1...Ay62/W&amp;quot; name=&amp;quot;security[token]&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we&amp;rsquo;ve adapted our form, we can work with it in our controller.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php

namespace app\controllers;

use lithium\security\validation\RequestToken;

class TasksController extends \lithium\action\Controller {

    public function add() {
        if($this-&amp;gt;request-&amp;gt;data) {
            if(!RequestToken::check($this-&amp;gt;request)) {
                RequestToken::get(array(&#39;regenerate&#39; =&amp;gt; true));
            } else {
                // work with the request as usual
            }
        }
    }

}

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are many ways how to handle security checks, so the code snippet above shows only one of them. Let&amp;rsquo;s tackle the important parts one by one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use lithium\security\validation\RequestToken;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll need to import the &lt;code&gt;RequestToken&lt;/code&gt; class into your namespace, as it is the responsible class for dealing with the tokens.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RequestToken::check($this-&amp;gt;request);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;check&lt;/code&gt; method reads the &lt;code&gt;sessionKey&lt;/code&gt; from your session and checks if it is identical to the requested one. You can also provide the key directly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$key = $this-&amp;gt;request-&amp;gt;data[&#39;security&#39;][&#39;token&#39;];
RequestToken::check($key);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can modify the key manually (set it to &lt;code&gt;foobar&lt;/code&gt; or so) and then see if the &lt;code&gt;check&lt;/code&gt; method fails. How you may handle security errors depends heavily on your application. In our example, we regenerate the token with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RequestToken::get(array(&#39;regenerate&#39; =&amp;gt; true));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you go down this route, you&amp;rsquo;ll also have to tell the user what happend in your view. A more secure route would be to raise an exception (or render a error template) and log what happened. In normal production environments this is clearly a exceptional behavior and therefore should be treated this way. If you need this more often in your controller, you can also move the checks to the &lt;code&gt;_init()&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class TasksController extends \lithium\action\Controller {

    public function _init() {
        parent::_init();

        if($this-&amp;gt;request-&amp;gt;data &amp;amp;&amp;amp; !RequestToken::check($this-&amp;gt;request)) {
            $host = $this-&amp;gt;request-&amp;gt;env(&#39;HTTP_HOST&#39;);
            Logger::error(&amp;quot;Possible CSRF attack from host $host&amp;quot;);
            $this-&amp;gt;redirect(&#39;/&#39;);
        }
    }

    public function add() {
        if($this-&amp;gt;request-&amp;gt;data) {
                // save your data as usual
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should give you a good starting point on how to work with the new
CSRF protection mechanisms. As of today, there is only one major feature left (namely MongoDB relationships) until Lithium reaches the &amp;ldquo;big one&amp;rdquo; so stay tuned for more announcements in the next weeks!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>