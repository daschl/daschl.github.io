<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cache &middot; daschl writes. sometimes.</title>

    <meta name="description" content="">

    <meta name="generator" content="Hugo 0.40.3" />
    <meta name="twitter:card" content="summary">
    
    <meta name="twitter:title" content="Cache &middot; daschl writes. sometimes.">
    <meta name="twitter:description" content="">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Cache &middot; daschl writes. sometimes.">
    <meta property="og:description" content="">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">
    <!--<![endif]-->

    <link rel="stylesheet" href="https://nitschinger.at/css/all.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="daschl writes. sometimes." href="https://nitschinger.at/index.xml" />
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title">
                <a href="https://nitschinger.at">daschl writes. sometimes.</a>
            </h1>
            <h2 class="brand-tagline"></h2>
        </hgroup>

        <nav class="nav">
            <ul class="nav-list">
                <li class="nav-item">
                    <a class="pure-button" href="https://twitter.com/daschl">
                        <i class="fa fa-twitter"></i> Twitter</a>
                </li>
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/daschl">
                        <i class="fa fa-github-alt"></i> github</a>
                </li>
                <li class="nav-item">
                    <a class="pure-button" href="https://nitschinger.at/index.xml">
                        <i class="fa fa-rss"></i> rss</a>
                </li>
                <li class="nav-item">
                    <a class="pure-button" href="https://nitschinger.at/imprint">Imprint</a>
                </li>
            </ul>
        </nav>
    </div>
</div>

    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                
                <h1 class="content-subhead">30 Jan 2013</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://nitschinger.at/benchmarking-cache-transcoders-in-php/" class="post-title">Benchmarking Cache Transcoders in PHP</a>

                        <p class="post-meta">
                            
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="motivation">Motivation</h2>

<p>Storing PHP objects (or simpler data types like arrays) in caches always requires some kind of transformation. You need a way of encoding/decoding data so that it can be stored and loaded properly. In most languages, this process is known as object <a href="http://en.wikipedia.org/wiki/Serialization">serialization</a>. PHP provides a mechanism for this out of the box, but in this article we&rsquo;ll also look at <a href="http://pecl.php.net/package/igbinary">igbinary</a> as a drop-in replacement for the default serializer. We also compare the results to object transcoding based on <a href="http://json.org/">JSON</a>, which is not really an object serialization mechanism but commonly used as a data chache structure which has its own benefits and drawbacks.</p>

<p>As always, please take this benchmarks with a grain of salt. Don&rsquo;t take the absolute numbers as a reference, look at the differences and run the benchmarks in your environment to get accurate results that apply to your scenarios. If you spot any flaws in what is shown here, please point it out in the comments. This blog post is not some kind of &ldquo;advertising&rdquo; for a special mechanism and all different transcoders are discussed with their benefits and drawbacks.</p>

<p>If you want to compare your results to mine, I&rsquo;m using a MacBook Pro on Mac OS X 10.8.2 with the 2.3 GHz i7 and 16GB RAM. I&rsquo;m using PHP 5.4.11 (through <a href="https://github.com/josegonzalez/homebrew-php">homebrew-php</a>) instead of the shipped 5.3.</p>

<h2 id="the-php-serializer">The PHP Serializer</h2>

<p>Out of the box, PHP provides a serialization mechanism on top of the <a href="http://php.net/manual/de/function.serialize.php">serialize</a> and <a href="http://www.php.net/manual/de/function.unserialize.php">unserialize</a> methods. By applying this method on a variable, it gets encoded to a byte stream and neither the type nor the structure gets lost (you can&rsquo;t store <a href="http://www.php.net/manual/en/language.types.resource.php">resources</a>).</p>

<p>So, let&rsquo;s look at a simple and a more complex example on how the transformation looks like:</p>

<pre><code>&lt;?php

class Person {
    private $name;

    public function __construct($name) {
        $this-&gt;name = $name;
    }

    public function getName() {
        return $this-&gt;name;
    }
}

$simple = array(&quot;key&quot; =&gt; &quot;value&quot;);
$complex = new Person(&quot;Michael&quot;);

?&gt;
</code></pre>

<p>If we&rsquo;re calling <code>serialize()</code> on both variables, the output (as a string representation) looks like this:</p>

<pre><code>&lt;?php
$simpleSerialized = serialize($simple);
$complexSerialized = serialize($complex);

// string(28) &quot;a:1:{s:3:&quot;key&quot;;s:5:&quot;value&quot;;}&quot;
var_dump(serialize($simple));

// string(51) &quot;O:6:&quot;Person&quot;:1:{s:12:&quot;\000Person\000name&quot;;s:7:&quot;Michael&quot;;}&quot;
var_dump(serialize($complex));
?&gt;
</code></pre>

<p>While the resulting string is not designed for readability, you can clearly see that some metadata is added in order to make the unserialization possible. For example, the <code>key</code> string is serialized to <code>s:3:&quot;key&quot;</code> where the <code>s</code> means <code>string</code> and <code>3</code> is the string length. Also, <code>a</code> points to an <code>array</code> and <code>O</code> to an <code>object</code>.</p>

<p>We can now <code>unserialize()</code> the values and work with them as if they&rsquo;ve never been stored somewhere else:</p>

<pre><code>&lt;?php
$simpleUnserialized = unserialize($simpleSerialized);
$complexUnserialized = unserialize($complexSerialized);

// array(1) {'key' =&gt; string(5) &quot;value&quot;}
var_dump($simpleUnserialized);

// string(7) &quot;Michael&quot;
var_dump($complexUnserialized-&gt;getName());
?&gt;
</code></pre>

<p>In practice, two characteristics are important: size of the serialized value and performance. While from a developer perspective performance is fun to explore, the size of the serialized object is what matters most. Performance differences are only measurable when running it in a loop with lots of iterations, while in practice you may only work with a few objects at a time per request.</p>

<p>Let&rsquo;s use a common caching scenario: imagine we&rsquo;re caching entity responses from an ORM framework like <a href="http://www.doctrine-project.org/">Doctrine</a>. Here is a blog post class that will be filled with life:</p>

<pre><code>&lt;?php
class BlogPost {

    private $title;
    private $teaser;
    private $author;
    private $body;

    public function __construct($title, $teaser, $author, $body) {
        $this-&gt;title = $title;
        $this-&gt;teaser = $teaser;
        $this-&gt;author = $author;
        $this-&gt;body = $body;
    }

    public function getTitle() { return $this-&gt;title; }
    public function getTeaser() { return $this-&gt;teaser; }
    public function getAuthor() { return $this-&gt;author; }
    public function getBody() { return $this-&gt;body; }

}
?&gt;
</code></pre>

<p>Please take this with a grain of salt, because since JSON transcoding is not able to store a 1:1 representation like <code>serialize</code>, we need to work around that a bit. More details and discussion will be provided in the JSON section.</p>

<p>Assume that a blog post with content has around 10k characters and about 10kb in size, lets create a crafted blog post:</p>

<pre><code>&lt;?php
$randomString = function ($length) {
    $chars = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 .&quot;;    
    $str = &quot;&quot;;
    for( $i = 0; $i &lt; $length; $i++ ) {
        $str .= $chars[rand(0, strlen($chars)-1)];
    }
    return $str;
};

$title = &quot;How to measure caching transcoders&quot;;
$teaser = &quot;This is a much longer introduction on how to measure caching transcoders. Feel free to post your own findings.&quot;;
$author = &quot;daschl&quot;;
$body = $randomString(10000);

$post = new BlogPost($title, $teaser, $author, $body);
?&gt;
</code></pre>

<p>Now run <code>serialize</code> and <code>unserialize</code> in loops to measure performance as well as determine the resulting size of the object:</p>

<pre><code>&lt;?php
$iterations = 10000;
$start = microtime(true);
for($i=0;$i&lt;$iterations;$i++) {
    $serialized = serialize($post);
}
$end = microtime(true);

echo &quot;Size: &quot; . strlen($serialized) . &quot;\n&quot;;
echo ($end - $start) * 1000 . &quot;Milliseconds\n&quot;;
?&gt;
</code></pre>

<p>On my machine, to serialize 10000 objects it took about 33 milliseconds. The length of the resulting object (its string representation) is 10297 characters. This is kind of expected because the bulk of the object is the long article body. Before start comparing, we can already make one observation: its pretty fast. Now, let&rsquo;s move on to igbinary serialization and see how these results compare.</p>

<h2 id="serializing-with-igbinary">Serializing with igbinary</h2>

<p>The <a href="http://pecl.php.net/package/igbinary">igbinary</a> extension was developed as a drop-in replacement for the default PHP serializer. Instead of storing the serialized object as a text, it is stored as binary data. You can install it either through PECL or compile it from source, either way before running the tests make sure you have the <code>igbinary</code> extension enabled:</p>

<pre><code>michael@daschlbook ~ $ php -m | grep igbinary
igbinary
</code></pre>

<p>Instead of using <code>serialize</code> or <code>unserialize</code>, igbinary provides us with appropriate <code>igbinary_serialize</code> and <code>igbinary_unserialize</code> functions. Now we can apply the same microbenchmark and see the results:</p>

<pre><code>&lt;?php
$iterations = 10000;
$start = microtime(true);
for($i=0;$i&lt;$iterations;$i++) {
    $serialized = igbinary_serialize($post);
}
$end = microtime(true);

echo &quot;Size: &quot; . strlen($serialized) . &quot;\n&quot;;
echo ($end - $start) * 1000 . &quot;Milliseconds\n&quot;;
?&gt;
</code></pre>

<p>With default settings, to serialize 10000 objects with igbinary it took 678 milliseconds. The length of the resulting object is 10244 characters. If you compare it with the default serialization mechanism, that is 20 times slower and the resulting object isn&rsquo;t much smaller either. Bummer - or not? Let&rsquo;s look at why this is happening.</p>

<p>Let&rsquo;s look at a different workload. Let&rsquo;s create a data structure which consist of 30 smaller blog posts and measure the statistics for both again (only doing 1000 iterations instead of 10000):</p>

<pre><code>&lt;?php
$posts = array();
for($i=0;$i&lt;30;$i++) {
    $posts[] = new BlogPost($title, $teaser, $author, $randomString(50));
}
?&gt;
</code></pre>

<p>The results are more interesting: on my machine igbinary takes about 95 milliseconds while serialize needs only 41 milliseconds. Now it&rsquo;s just 2 times slower. But here comes the important part: the resulting size of igbinary is 2385 characters, while serialize is 10467 characters! That&rsquo;s about 5 times smaller. Note that this gap increases the larger your PHP object gets (not in terms of long character strings but speaking of complexity like methods).</p>

<p>Note that the igbinary docs say you should set <code>igbinary.compact_strings</code> to <code>Off</code> to increase performance, but there was no real measurable difference in my testings.</p>

<p>There is one more thing we haven&rsquo;t compared: deserializing of previously serialized objects. We can take the same code from above, use the serialized part as input and measure the timings once again (not that we don&rsquo;t need to measure the size of the resulting object because we&rsquo;re creating a &ldquo;live&rdquo; object again):</p>

<pre><code>&lt;?php
$posts = array();
for($i=0;$i&lt;30;$i++) {
    $posts[] = new BlogPost($title, $teaser, $author, $randomString(50));
}

$serializedIgbinary = igbinary_serialize($posts);
$serializedClassic = serialize($posts);

$iterations = 1000;
$start = microtime(true);
for($i=0;$i&lt;$iterations;$i++) {
    $unserialized = igbinary_unserialize($serializedIgbinary);
}
$end = microtime(true);

echo ($end - $start) * 1000 . &quot;Milliseconds\n&quot;;

$start = microtime(true);
for($i=0;$i&lt;$iterations;$i++) {
    $unserialized = unserialize($serializedClassic);
}
$end = microtime(true);

echo ($end - $start) * 1000 . &quot;Milliseconds\n&quot;;
?&gt;
</code></pre>

<p>This is giving us very interesting results: igbinary takes 65 milliseconds while classic unserialize needs 82 milliseconds! So igbinary is faster here. This is pretty good news, because in practice you will need to unserialize (speak &ldquo;fetch from cache&rdquo;) much more often than to serialize (speak &ldquo;store in cache&rdquo;). That&rsquo;s the whole point of a cache.</p>

<p>Before we move on to JSON, I think it&rsquo;s fair to say that igbinary wins this comparison. Most of the time you want to store complex PHP objects and fetch them out fast and quickly. Of course it has the overhead of installing it as an extension, but since it&rsquo;s a drop-in replacement you can change your mind later (but take this with a grain of salt because you can only unserialize what was serialized with igbinary and vice versa - so you&rsquo;d need to fetch and restore them).</p>

<p>Finally, when you are storing very long strings in objects, both have pretty much the same overhead (because you can&rsquo;t &ldquo;compact&rdquo; this long string very well). One workaround may be to compress and decompress the string as needed, using a mixture of gzip and base64 encoding. When serializing PHP objects, you can use the <a href="http://www.php.net/manual/en/language.oop5.magic.php#object.sleep">__sleep</a> and <a href="http://www.php.net/manual/en/language.oop5.magic.php#object.wakeup">__wakeup</a> methods to perform these kind of transformations.</p>

<p>Adding these two methods to our <code>BlogPost</code> class results in a 20% saving when using the 10k random string again:</p>

<pre><code>&lt;?php
public function __sleep() {
    $this-&gt;body = gzdeflate($this-&gt;body, 9);
    return array('title', 'teaser', 'author', 'body');
}

public function __wakeup() {
    $this-&gt;body = gzinflate($this-&gt;body);
}
?&gt;
</code></pre>

<p>Note that compressing takes time too, so measure if it makes sense in your case and the space savings are good enough. You also need the <code>zblib</code> extension to make this work properly.</p>

<h2 id="transcoding-on-top-of-json">Transcoding on top of JSON</h2>

<p>First of all, JSON has not the same characteristics as serialization. This is just because JSON only supports a subset of the available data types that PHP supports and therefore encoding/decoding takes some extra steps on the application side. So why are we comparing it here? Well, JSON is used very often for storing data in caches. Not only is it human readable, it can also be used in combination with other languages and applications. Using JSON allows you to store cache information from a Java backend and use it in your PHP application. That doesn&rsquo;t work with traditional serialization approaches.</p>

<p>If you need a primer on JSON and PHP, <a href="http://nitschinger.at/Handling-JSON-like-a-boss-in-PHP">read</a> my other article first. PHP allows you to transcode all objects (except resources) through the <a href="http://www.php.net/manual/en/function.json-encode.php">json_encode</a> and <a href="http://www.php.net/manual/en/function.json-decode.php">json_decode</a> functions. Private and protected variables are not converted, so we either need to make them public or provide a custom method that exports a storable object structure. While we&rsquo;re at it, we can provide a static factory method that initializes our BlogPost from the returned JSON string:</p>

<pre><code>&lt;?php
public function toJson() {
    return array(
        'title' =&gt; $this-&gt;title,
        'teaser' =&gt; $this-&gt;teaser,
        'author' =&gt; $this-&gt;author,
        'body' =&gt; $this-&gt;body
    );
}

public static function fromJson($json) {
    $d = json_decode($json, true);
    return new BlogPost($d['title'], $d['teaser'], $d['author'], $d['body']);
}
?&gt;
</code></pre>

<p>Note that the <code>toJson()</code> method returns a simple representation of the object, which is much less complicated than a full serialization approach. Let&rsquo;s run our benchmark again:</p>

<pre><code>&lt;?php
$post = new BlogPost($title, $teaser, $author, $randomString(10000));
$post = $post-&gt;toJson();

$iterations = 10000;
$start = microtime(true);
for($i=0;$i&lt;$iterations;$i++) {
    $encoded = json_encode($post);
}
echo &quot;Size: &quot; . strlen($serialized) . &quot;\n&quot;;
$end = microtime(true);

echo ($end - $start) * 1000 . &quot;Milliseconds\n&quot;;
?&gt;
</code></pre>

<p>On my machine it takes 1.7 seconds (!) to complete the encoding. The resulting object size is 10196 bytes which is comparable to our earlier measurements (again, the large value dominates here). Testing it against complex objects is not interesting because we can&rsquo;t restore them anyway without further modifications. Running <code>json_decode</code> on the encoded object also takes around 1.5 seconds, so there is no major difference here.</p>

<p>Personally, I&rsquo;d expected to have JSON transcoding to perform better, but again normally you don&rsquo;t run 10k iterations in a row. When you break it down to 10 encodings they take about 1 millisecond which is okay for most scenarios (given we encode a really large objects with a few kb here). Smaller objects like user sessions will encode much faster.</p>

<p>Edit: a friendly reader on <a href="http://www.reddit.com/r/PHP/comments/17kcy3/benchmarking_cache_transcoders_in_php/">reddit</a> pointed out that you can (and should) use the <a href="http://www.php.net/manual/en/class.jsonserializable.php">JsonSerializable interface</a> instead of rolling your own method name like <code>toJson()</code>. Thanks!</p>

<p>Edit2: another reader pointed out that naming a method <code>toJson()</code> which does not return JSON but an array is misleading. I agree, so if you adapt this approach in your environment choose a better name like <code>prepareForJson()</code>, <code>toArray()</code> or use the <code>JsonSerializable</code> Interface as shown above.</p>

<h2 id="conclusion">Conclusion</h2>

<p>After running these microbenchmarks, my conclusion is that when you need object serialization, go with igbinary. It provides good enough serialization performance and huge wins on object sizes. Decoding performance is also much better than out-ouf-the-box serialization. If you need interoperability with other applications or if you don&rsquo;t want to limit yourself to serialized PHP blobs, go with JSON. JSON requires much more hand wiring but you&rsquo;ll gain a lot of flexibility.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">08 Jan 2013</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://nitschinger.at/caching-doctrine-entities-with-couchbase/" class="post-title">Caching Doctrine Entities with Couchbase</a>

                        <p class="post-meta">
                            
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="motivation">Motivation</h2>

<p>As part of our ongoing efforts to make Couchbase more integrated with frameworks and libraries, we added caching support for the <a href="http://www.doctrine-project.org/">Doctrine ORM</a>. Recently, the pull request has been merged into the master branch and is scheduled to be published along with the <a href="http://doctrine-project.org/jira/browse/DCOM/fixforversion/10327">2.4</a> release.</p>

<p>Caching can either be used standalone (through the API provided by <a href="http://www.doctrine-project.org/projects/common.html">doctrine/common</a>) or integrated with the ORM functionality. We&rsquo;ll look at both variants through simple examples, a good documentation can also be found <a href="http://docs.doctrine-project.org/en/latest/reference/caching.html">here</a>. Note that at the time of writing, the CouchbaseCache is not mentioned as a caching driver because the documentation still needs to be updated.</p>

<p>Since 2.4 has not been released yet, we need to work against the <code>2.4.x-dev</code> branch. We&rsquo;ll be using <a href="http://getcomposer.org/">Composer</a> to fetch our dependencies, so just need change the version number if you want to pin it down to 2.4 later.</p>

<h2 id="simple-caching">Simple Caching</h2>

<p>Our first example shows how the caching API can be used directly. If you are familiar with the Couchbase API, you may think that it&rsquo;s more or less just a different API with the same (and maybe less) semantics, but the point is that it uses the Doctrine Cache API interface and as a result you can switch between different caching implementations very easily.</p>

<p>Create a directory called <code>couchbase-doctrine-simple</code> with the following <code>composer.json</code> inside:</p>

<pre><code>{
    &quot;require&quot;: {
        &quot;doctrine/common&quot;: &quot;2.4.x-dev&quot;,
        &quot;ext-couchbase&quot;: &quot;1.1.x&quot;
    }
}
</code></pre>

<p>This installs the <a href="https://packagist.org/packages/doctrine/common">doctrine/common</a> package and also makes sure that we have the <code>couchbase.so</code> extension in place. If you haven&rsquo;t installed the Couchbase PHP extension already, head over to the <a href="http://www.couchbase.com/develop/php/current">official website</a> and install it based on the tutorial and the docs.</p>

<p>Create a <code>index.php</code> with the following content (we&rsquo;ll break up the code afterwards):</p>

<pre><code>&lt;?php
// 0: Composer Autoloader
require 'vendor/autoload.php';

// 1: Open the Couchbase Connection
$couchbase = new Couchbase(&quot;127.0.0.1&quot;, &quot;&quot;, &quot;&quot;, &quot;default&quot;);

// 2: Instantiate the Driver &amp; Inject the Connection
$cacheDriver = new \Doctrine\Common\Cache\CouchbaseCache();
$cacheDriver-&gt;setCouchbase($couchbase);

// 3: Execute your commands!
$key = &quot;my-cache-item&quot;;

if(!$cacheDriver-&gt;contains($key)) {
    $cacheDriver-&gt;save($key, &quot;my_data&quot;);
} else {
    echo $cacheDriver-&gt;fetch($key);
}
?&gt;
</code></pre>

<p>First, we need to bootstrap the composer autoloader so we don&rsquo;t have to write all <code>require</code> statements on our own. The next thing we need to do is actually connect to the Couchbase cluster:</p>

<pre><code>// 1: Open the Couchbase Connection
$couchbase = new Couchbase(&quot;127.0.0.1&quot;, &quot;&quot;, &quot;&quot;, &quot;default&quot;);
</code></pre>

<p>Here, we&rsquo;re connecting to a node in the cluster which points at <code>localhost</code>, but you can pass in an array of nodes as well. We connect to the <code>default</code> bucket, which has no password. Now that we have our connection established, we can instantiate the cache driver and inject our Couchbase client:</p>

<pre><code>// 2: Instantiate the Driver &amp; Inject the Connection
$cacheDriver = new \Doctrine\Common\Cache\CouchbaseCache();
$cacheDriver-&gt;setCouchbase($couchbase);
</code></pre>

<p>From here on, the API is the same for all cache drivers. The following code checks if the cache contains a key. If it is present, it prints out the document but if it isn&rsquo;t it creates a new one. This is a very simple example but shows how you can start to use Couchbase caching in your own projects with just a few lines of bootstrapping!</p>

<p>Aside from these three methods, there is also a <code>delete</code> method available. Finally, you can pass an optional third param on <code>save</code> with a <code>$lifeTime</code> so that the cache item vanishes automatically.</p>

<p>Since Couchbase Server doesn&rsquo;t care what you store, you can also save and fetch any kind of datatype (aside from resources):</p>

<pre><code>$cacheDriver-&gt;save($key, array('foo' =&gt; 'bar'));
var_dump($cacheDriver-&gt;fetch($key));
</code></pre>

<p>Note that when you use the driver at this level, try to store JSON strings when you can (use <code>json_encode</code>/<code>json_decode</code> on your datastructures) This way you can take advantage of the brand new view engine inside Couchbase Server 2.0. You can always just store serialized objects as well (like we need to do with ORM integration) since for Couchbase Server it&rsquo;s just a byte stream.</p>

<p>We can now build on this foundation and see how this works with ORM integration.</p>

<h2 id="orm-integration">ORM Integration</h2>

<p>Create a new directory called <code>couchbase-doctrine-orm</code> with the following <code>composer.json</code>:</p>

<pre><code>{
    &quot;require&quot;: {
        &quot;doctrine/orm&quot;: &quot;2.4.x-dev&quot;,
        &quot;doctrine/dbal&quot;: &quot;2.4.x-dev&quot;,
        &quot;doctrine/common&quot;: &quot;2.4.x-dev&quot;,
        &quot;ext-couchbase&quot;: &quot;1.1.x&quot;
    },
    &quot;autoload&quot;: {
        &quot;psr-0&quot;: {
            &quot;Entities&quot;: &quot;src/&quot;
        }
    }
}
</code></pre>

<p>This time our <code>composer.json</code> file is a little bit longer, because we need to define all of our dependencies by hand (since we don&rsquo;t want to work against the stable release). Since we need to define Doctrine Entities we pass the composer autoloader the custom directory (<code>src/</code>).</p>

<p>The next thing we need is our actual entity that we want to manage through Doctrine. Go ahead and create a <code>Person.php</code> file inside the <code>src/Entities</code> directory with the following content:</p>

<pre><code>&lt;?php

namespace Entities;

/** @Entity */
class Person {

    /**
     * @Id @Column(type=&quot;integer&quot;) @GeneratedValue(strategy=&quot;AUTO&quot;)
     */
    private $id;

    /** @Column(type=&quot;string&quot;) */
    private $firstname;

    /** @Column(type=&quot;string&quot;) */
    private $lastname;

    public function setFirstname($firstname) {
        $this-&gt;firstname = $firstname;
    }

    public function getFirstname() {
        return $this-&gt;firstname;
    }

    public function setLastname($lastname) {
        $this-&gt;lastname = $lastname;
    }

    public function getLastname() {
        return $this-&gt;lastname;
    }

}

?&gt;
</code></pre>

<p>This is a very simple Doctrine Entity that has some properties and also a autogenerated <code>ID</code> field. I&rsquo;m going to use <a href="http://www.sqlite.org/">SQLite</a> in the following example, but feel free to use MySQL or any other relational database that you have available.</p>

<p>To wire everything together, we&rsquo;re going to create a <code>index.php</code> file in the root directory of the project. Again, here is the full content and we&rsquo;re going to break it apart afterwards:</p>

<pre><code>&lt;?php
// Composer autoloader.
$loader = require 'vendor/autoload.php';

/**
 * Initialize Couchbase &amp; the Cache.
 */
$couchbase = new Couchbase(&quot;127.0.0.1&quot;, &quot;&quot;, &quot;&quot;, &quot;default&quot;);
$cacheDriver = new \Doctrine\Common\Cache\CouchbaseCache();
$cacheDriver-&gt;setCouchbase($couchbase);


/**
 * Initialize the Entity Manager.
 */
$paths = array(__DIR__ . '/src/Entities/');
$isDevMode = true;
$dbParams = array(
    'driver' =&gt; 'pdo_sqlite',
    'user' =&gt; 'root',
    'password' =&gt; '',
    'path' =&gt; __DIR__ . '/cbexample.sqlite'
);

$config = \Doctrine\ORM\Tools\Setup::createAnnotationMetadataConfiguration($paths, $isDevMode, null, $cacheDriver);
$em = \Doctrine\ORM\EntityManager::create($dbParams, $config);

/**
 * Work with our Entities.
 */
$person = new \Entities\Person();
$person-&gt;setFirstname(&quot;Michael&quot;);
$person-&gt;setLastname(&quot;Nitschinger&quot;);

$em-&gt;persist($person);
$em-&gt;flush();

// Query with Result Cache
$query = $em-&gt;createQuery('select p from Entities\Person p');
$query-&gt;useResultCache(true);
$results = $query-&gt;getResult();

?&gt;
</code></pre>

<p>Since this may be a lot to grasp, let&rsquo;s break it into smaller sized chunks.</p>

<pre><code>$couchbase = new Couchbase(&quot;127.0.0.1&quot;, &quot;&quot;, &quot;&quot;, &quot;default&quot;);
$cacheDriver = new \Doctrine\Common\Cache\CouchbaseCache();
$cacheDriver-&gt;setCouchbase($couchbase);
</code></pre>

<p>After our bootstrapping the autoloader, we&rsquo;re initializing the cache driver. You already know what this means because we&rsquo;ve used the same code in the simple example before.</p>

<pre><code>$paths = array(__DIR__ . '/src/Entities/');
$isDevMode = true;
$dbParams = array(
    'driver' =&gt; 'pdo_sqlite',
    'user' =&gt; 'root',
    'password' =&gt; '',
    'path' =&gt; __DIR__ . '/cbexample.sqlite'
);

$config = \Doctrine\ORM\Tools\Setup::createAnnotationMetadataConfiguration($paths, $isDevMode, null, $cacheDriver);
$em = \Doctrine\ORM\EntityManager::create($dbParams, $config);
</code></pre>

<p>The <code>\Doctrine\ORM\EntityManager</code> is one of the major building blocks inside Doctrine and needs to be initialized accordingly. Therefore, we need to provide it a valid configuration. Here we&rsquo;re going to use annotations (as seen on the Doctrine Entity, but you can also do it through XML or YAML). We also need to provide our database connection and the path to the entities. The important part here is that we pass the <code>$cacheDriver</code> to the factory method. This automatically initializes our <code>CouchbaseCache</code> to be used for all kinds of caching (Query, Metadata and Result caching).</p>

<p>Now we can go ahead and create a record:</p>

<pre><code>$person = new \Entities\Person();
$person-&gt;setFirstname(&quot;Michael&quot;);
$person-&gt;setLastname(&quot;Nitschinger&quot;);

$em-&gt;persist($person);
$em-&gt;flush();
</code></pre>

<p>Afterwards, we can fetch it back through a query:</p>

<pre><code>$query = $em-&gt;createQuery('select p from Entities\Person p');
$query-&gt;useResultCache(true);
$results = $query-&gt;getResult();
</code></pre>

<p>Note that we explicitely tell it to cache this query result for us (by default, result caching won&rsquo;t be used). If open the browser and point it to your Couchbase Server 2.0 management UI, you can see that Doctrine did create lots of documents behind the scenes. These are subsequently used to boost your application performance.</p>

<h2 id="summary">Summary</h2>

<p>As you can see, using Couchbase as a Cache for Doctrine is not hard. You just need to initialize it and pass it into the configuration. From this point on, everything happens behind the scenes. And don&rsquo;t forget that you not only get exceptional performance, but also persistence, scalability and all the cool stuff that Couchbase Server provides out of the box.</p>

<p>If you have any questions or input, please let me know in the comments! Finally, thanks to <a href="https://twitter.com/Ocramius">Marco Pivetta</a> for helping me debug an <a href="https://github.com/doctrine/common/pull/240">issue</a> with ORM integration!</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">30 May 2011</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://nitschinger.at/caching-responses-in-lithium/" class="post-title">Caching responses in Lithium</a>

                        <p class="post-meta">
                            
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>If you need to cache full <code>Response</code> objects in Lithium (which means that your controllers don&rsquo;t even get called when there&rsquo;s a cache hit), you can place this in your <code>app/config/bootstrap/cache.php</code> file (note that this is certainly not &ldquo;production ready&rdquo;, but it should give you a starting point):</p>

<pre><code>/**
 * Cache full Responses
 */
Dispatcher::applyFilter('run', function($self, $params, $chain) {
    $key = md5(LITHIUM_APP_PATH) . '.app.cache.'.md5($params['request']-&gt;url);
    if($cache = Cache::read('default', $key)) {
        return $cache;
    }

    $result = $chain-&gt;next($self, $params, $chain);

    Cache::write('default', $key, $result, '+1 day');
    return $result;
});
</code></pre>

<p>It filters the <code>Dispatcher</code> and first checks if the <code>Response</code> object is already stored in the cache. The cache key is based on the requested URL, so if your <code>/</code> URL points to `<code>/posts/index</code>, both requests will be cached seperately (you could modify the code snipped so that it talks to the <code>Router</code> and checks for the corresponding controller/action object and cache on this key).</p>

<p>Your filter chain returns the <code>Response</code> object, so we can directly cache it. The serialization strategy takes care of correctly storing and retrieving our cached object.</p>

<p>If you have alternative approaches to tackle this, please let me know!</p>

                    </div>
                </section>
                
            </div>
            

            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>&copy; Michael Nitschinger 2010-2018</li>
        </ul>
    </div>
</div>
<script src="https://nitschinger.at/js/all.min.js"></script>
<script>
    (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
            m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-19686689-1', 'auto');
    ga('send', 'pageview');
    ga('set', 'anonymizeIp', true);
</script>
        </div>
    </div>
</div>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');

</script>

</body>
</html>
