<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>reactive on daschl writes. sometimes.</title>
    <link>https://nitschinger.at/tags/reactive/</link>
    <description>Recent content in reactive on daschl writes. sometimes.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 01 Apr 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://nitschinger.at/tags/reactive/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Reactive Barriers with Reactor</title>
      <link>https://nitschinger.at/Reactive-Barriers-with-Reactor/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Reactive-Barriers-with-Reactor/</guid>
      <description>In the non-reactive java world, if you need a couple threads waiting on a barrier to move forward together, a common approach is to use a CountDownLatch.
Here is how the documentation describes it succinctly:
 A CountDownLatch is initialized with a given count. The await methods block until the current count reaches zero due to invocations of the countDown() method, after which all waiting threads are released and any subsequent invocations of await return immediately.</description>
    </item>
    
  </channel>
</rss>