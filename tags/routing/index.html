<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Routing &middot; daschl writes. sometimes.</title>

    <meta name="description" content="">

    <meta name="generator" content="Hugo 0.17" />
    <meta name="twitter:card" content="summary">
    
    <meta name="twitter:title" content="Routing &middot; daschl writes. sometimes.">
    <meta name="twitter:description" content="">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Routing &middot; daschl writes. sometimes.">
    <meta property="og:description" content="">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">
    <!--<![endif]-->

    <link rel="stylesheet" href="http://nitschinger.at//css/all.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="daschl writes. sometimes." href="http://nitschinger.at//index.xml" />
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title"><a href="http://nitschinger.at/">daschl writes. sometimes.</a></h1>
            <h2 class="brand-tagline"></h2>
        </hgroup>

        <nav class="nav">
            <ul class="nav-list">
                <li class="nav-item">
                    <a class="pure-button" href="https://twitter.com/daschl"><i class="fa fa-twitter"></i> Twitter</a>
                </li>
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/daschl"><i class="fa fa-github-alt"></i> github</a>
                </li>
                <li class="nav-item">
                    <a class="pure-button" href="http://nitschinger.at//index.xml"><i class="fa fa-rss"></i> rss</a>
                </li>
            </ul>
        </nav>
    </div>
</div>


    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                
                <h1 class="content-subhead">24 Feb 2011</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://nitschinger.at/Understanding-the-Lithium-Router-Part-2/" class="post-title">Understanding the Lithium Router - Part 2</a>

                        <p class="post-meta">
                            
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h3 id="introduction">Introduction</h3>

<p>Routes play an essential role in your request/response-cycle and therefore should also be tested like any other component that you develop. As the Lithium routing infrastructure also consists of classes and methods, we can run unit and integration tests against them.</p>

<p>If we follow the testing conventions, we need to differentiate two distinct methods of testing. The first one (the so called &ldquo;<a href="http://en.wikipedia.org/wiki/Unit_testing">Unit Test</a>&rdquo;), is used to test your routes one by one, isolated from your application and ideally all dependencies are mocked away. The second one (called &ldquo;<a href="http://en.wikipedia.org/wiki/Integration_testing">Integration Test</a>&rdquo;), takes the state of your actual application into account and therefore tests the routes in a &ldquo;real environment&rdquo;. This way we can validate their functionality in isolation, and when we are confident with that we can check that no dependencies or other interfaces change the expected behavior.</p>

<p>Let&rsquo;s cover unit tests first and then move on to the integration tests. Afterwards, we&rsquo;ll look at testing reverse routes (more on that later).</p>

<h3 id="unit-testing">Unit Testing</h3>

<p>Let me clarify one thing first: in general, you don&rsquo;t need to unit test your routes (instead you only need to do integration testing, but more on that later). There core developers did an awesome job in unit testing the routing infrastructure for you, so there is no need for you to duplicate their tests.</p>

<p>Nevertheless, learning  something about unit testing routes has two benefits. On the one hand, you get some practice in writing unit tests and on the other hand you get a better understand on how the routing system works internally. So i really recommend you to read through this section and play around with the code.</p>

<p>If we don&rsquo;t know how to implement unit tests, it is always a good idea to look at the core tests, as they show us how to do this properly and at the same time give us use cases that we can use in our own application. We can also copy and modify some tests, because often our own tests will be similar.</p>

<p>Before we can unit test some routes, we need to add a unit test file. According to the namespace standard, let&rsquo;s create the appropriate file (<code>RouteTest.php</code>) in <code>app\tests\cases\net\http</code>:</p>

<pre><code>&lt;?php
namespace app\tests\cases\net\http;

use lithium\action\Request;
use lithium\net\http\Route;

class RouteTest extends \lithium\test\Unit {

}

?&gt;
</code></pre>

<p>In our first test, we want to make sure that the route <code>/foo</code>, matches the <code>FooController</code> and the <code>index</code> action. Insert the following test case in your previously created class and run it through the test runner (&ldquo;<a href="http://example.com/test/app/tests/cases/net/http/RouteTest&quot;">http://example.com/test/app/tests/cases/net/http/RouteTest&quot;</a>).</p>

<pre><code>public function testFooRoute() {
    $params = array('controller' =&gt; 'foo', 'action' =&gt; 'index');
    $route = new Route(array(
        'template' =&gt; '/foo',
        'params' =&gt; $params
    ));

    $request = new Request();
    $request-&gt;url = '/foo';

    $result = $route-&gt;parse($request);
    $this-&gt;assertEqual($params, $result-&gt;params);
}
</code></pre>

<p>If we run <code>Router::connect()</code>, the <code>Router</code> basically creates a new <code>Route</code> object and passes the arguments to its constructor. In our tests we do the same, but we initialize the Route directly. This way, we can test the route in isolation. When we create a new route, the <code>template</code> param is the URL that our route will match (remember that it can also contain non-static identifiers). The params argument tells
the route what to return when the template matches the request. We then create a simple <code>Request</code> object (that mimics a request by the browser) and hard-code a URL (in the real application, the <code>$request-&gt;url</code> will be dynamically assigned). Now we run <code>parse()</code>,
that&rsquo;s exactly what the Router does route for route when the <code>Dispatcher</code> asks him to route the request. The parse method returns a <code>Request</code> object with the params set accordingly when it matches, and false when it does not.</p>

<p>To get more familiar, we&rsquo;ll add some more assertions to this test, just append them after the last <code>assertEqual()</code> and run the tests again. You can see that this route really matches only <code>/foo</code> and nothing else:</p>

<pre><code>$request-&gt;url = '/bar';
$result = $route-&gt;parse($request);
$this-&gt;assertFalse($result);

$request-&gt;url = '/foo/edit';
$result = $route-&gt;parse($request);
$this-&gt;assertFalse($result);
</code></pre>

<p>Now that we wrote some basic tests, let&rsquo;s move on to a slightly more complex example with a non-static routing template. The route <code>/users/{:id}</code> matches with or without an ID given and passes it as a param in the returned request object.</p>

<pre><code>public function testUserWithIdRoute() {
    $params = array('id' =&gt; null, 'action' =&gt; 'index', 'controller' =&gt; 'users');
    $route = new Route(array(
        'template' =&gt; '/users/{:id}',
        'params' =&gt; $params
    ));
    $request = new Request();

    $request-&gt;url = '/users';
    $result = $route-&gt;parse($request);
    $this-&gt;assertEqual($params, $result-&gt;params);
    $this-&gt;assertNull($result-&gt;params['id']);

    $request-&gt;url = '/users/4';
    $result = $route-&gt;parse($request);
    $this-&gt;assertEqual(4, $result-&gt;params['id']);
}
</code></pre>

<p>We can also test for various HTTP parameters like the request type (typically GET, PUT, POST and DELETE). Let&rsquo;s assume we want to match <code>/cocktails/delete/{:id}</code> only when the id is present (non-optional), it is numeric and the request method is <code>delete</code>. The equivalent router call in our <code>routes.php</code> file would be <code>Router::connect('/cocktails/delete/{:id:\d+}, array('controller' =&gt; 'cocktails', 
'action' =&gt; 'delete', 'http:method' =&gt; 'DELETE'));</code>.</p>

<pre><code>public function testCocktailDeleteRoute() {
    $params = array(
        'controller' =&gt; 'cocktails',
        'action' =&gt; 'delete',
        'http:method' =&gt; 'DELETE'
    );
    $route = new Route(array(
        'template' =&gt; '/cocktails/delete/{:id:\d+}',
        'params' =&gt; $params
    ));

    $request = new Request();
    $request-&gt;url = '/cocktails/delete/4';
    $result = $route-&gt;parse($request);
    $this-&gt;assertFalse($result);

    $request = new Request(array('env' =&gt; array('REQUEST_METHOD' =&gt; 'DELETE')));
    $request-&gt;url = '/cocktails/delete';
    $result = $route-&gt;parse($request);
    $this-&gt;assertFalse($result);

    $request = new Request(array('env' =&gt; array('REQUEST_METHOD' =&gt; 'DELETE')));
    $request-&gt;url = '/cocktails/delete/4';
    $result = $route-&gt;parse($request);
    $this-&gt;assertEqual(4, $result-&gt;params['id']);
}
</code></pre>

<p>As stated in the first lines of this section, you won&rsquo;t need to do this in your application code, but writing this kind of tests has one more benefit: if something goes wrong, it is a great tool to understand the inner workings and also to test scenarios in isolation. If you encounter any bugs in the router, writing a unit test that shows the failure is also highly recommended, so that the core team is able to track down your problem and reproduce it in their environments. Also, writing failing test cases ensures that after a bug is fixed, it never happens again.</p>

<p>A great way to inspect and debug routes is the <code>export()</code> method. With this method, you can inspect the full state of an route and run assertions against it. Let&rsquo;s try this in a test:</p>

<pre><code>public function testExport() {
    $params = array('controller' =&gt; 'posts', 'action' =&gt; 'index');
    $route = new Route(array(
        'template' =&gt; '/read',
        'params' =&gt; $params
    ));

    $exported = $route-&gt;export();
    $this-&gt;assertEqual($params, $exported['params']);
    $this-&gt;assertEqual('/read', $exported['template']);
    $this-&gt;assertFalse($exported['handler']);
}
</code></pre>

<p>Now let&rsquo;s move on to something that we should really use in our applications, integration testing.</p>

<h3 id="integration-testing">Integration Testing</h3>

<p>Now that we&rsquo;ve tested each route in isolation, it&rsquo;s time to get a higher-level view of our application. When we test more than one class in isolation, we call that &ldquo;Integration Testing&rdquo;. Technically, these tests are similar to normal unit tests, so you don&rsquo;t need to learn something new. In a typical framework request, the <code>Dispatcher</code> calls the <code>Router</code> with a <code>Request</code>, and the router matches it against all connected routes and checks if there is a match.</p>

<p>The following code snippets are suited for a default installation. Create a <code>RouterTest.php</code> file in <code>app/tests/integration/net/http</code>. Additionally, you may also need to create the appropriate subdirectories in there.</p>

<pre><code>&lt;?php
namespace app\tests\integration\net\http;
use lithium\net\http\Router;

class RouterTest extends \lithium\test\Unit {

}

?&gt;
</code></pre>

<p>We can issue a request against the router and check that the output is correct. Let&rsquo;s do that for a subset of our default routes:</p>

<pre><code>public function testRootRoute() {
    $expected = array('controller' =&gt; 'pages', 'action' =&gt; 'view');

    $request = new Request();
    $request-&gt;url = '/';

    $result = Router::process($request);
    $this-&gt;assertEqual($expected, $result-&gt;params);
}

public function testPagesRoutes() {
    $request = new Request();

    $request-&gt;url = '/pages';
    $result = Router::process($request);
    $expected = array(
        'controller' =&gt; 'pages',
        'action' =&gt; 'view'
    );
    $this-&gt;assertEqual($expected, $result-&gt;params);

    $request-&gt;url = '/pages/1';
    $result = Router::process($request);
    $expected = array(
        'args' =&gt; array('1'),
        'controller' =&gt; 'pages',
        'action' =&gt; 'view'
    );
    $this-&gt;assertEqual($expected, $result-&gt;params);
}

public function testDefaultRoutes() {
    $request = new Request();

    $request-&gt;url = '/foo';
    $result = Router::process($request);
    $expected = array(
        'controller' =&gt; 'foo',
        'action' =&gt; 'index'
    );
    $this-&gt;assertEqual($expected, $result-&gt;params);

    $request-&gt;url = '/foo/bar';
    $result = Router::process($request);
    $expected = array(
        'controller' =&gt; 'foo',
        'action' =&gt; 'bar'
    );
    $this-&gt;assertEqual($expected, $result-&gt;params);

    $request-&gt;url = '/foo/bar/1';
    $result = Router::process($request);
    $expected = array(
        'controller' =&gt; 'foo',
        'action' =&gt; 'bar',
        'args' =&gt; array('1')
    );
    $this-&gt;assertEqual($expected, $result-&gt;params);
}
</code></pre>

<p>Most of the code should look familiar to you, the most interesting part is the call of <code>Router::process()</code>. This method is also called by the dispatcher (but with the actual Request object). For every call to the Router, we simulate a request by the client browser. This code contains a high amount of duplication, so you may want to compact this and create a helper method in your test class that wraps and simplifies the duplicated code.</p>

<p>Here is another example for a route that we can test:</p>

<pre><code>use app\models\Post;

Router::connect('/{:slug:[\w\-]+}', array('Posts::show'), function($request) {

    $conditions = array(
        'conditions' =&gt; array(
            'slug' =&gt; $request-&gt;params['slug']
        )
    );

    if(Post::count($conditions)) {
        return $request;
    } else {
        return false;
    }

});
</code></pre>

<p>When this route is placed right before the default routes, it should correctly match URLs like <code>/a-cool-article</code>. The code inside the closure calls the database and checks if the given slug really exists in the database. If it does, it returns the request (and false if not). The router iterates over each route and when false is returned, he tries the next route. So when we return the <code>Request</code>-object, we tell the router that our route is the one he has searched for. To ensure that everything works as expected, we can write some integration tests.</p>

<pre><code>public function testSlugRoute() {
    $request = new Request();

    // a correct slug (stored in the db)
    $request-&gt;url = '/a-correct-slug';
    $result = Router::process($request);
    $expected = array(
        'controller' =&gt; 'posts',
        'action' =&gt; 'show',
        'slug' =&gt; 'a-correct-slug'
    );
    $this-&gt;assertEqual($expected, $result-&gt;params);

    // not a correct slug, renders a default route
    $request-&gt;url = '/foobar-not-a-slug-here';
    $result = Router::process($request);
    $expected = array(
        'controller' =&gt; 'posts',
        'action' =&gt; 'show',
        'slug' =&gt; 'foobar-not-a-slug-here'
    );
    $this-&gt;assertNotEqual($expected, $result-&gt;params);
    $this-&gt;assertFalse(isset($result-&gt;params['slug']));

    // tests should always come first
    $request-&gt;url = '/test';
    $result = Router::process($request);
    $expected = array(
        'controller' =&gt; 'lithium\test\Controller',
        'action' =&gt; 'index',
    );
    $this-&gt;assertEqual($expected, $result-&gt;params);
    $this-&gt;assertFalse(isset($result-&gt;params['slug']));
}
</code></pre>

<p>This code assumes that your database has a reproducible set of posts stored in it. I&rsquo;d recommend you to load a set of posts with the <a href="http://rad-dev.org/li3_fixtures">li3_fixtures</a> plugin and then populate the database in the <code>setUp()</code> method. If you want to play around with it some more, I&rsquo;d suggest you to check the current <a href="http://lithify.me/docs/lithium/core/Environment">Environment</a> and test the different behavior for different environments.</p>

<p>With this tools at hand, you should be able to test everything that has to do with your routes and make sure that they are connected in the correct order and return the response you&rsquo;ve intended.</p>

<h3 id="reverse-routing">Reverse Routing</h3>

<p>As the router also handles reverse routing (which is used by the HTML helper to generate links), we can test it here too. Because we look at the router and its routes, reverse routing fits well into our router integration tests.</p>

<p>Testing reverse routing is straightforward, so let&rsquo;s start with some examples and work them through afterwards.</p>

<pre><code>public function testReverseRouting() {
    $expected = '/foo/bar';
    $params = array('controller' =&gt; 'foo', 'action' =&gt; 'bar');
    $result = Router::match($params);
    $this-&gt;assertEqual($expected, $result);

    $expected = '/pages';
    $params = array('controller' =&gt; 'pages', 'action' =&gt; 'index');
    $result = Router::match($params);
    $this-&gt;assertEqual($expected, $result);

    $expected = '/pages/index/1';
    $params = array('controller' =&gt; 'pages', 'action' =&gt; 'index', 'args' =&gt; array('1'));
    $result = Router::match($params);
    $this-&gt;assertEqual($expected, $result);
}
</code></pre>

<p>Here, we test the opposite direction. We pass the router a set of arguments and get an URL back. As it&rsquo;s the case with normal
routing, if two routes compete for the same URL, the first one wins. We call <code>Router::match()</code> with our request params and get a URL as a string returned. This way, we can test that our HTML helper will return the desired URLs in our application. Of course, you can also add some tests to the HTML Helper (where you can make sure that the echoed HTML code is correct). If the router is not able to translate your params into a URL, it will raise an exception.</p>

<h3 id="wrapping-up">Wrapping up</h3>

<p>In part two of our series we&rsquo;ve looked at unit testing routes, running integration tests against them and also testing the reverse routing
mechanism. Of course, these tests depend heavily on your application and will surely become more complex as the previous examples. The next higher level would be to do add some acceptance tests with <a href="http://seleniumhq.org/">Selenium</a>, so that you can test routes in combination with links and forms on your page, to make sure that the data flow works as expected between pages. Also, I&rsquo;m working on a BDD plugin for Lithium that works similar to <a href="http://cukes.info/">Cucumber</a>, so stay tuned.</p>

<p>I really hope that you&rsquo;ve enjoyed the second part of this series. Also, thanks again to <a href="http://twitter.com/#!/nateabele">@nateabele</a> for his helpful comments.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">05 Feb 2011</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://nitschinger.at/Understanding-the-Lithium-Router-Part-1/" class="post-title">Understanding the Lithium Router - Part 1</a>

                        <p class="post-meta">
                            
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h3 id="introduction">Introduction</h3>

<p>The router is an integral part of the framework and has two main purposes. The first one is to match a URL against a set of previously connected routes, the second one is to generate a URL from a set of arguments (reverse routing). The router itself is very flexible as we&rsquo;ll see later on, but getting started is pretty easy. Lithium comes with a set of sensible default routes that help you to get on track immediately. While developing, you can always add, modify or remove routes and the application will instantly take these changes into account. When you are running in production mode, routes should be cached for performance reasons, because compiling and analyzing routes takes some time for every request. We&rsquo;ll see how this works in one of the upcoming posts.</p>

<p>At the time of writing, there is no full featured guide available. Nevertheless, Lithium provides an extensive API documentation that covers nearly every aspect of the routing system. For your convenience, here are some short links to <a href="http://lithify.me/docs/lithium/net/http/Router">the Router</a> and <a href="http://lithify.me/docs/lithium/net/http/Route">the Route</a> classes. Usually a good place for examples are unit tests, and the core developers worked hard to implement high code coverage and extensive unit tests. You can find them online <a href="http://dev.lithify.me/lithium/source/libraries/lithium/tests/cases/net/http">here</a>.</p>

<h4 id="the-request-response-cycle">The Request/Response-Cycle</h4>

<p>Before we dive into the router itself, it would be a good idea to take a look where the router is placed in the request/response-cycle and how it participates in the typical dispatching process.</p>

<p>The index.php-Page creates a new request object and hands it over to the dispatcher. The dispatcher hands this request object over to the router, who matches it against his connected routes and returns parameters that tell the dispatcher which controller and action to execute. If no matching route is found, an exception is raised. The dispatcher then instantiates the correct Controller object, which returns - after processing the associated models, controller actions and views - a response object. The dispatcher then sends the headers
and the content of the response object back to the browser.</p>

<p>After reading this, you may notice that the flow of the request and response objects is really straightforward. It is possible to modify or exchange every part of this dispatching process, so you have the full flexibility at your fingertips if you need it.</p>

<p>The whole Lithium routing functionality is organized in separate classes that perform distinct operations. Two classes mainly participate in the routing process. The <code>lithium\net\http\Router</code> has one or more  instances of <code>lithium\net\http\Route</code> connected to itself. When the router has to route the request, it iterates over the connected routes and checks if one of them match. The routes are checked in the same order as they&rsquo;re connected, so the first match wins the race. Therefore you need to be careful when designing your routes, as this may have some impact on your performance. When no matching routes are found (and no default routes are in place), then a <code>lithium\net\http\RoutingException</code> is raised. We&rsquo;ll use this behavior in the second part to render a 404-Page.</p>

<p>Enough talk, let&rsquo;s get started.</p>

<h3 id="basics-first">Basics First</h3>

<p>Usually, there is only one file you&rsquo;ll need to modify when you want to add or modify your application routes. The <code>app/config/routes.php</code> file is part of the bootstrap process and connects your routes to the router. If you open the file, you&rsquo;ll see that there are already a few routes defined. We&rsquo;ll look at them route by route, because they cover most of the syntax we&rsquo;ll usually need.</p>

<p>We always use the  <code>Router::connect()</code> method if we want to bind a given URL to a set of parameters. The first route is also called the &ldquo;root&rdquo;, because this route will be used if the user hits your application with no additional parameters (like <code>http://www.example.com</code>).</p>

<pre><code>Router::connect('/', array('Pages::view', 'args' =&gt; array('home')));
</code></pre>

<p>The <code>Router::connect()</code> method expects at least one argument, two more can also be specified. We&rsquo;ll see more of them in later examples. The first argument is a string with the URL, the second one can be just a string or an array with information on how to map the URL to controllers and actions. For the first route, when the user hits the application with the root URL &ldquo;/&rdquo;, the <code>app\controllers\PagesController</code> and its <code>view</code> action is called. Additionally, a &ldquo;args&rdquo; param with the value &lsquo;home&rsquo; is passed to the controller. This argument is used afterwards in the controller action to render the <code>home</code> view. Of course this is not necessary, but it showcases the flexibility of routes.</p>

<p>The next route connects URLs like <code>/pages/foo</code> or <code>/pages/bar</code> to the PagesController and the view action.</p>

<pre><code>Router::connect('/pages/{:args}', 'Pages::view');
</code></pre>

<p>If you re-read the first route now, you should see obvious similarities. These two routes call the same controller and the same action, but the first route sets the <code>args</code> param to a static value, while the second route sets it dynamically (based on the request). You can also pass an array as the second argument, which can give you more flexibility. The equal method call with an array passed as the second argument would look like this:</p>

<pre><code>Router::connect('/pages/{:args}', array('controller' =&gt; 'pages', 'action' =&gt; 'view'));
</code></pre>

<p>This way of calling <code>Router::connect()</code>allows you to specify more arguments, but if you only need to route to a Controller/Action combination without further arguments, the first example is much shorter and as a result way easier to read.</p>

<p>The <code>{:args}</code> string acts as a placeholder, so let&rsquo;s have a look at the controller and see how he uses the passed arguments (<code>app\controllers\PagesController</code>).</p>

<pre><code>public function view() {
    $path = func_get_args();

    if (empty($path)) {
        $path = array('home');
    }
    $this-&gt;render(array('template' =&gt; join('/', $path)));
}
</code></pre>

<p>The <code>args</code> keyword defined in the route is passed to the view action as a param. If no path was set, the action sets it to &ldquo;home&rdquo;. Afterwards, the correct template is rendered. This is just one way to use the passed arguments, we&rsquo;ll see different methods in a minute.</p>

<p>The next code snippet connects testing routes, but only when we are not in the production environment. You see that the routing system is flexible enough to take other conditions of the environment into account.</p>

<pre><code>if (!Environment::is('production')) {
    Router::connect('/test/{:args}', array('controller' =&gt; 'lithium\test\Controller'));
    Router::connect('/test', array('controller' =&gt; 'lithium\test\Controller'));
}
</code></pre>

<p>By default, Lithium searches for the controller in the <code>app\controllers</code> namespace, so if you want to specify a controller in a different path, you&rsquo;ll need to give Lithium the fully namespaced path (for example if you need to match a route against a controller in a plugin). These two routes match <code>/test</code> and also <code>/test/lithium/tests/cases/action/ControllerTest</code>.</p>

<p>The last routes you&rsquo;ll find in the <code>routes.php</code> file are the so called &ldquo;default routes&rdquo;. Because of the fact that route matching occurs in the same order as they are connected, they need to be connected at last (otherwise these routes would always match every request).</p>

<pre><code>Router::connect('/{:controller}/{:action}/{:id:[0-9]+}.{:type}', array('id' =&gt; null));
Router::connect('/{:controller}/{:action}/{:id:[0-9]+}');
Router::connect('/{:controller}/{:action}/{:args}');
</code></pre>

<p>The <code>{:controller}</code>, <code>{:action}</code>and <code>{:type}</code> keywords are treated specially. These three keywords are used by the router to dynamically find and match the correct Controller/Action combination and render the result as the correct <code>lithium\net\http\Media</code>-type. If a optional <code>{:id}</code> is given, it is also passed down to the action. By convention, if no action is given <code>YourController::index()</code> is assumed. The default routes also make it easy to define a separate output type (like JSON or XML), which can be used to render the data in an other format instead of HTML. If you want to learn more about this feature, be sure to read my blog post about <a href="http://nitschinger.at/Add-an-RSS-Feed-to-your-blog-with-Lithium">&ldquo;Adding an RSS Feed to your blog with Lithium&rdquo;</a>.</p>

<p>These default routes match nearly everything, like <code>/posts</code>, <code>/posts/show/4</code> or <code>/posts/index.json</code>. This default routes work perfectly with ids generated by MySQL auto increment (or anything similar), but it doesn&rsquo;t work with MongoDB-IDs. Check out my blog post about <a href="http://nitschinger.at/Lithium-Routes-And-Mongo-DB">&ldquo;Lithium Routes And MongoDB&rdquo;</a>.</p>

<p>To understand the routing process full-stack, we also need to investigate how we can access the <code>Request</code>-object and its params. In the next snippet you&rsquo;ll find various examples of routes and how their params can be used in your controller. They always follow the same schema, so once you get used to it you should not need to look up the documentation again.</p>

<p>The slug-route is a bit more complex for now, but we&rsquo;ll cover these kind of routes in the next part.</p>

<pre><code>/**
 * connects the root URL to the PostsController and the &quot;index&quot;-action.
 */
Router::connect('/', array('Posts::index'));

/**
 * connects login and logout shorthand URLs to the UsersController.
 */
Router::connect('/login', array('Users::login'));
Router::connect('/logout', array('Users::logout'));

/**
 * connects slug URLs in my blog to the PostsController.
 */
Router::connect('/{:slug:[\w\-]+}', array('Posts::show'));

/**
 * the corresponding Posts::show() action (the slug is passed in the request object).
 * the show-action can be called with an id (default route), or with a slug (previous route)
 */
public function show() {
    if(isset($this-&gt;request-&gt;id)) {
        $post = Post::first($this-&gt;request-&gt;id);
    } elseif(isset($this-&gt;request-&gt;params['slug'])) {
        $post = Post::first(array('conditions' =&gt; array('slug' =&gt; $this-&gt;request-&gt;params['slug'])));
    }
    if(!count($post)) {
        $this-&gt;redirect('Posts::index');
    }
    return compact('post');
}
</code></pre>

<h4 id="generating-urls">Generating URLs</h4>

<p>As said previously, the routing infrastructure is not only capable of matching URLs to routes, but also matching a set of given parameters and generate a URL out of them. This technique is called &ldquo;reverse routing&rdquo;. The HTML-Helper for example does this for if you use its <a href="http://lithify.me/docs/lithium/template/helper/Html::link%28%29">&ldquo;link&rdquo;</a>-method. If you want to trigger the reverse routing functionality manually, you can do this by querying the <code>Router::match()</code> method. Here is an example from the Lithium documentation that illustrates this behavior. Both <code>Router::match()</code> queries return the URL &ldquo;/login&rdquo; as a result:</p>

<pre><code>Router::connect('/login', array('controller' =&gt; 'users', 'action' =&gt; 'login'));
// params as an array
$url = Router::match(array('controller' =&gt; 'users', 'action' =&gt; 'login'));
// a more compact syntax
$url = Router::match('User::login');
</code></pre>

<p>By using this method to generate URLs, you also make sure that your application is portable and works even if you place the application under a subdirectory on the server.</p>

<h3 id="wrapping-up">Wrapping Up</h3>

<p>After reading this post you should have a basic understanding on how the router works and how it participates in the whole request/response cycle. The next posts will cover more advanced topics like testing routes,
<a href="http://en.wikipedia.org/wiki/Representational_State_Transfer">REST</a>ful routes, namespaces/prefixes, bypassing the framework altogether, catching exceptions and even various production deployment considerations.</p>

<p>If you want to read about a specific topic, feel free to comment below. Any feedback would be also greatly appreciated. Lastly, special thanks to <a href="http://twitter.com/#!/nateabele">@nateabele</a> for reading through this post and providing important feedback.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">19 Nov 2010</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://nitschinger.at/Lithium-Routes-And-Mongo-DB/" class="post-title">Lithium Routes And MongoDB</a>

                        <p class="post-meta">
                            
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>Lithium comes with a powerful and flexible routing system. However, in its default configuration, you may encounter some problems with MongoDB-ObjectIDs and reverse routing. ObjectIDs are usually the &ldquo;primary keys&rdquo; of your Document in MongoDB, are 12 bytes long and consist of numbers and characters from &lsquo;a&rsquo; to &lsquo;f&rsquo;. A typical ObjectID would look similar to <code>4ce2d9f99436485e05000000</code>.</p>

<p>If you take a closer look at the default routes that ship with Lithium, you&rsquo;ll maybe notice that the <code>:id</code> part only matches numbers (and not characters).</p>

<pre><code>Router::connect('/{:controller}/{:action}/{:id:[0-9]+}.{:type}', array('id' =&gt; null));
Router::connect('/{:controller}/{:action}/{:id:[0-9]+}');
Router::connect('/{:controller}/{:action}/{:args}');
</code></pre>

<p>With this setup a call to <code>$this-&gt;html-&gt;link()</code> with an MongoDB-ObjectID set as <code>id</code> won&rsquo;t work because the router is not able to find a matching route (this is called reverse routing). The solution to this &ldquo;problem&rdquo; is, that we need to modify the <code>:id</code>-part of the <code>Router::connect</code>-calls. Replace your default routes with the following code:</p>

<pre><code>Router::connect('/{:controller}/{:action}/{:id:[0-9a-f]{24}}.{:type}', array('id' =&gt; null));
Router::connect('/{:controller}/{:action}/{:id:[0-9a-f]{24}}');
Router::connect('/{:controller}/{:action}/{:args}');
</code></pre>

<p>Now everything should work as expected with li3 and MongoDB ObjectIDs. A final note for the interested reader: if you leave out the <code>{24}</code>-quantifier, then a route like <code>/posts/add</code> won&rsquo;t work because <code>add</code> would also be a valid <code>id</code> to the router.</p>

                    </div>
                </section>
                
            </div>
            

            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
                <li>&copy; Michael Nitschinger 2010-2016</li>
        </ul>
    </div>
</div>
<script src="http://nitschinger.at//js/all.min.js"></script>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-19686689-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
        'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();

</script>

        </div>
    </div>
</div>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');

</script>

</body>
</html>
