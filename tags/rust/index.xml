<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rust on daschl writes. sometimes.</title>
    <link>https://nitschinger.at/tags/rust/</link>
    <description>Recent content in rust on daschl writes. sometimes.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 12 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://nitschinger.at/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Digging into TSIC and ZACWire with the Saleae Logic Analyzer</title>
      <link>https://nitschinger.at/Digging-into-TSIC-and-ZACWire-with-the-Saleae-Logic-Analyzer/</link>
      <pubDate>Sat, 12 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Digging-into-TSIC-and-ZACWire-with-the-Saleae-Logic-Analyzer/</guid>
      <description>My first real adventure into the embedded world has been porting the TSIC temperature sensor code from arduino to Rust. While the code seems to work fine for my use case, there are some pieces in the code which I ported from C but always scratched my head about. I neither owned a Oscilloscope nor a Logic Analyzer, so I was flying blind and had to trust the code I was porting.</description>
    </item>
    
    <item>
      <title>Writing an embedded display driver in Rust</title>
      <link>https://nitschinger.at/Writing-an-embedded-display-driver-in-Rust/</link>
      <pubDate>Sun, 15 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Writing-an-embedded-display-driver-in-Rust/</guid>
      <description>A year or so ago when I started my yourney into embedded development (to build a PID controller for my coffee machine) I bought a 1.5 inch RGB OLED display, which uses a SSD1351 controller. I got lucky, because a display driver for it already existed.
Unfortunately, very recently it stopped working and I&amp;rsquo;m not sure why. Okay, maybe I tightened those screws a bit too much. Anyways, since I did not need a color display, I bought a very similar 1.</description>
    </item>
    
    <item>
      <title>Getting Started with the nRF52840 in Rust</title>
      <link>https://nitschinger.at/Getting-Started-with-the-nRF52840-in-Rust/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Getting-Started-with-the-nRF52840-in-Rust/</guid>
      <description>After my last blog post on the TSIC 306 temperature sensor port to Rust, someone on Reddit mentioned that it does not provide any guidance on how to get the code samples actually running on the chip.
So this post takes a step back and runs you through the basics of setting up a project, configuring it properly and finally running different examples.
Before we dive in I want to mention that I&amp;rsquo;m still quite new to the embedded world, so some of the information might not be accurate or misleading.</description>
    </item>
    
    <item>
      <title>Rusty-PID: Porting the TSic sensor from C to Rust</title>
      <link>https://nitschinger.at/Rusty-PID-Porting-the-TSic-sensor-from-C-to-Rust/</link>
      <pubDate>Mon, 28 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Rusty-PID-Porting-the-TSic-sensor-from-C-to-Rust/</guid>
      <description>This post is part of my &amp;ldquo;Rusty-PID&amp;rdquo; series, in which you can follow my adventure building a PID Controller for my Rancilio Silvia in Rust.
In this blog post we&amp;rsquo;ll dive into how to read temperature measurements from the TSic sensor in Rust. It goes pretty deep into the implementation details and the porting process, so if you just want to use it go straight to the tsic-rs repository and don&amp;rsquo;t look back.</description>
    </item>
    
    <item>
      <title>Rust on the WiFi Pineapple (and OpenWrt)</title>
      <link>https://nitschinger.at/Rust-on-the-Wifi-Pineapple-and-OpenWRT/</link>
      <pubDate>Mon, 02 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Rust-on-the-Wifi-Pineapple-and-OpenWRT/</guid>
      <description>Over the holidays I wanted to get a very simple Rust application running on my WiFi Pineapple Nano. Since I don&amp;rsquo;t have much experience with embedded systems and cross-compilation, it sounded like something fun to do and I was sure I might learn a thing or two. Many hours later and lots of frustration, I ended up with a simple solution that I&amp;rsquo;d like to share in this post.
The major obstacle to overcome is building your own standard library, since Rust doesn&amp;rsquo;t ship with one for our target out of the box.</description>
    </item>
    
    <item>
      <title>Text Analysis in Rust - Tokenization</title>
      <link>https://nitschinger.at/Text-Analysis-in-Rust-Tokenization/</link>
      <pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Text-Analysis-in-Rust-Tokenization/</guid>
      <description>I work for Couchbase where we are currently developing full text search capabilities based on bleve. Bleve is implemented in go and inspired by Apache Lucene, the reference implementation when it comes to full text search. While I am not directly involved in developing bleve I was curious about how it works internally and did take a look at the analyzers it provides.
Analyzers take your free form text and turn it into tokens which can then be used for indexing or queries.</description>
    </item>
    
    <item>
      <title>Scheduling Timers on OS X with Rust and Kqueue</title>
      <link>https://nitschinger.at/Scheduling-Timers-on-OS-X-with-Rust-and-Kqueue/</link>
      <pubDate>Wed, 15 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Scheduling-Timers-on-OS-X-with-Rust-and-Kqueue/</guid>
      <description>As a more or less POSIX compatible system I would&amp;rsquo;ve expected timer_create and friends to be available on OS X, but it turns out those functions are not available (at least I couldn&amp;rsquo;t find them after hours of research).
Looking into alternatives (spoiler: there are not many I think if you want to work from C/Rust) I settled on Kqueue. It doesn&amp;rsquo;t have all the features that the timer_ functions provide, but for what I need it seems to be good enough.</description>
    </item>
    
    <item>
      <title>First Steps with Rust and JNI</title>
      <link>https://nitschinger.at/First-Steps-with-Rust-and-JNI/</link>
      <pubDate>Fri, 19 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/First-Steps-with-Rust-and-JNI/</guid>
      <description>The first steps are always the hardest, at least thats how the saying goes. But it turns out that calling into Rust from Java is easier than I originally thought.
The following blog post shows you how to setup and compile a Rust library which can be called from Java userland. Note that everything you see in this post, while being functional, is very simplistic. Real world JNI has lots of nitty gritty details and pitfalls, but we need to start somewhere right?</description>
    </item>
    
    <item>
      <title>Binding Threads And Processes to CPUs in Rust</title>
      <link>https://nitschinger.at/Binding-Threads-And-Processes-to-CPUs-in-Rust/</link>
      <pubDate>Thu, 11 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Binding-Threads-And-Processes-to-CPUs-in-Rust/</guid>
      <description>In the previous post I&amp;rsquo;ve introduced the hwloc-rs library, which allows you to discover and manage hardware topologies. Discovering the capabilities of a machine is insightful, but it gets more interesting if you can perform certain actions based on those insights.
Binding threads or processes to distinct CPU cores is very important in high performance applications to isolate workloads, keep inter-core messaging latency to a minimum and also to prevent the operating system from relocating your threads between cores as it sees fit.</description>
    </item>
    
    <item>
      <title>Discovering Hardware Topology in Rust</title>
      <link>https://nitschinger.at/Discovering-Hardware-Topology-in-Rust/</link>
      <pubDate>Fri, 08 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Discovering-Hardware-Topology-in-Rust/</guid>
      <description>Todays programming languages and operation systems provide a bunch of abstraction layers over our hardware. Most of the time this is great, since we can write code quickly and make it run on lots of different machines. The opportunity cost with abstraction is (most of the time) performance and a lack of understanding.
To get the best performance out of hour hardware, it is important to understand it. Concepts like cache locality matter a lot, especially in modern NUMA architectures.</description>
    </item>
    
  </channel>
</rss>
