<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lithium on daschl writes. sometimes.</title>
    <link>https://nitschinger.at/tags/lithium/</link>
    <description>Recent content in Lithium on daschl writes. sometimes.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 03 Mar 2012 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://nitschinger.at/tags/lithium/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Introducing Relationships in Lithium</title>
      <link>https://nitschinger.at/Introducing-Relationships-in-Lithium/</link>
      <pubDate>Sat, 03 Mar 2012 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Introducing-Relationships-in-Lithium/</guid>
      <description>Introduction The model relationship support in Lithium is one of the hottest topics on IRC lately, so I thought it would be a good idea to blog about it.
Currently, Lithium supports 1:1 and 1:n relationships for relational databases. There is no m:n support out of the box (like CakePHP&amp;rsquo;s $hasAndBelongsToMany). This also means that MongoDB relationships are not implemented for now. If you look at the Roadmap, you can see that this is on the &amp;ldquo;pre 1.</description>
    </item>
    
    <item>
      <title>RFC: li3_fixtures Rewrite</title>
      <link>https://nitschinger.at/RFC-li3_fixtures-Rewrite/</link>
      <pubDate>Fri, 24 Feb 2012 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/RFC-li3_fixtures-Rewrite/</guid>
      <description>The li3_fixtures plugin was my first Lithium plugin ever, and while it works okay, I feel there is a lot I can do to make it better and more flexible. In this post I want to share my ideas for a new fixture plugin and also want to gather feedback from the community to make it even more awesome.
As far as I can see, there are three big use cases for fixtures:</description>
    </item>
    
    <item>
      <title>Playing with Composer and Lithium</title>
      <link>https://nitschinger.at/Playing-with-Composer-and-Lithium/</link>
      <pubDate>Mon, 23 Jan 2012 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Playing-with-Composer-and-Lithium/</guid>
      <description>About Composer Composer is a command-line tool that helps you manage your application dependencies. It automatically fetches packages, resolves dependencies and is easy to configure. The really good thing about Composer is that it isn&amp;rsquo;t bound to a specific framework and can be used with every kind of repository. Composer is similar to package managers like npm, so you may feel at home quickly.
The default repository of Composer is Packagist.</description>
    </item>
    
    <item>
      <title>Session Encryption with Lithium</title>
      <link>https://nitschinger.at/Session-Encryption-with-Lithium/</link>
      <pubDate>Fri, 20 Jan 2012 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Session-Encryption-with-Lithium/</guid>
      <description>The Basics If you check out the master branch, you can use the new Encrypt strategy to encrypt your session data automatically. This means that you can read and write session data in cleartext and they will be encrypted on the fly before getting stored (in a cookie, for example). You can read my post about &amp;ldquo;baking cookies like a chef&amp;rdquo; for PHPAdvent 2011 here. The article covers both HMAC signatures and encryption, and is a good place to start.</description>
    </item>
    
    <item>
      <title>Quick Tip: Lithium Redirect</title>
      <link>https://nitschinger.at/Quick-Tip-Lithium-Redirect/</link>
      <pubDate>Fri, 16 Sep 2011 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Quick-Tip-Lithium-Redirect/</guid>
      <description>While migrating lithium_bin as part of research over to MongoDB (from CouchDB), I found the following snippet in the routes.php file:
Router::connect(&#39;/&#39;, array(), function($request) { $location = array(&#39;controller&#39; =&amp;gt; &#39;pastes&#39;, &#39;action&#39; =&amp;gt; &#39;add&#39;); return new Response(compact(&#39;location&#39;)); });  This means that when the user enters the application via the root url (/), he instantly gets redirected to /pastes/add (or a different URL if you have custom routes configured).
This may seem ok at first, but there&amp;rsquo;s a problem.</description>
    </item>
    
    <item>
      <title>Letters from Lithium #2</title>
      <link>https://nitschinger.at/Letters-from-Lithium-2/</link>
      <pubDate>Mon, 05 Sep 2011 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Letters-from-Lithium-2/</guid>
      <description>About Letters from Lithium keeps you up to date about what happens in the Lithium core and community. If you have interesting news to share, comment below or ping me on twitter.
Core News Routing got a bit more awesome with route continuations. They allow you match more routes in one request, which is very useful in many cases. Take a look at this test case:
/** * Tests that continuation routes properly fall through and aggregate multiple route parameters.</description>
    </item>
    
    <item>
      <title>Letters from Lithium #1</title>
      <link>https://nitschinger.at/Letters-from-Lithium-1/</link>
      <pubDate>Tue, 02 Aug 2011 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Letters-from-Lithium-1/</guid>
      <description>About &amp;ldquo;Letters from Lithium&amp;rdquo; will be published on a regular basis to give you an update on what happens in the Lithium community. If you have interesting topics/plugins/stuff you want to read about, feel free to contact me through twitter or email.
Core News The Roadmap to 1.0 is going pretty well so far, and relationship support for relational databases has been already merged into master. For the impatient, there is also some documentation for it underway which can be found here.</description>
    </item>
    
    <item>
      <title>Using Environments in Lithium</title>
      <link>https://nitschinger.at/Using-Environments-in-Lithium/</link>
      <pubDate>Tue, 19 Jul 2011 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Using-Environments-in-Lithium/</guid>
      <description>Introduction Environments help you to manage multiple configurations for your application. Maybe you have a different database for testing than for production or you use file caching in development but APC in production. If your framework does not support this (or a similar) concept, it can be a pain to code this overhead for yourself. Therefore, Lithium frees you from this by providing a Environment class (in the \lithium\core namespace) which handles everything for you automatically.</description>
    </item>
    
    <item>
      <title>Testing the Lithium core for fun and profit</title>
      <link>https://nitschinger.at/Testing-the-Lithium-core-for-fun-and-profit/</link>
      <pubDate>Sat, 09 Jul 2011 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Testing-the-Lithium-core-for-fun-and-profit/</guid>
      <description>In modern web frameworks, testing is one of the most important pillars that ensure a clean, stable and extendable codebase. Testing support in Lithium was built in from the beginning and therefore it already features a great code coverage. The Lithium project aims to work out of the box on many platforms, including Microsoft Windows and its IIS, which was often neglected in the past.
The main purpose of this post is to show you how core tests work and were the core team needs help to improve things further.</description>
    </item>
    
    <item>
      <title>Lithium plugin roundup</title>
      <link>https://nitschinger.at/Lithium-plugin-roundup/</link>
      <pubDate>Wed, 22 Jun 2011 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Lithium-plugin-roundup/</guid>
      <description>Note that this list is by no means complete. If you don&amp;rsquo;t find your own mentioned here, feel free to comment below. I&amp;rsquo;ve also tried to roughly group them so you can find them later more easily.
Authentication &amp;amp; Security li3_access: Access control library by tmaiaroto.
li3_ids: Intrusion detection integration (phpids) by weluse.
li3_oauth: OAuth library by gwoo.
APIs and Externals li3_delayed_job: Ruby&amp;rsquo;s Delayed::Job port to Lithium by cgarvis.</description>
    </item>
    
    <item>
      <title>Securing Lithium Forms</title>
      <link>https://nitschinger.at/Securing-Lithium-Forms/</link>
      <pubDate>Wed, 08 Jun 2011 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Securing-Lithium-Forms/</guid>
      <description>CSRF (Cross-Site-Request-Forgery) attacks work by sending arbitary (form) requests from a victim. Normally, the receiving site (in our case the Controller who processes the form data) doesn&amp;rsquo;t know where the data comes from. The CSRF protection in Lithium aims to solve this problem in an elegant and secure way. You can read more about those attacks here. Note that you&amp;rsquo;ll need to clone the latest master branch of Lithium if you want to try it out now.</description>
    </item>
    
    <item>
      <title>Custom Finders with Lithium</title>
      <link>https://nitschinger.at/Custom-Finders-with-Lithium/</link>
      <pubDate>Fri, 03 Jun 2011 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Custom-Finders-with-Lithium/</guid>
      <description>Finders assist you with often-used database queries so you don&amp;rsquo;t have to write them over and over again. Out of the box, Lithium provides you with a bunch of them: all, first, count list and &amp;ldquo;magic finders like&amp;rdquo; findById or findFirstById. How these are constructed in the core is not relevant for now, but Lithium provides you with a mechanism to write your own finders easily.
To understand how we can implement our own finder, let&amp;rsquo;s take a look at the built-in first one.</description>
    </item>
    
    <item>
      <title>Caching responses in Lithium</title>
      <link>https://nitschinger.at/Caching-responses-in-Lithium/</link>
      <pubDate>Mon, 30 May 2011 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Caching-responses-in-Lithium/</guid>
      <description>If you need to cache full Response objects in Lithium (which means that your controllers don&amp;rsquo;t even get called when there&amp;rsquo;s a cache hit), you can place this in your app/config/bootstrap/cache.php file (note that this is certainly not &amp;ldquo;production ready&amp;rdquo;, but it should give you a starting point):
/** * Cache full Responses */ Dispatcher::applyFilter(&#39;run&#39;, function($self, $params, $chain) { $key = md5(LITHIUM_APP_PATH) . &#39;.app.cache.&#39;.md5($params[&#39;request&#39;]-&amp;gt;url); if($cache = Cache::read(&#39;default&#39;, $key)) { return $cache; } $result = $chain-&amp;gt;next($self, $params, $chain); Cache::write(&#39;default&#39;, $key, $result, &#39;+1 day&#39;); return $result; });  It filters the Dispatcher and first checks if the Response object is already stored in the cache.</description>
    </item>
    
    <item>
      <title>Understanding the Lithium Router - Part 2</title>
      <link>https://nitschinger.at/Understanding-the-Lithium-Router-Part-2/</link>
      <pubDate>Thu, 24 Feb 2011 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Understanding-the-Lithium-Router-Part-2/</guid>
      <description>Introduction Routes play an essential role in your request/response-cycle and therefore should also be tested like any other component that you develop. As the Lithium routing infrastructure also consists of classes and methods, we can run unit and integration tests against them.
If we follow the testing conventions, we need to differentiate two distinct methods of testing. The first one (the so called &amp;ldquo;Unit Test&amp;rdquo;), is used to test your routes one by one, isolated from your application and ideally all dependencies are mocked away.</description>
    </item>
    
    <item>
      <title>Understanding the Lithium Router - Part 1</title>
      <link>https://nitschinger.at/Understanding-the-Lithium-Router-Part-1/</link>
      <pubDate>Sat, 05 Feb 2011 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Understanding-the-Lithium-Router-Part-1/</guid>
      <description>Introduction The router is an integral part of the framework and has two main purposes. The first one is to match a URL against a set of previously connected routes, the second one is to generate a URL from a set of arguments (reverse routing). The router itself is very flexible as we&amp;rsquo;ll see later on, but getting started is pretty easy. Lithium comes with a set of sensible default routes that help you to get on track immediately.</description>
    </item>
    
    <item>
      <title>Understanding the Inflector</title>
      <link>https://nitschinger.at/Understanding-the-Inflector/</link>
      <pubDate>Thu, 16 Dec 2010 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Understanding-the-Inflector/</guid>
      <description>Introduction The Inflector is one of many utility classes that ship with Lithium out of the box. Those classes are designed to assist you with common tasks that need to be done.
One of those tasks may be to pluralize, singularize, camel-case or humanize strings, database keys or other dynamic content. Let&amp;rsquo;s see how the class itself is described:
 Utility for modifying format of words. Change singular to plural and vice versa.</description>
    </item>
    
    <item>
      <title>Introducing Fixtures for Lithium</title>
      <link>https://nitschinger.at/Introducing-Fixtures-for-Lithium/</link>
      <pubDate>Sat, 04 Dec 2010 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Introducing-Fixtures-for-Lithium/</guid>
      <description>When you write tests for your classes (and you should), you may run into the problem that you create large arrays of test data in your code. Consider the following example:
$expected = array( &#39;post1&#39; =&amp;gt; array( &#39;title&#39; =&amp;gt; &#39;My First Post&#39;, &#39;content&#39; =&amp;gt; &#39;First Content...&#39; ), &#39;post2&#39; =&amp;gt; array( &#39;title&#39; =&amp;gt; &#39;My Second Post&#39;, &#39;content&#39; =&amp;gt; &#39;Also some foobar text&#39; ), &#39;post3&#39; =&amp;gt; array( &#39;title&#39; =&amp;gt; &#39;My Third Post&#39;, &#39;content&#39; =&amp;gt; &#39;I like to write some foobar foo too&#39; ) ); $this-&amp;gt;assertEqual($expected[0], Post::first()); /* more tests down here */  This creates a nested array of test data where each inner array mocks a post stored in the database.</description>
    </item>
    
    <item>
      <title>Write your own Helper with Lithium</title>
      <link>https://nitschinger.at/Write-your-own-Helper-with-Lithium/</link>
      <pubDate>Tue, 23 Nov 2010 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Write-your-own-Helper-with-Lithium/</guid>
      <description>Lithium comes with two helpers out of the box. The Form-Helper and the Html-Helper. Both are great and help you to make your View-Code more flexible, maintainable and easier to read.
But what do you do when you need a functionality that they don&amp;rsquo;t provide? Right, you write your own. Let&amp;rsquo;s imagine you want to tell your blog-readers how many posts you have stored in your database. In our first iteration our code might look like this:</description>
    </item>
    
    <item>
      <title>Add an RSS-Feed to your blog with Lithium</title>
      <link>https://nitschinger.at/Add-an-RSS-Feed-to-your-blog-with-Lithium/</link>
      <pubDate>Sat, 20 Nov 2010 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Add-an-RSS-Feed-to-your-blog-with-Lithium/</guid>
      <description>Adding an RSS-Feed to your blog with li3 is really straightforward, because all the infrastructure you need is already at your fingertips. I assume that you already have some posts stored in your database, you serve them to your users via /posts and the new RSS-File should be accessible via /posts.rss.
First, we need to tell Lithium that we want to add another Media-Type to our application. Add the following to your app/config/bootstrap/media.</description>
    </item>
    
    <item>
      <title>Lithium Routes And MongoDB</title>
      <link>https://nitschinger.at/Lithium-Routes-And-Mongo-DB/</link>
      <pubDate>Fri, 19 Nov 2010 00:00:00 +0000</pubDate>
      
      <guid>https://nitschinger.at/Lithium-Routes-And-Mongo-DB/</guid>
      <description>Lithium comes with a powerful and flexible routing system. However, in its default configuration, you may encounter some problems with MongoDB-ObjectIDs and reverse routing. ObjectIDs are usually the &amp;ldquo;primary keys&amp;rdquo; of your Document in MongoDB, are 12 bytes long and consist of numbers and characters from &amp;lsquo;a&amp;rsquo; to &amp;lsquo;f&amp;rsquo;. A typical ObjectID would look similar to 4ce2d9f99436485e05000000.
If you take a closer look at the default routes that ship with Lithium, you&amp;rsquo;ll maybe notice that the :id part only matches numbers (and not characters).</description>
    </item>
    
  </channel>
</rss>