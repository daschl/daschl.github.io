<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lithium on daschl writes. sometimes.</title>
    <link>http://nitschinger.at/tags/lithium/</link>
    <description>Recent content in Lithium on daschl writes. sometimes.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 03 Mar 2012 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://nitschinger.at/tags/lithium/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Introducing Relationships in Lithium</title>
      <link>http://nitschinger.at/Introducing-Relationships-in-Lithium/</link>
      <pubDate>Sat, 03 Mar 2012 00:00:00 +0000</pubDate>
      
      <guid>http://nitschinger.at/Introducing-Relationships-in-Lithium/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;The model relationship support in Lithium is one of the hottest topics on IRC lately, so I thought it would be a good idea to blog about it.&lt;/p&gt;

&lt;p&gt;Currently, Lithium supports 1:1 and 1:n relationships for relational databases. There is no m:n support out of the box (like CakePHP&amp;rsquo;s &lt;code&gt;$hasAndBelongsToMany&lt;/code&gt;). This also means that MongoDB relationships are not implemented for now. If you look at the &lt;a href=&#34;https://github.com/UnionOfRAD/lithium/wiki/Roadmap&#34;&gt;Roadmap&lt;/a&gt;, you can see that this is on the &amp;ldquo;pre 1.0&amp;rdquo; list and will be addressed before the 1.0 version is released.&lt;/p&gt;

&lt;p&gt;This post gives you a little background on relationship types and their database representations before we implement a simple example in PHP.&lt;/p&gt;

&lt;h1 id=&#34;basics-first&#34;&gt;Basics First&lt;/h1&gt;

&lt;p&gt;If you know how the three &amp;ldquo;big&amp;rdquo; relationship types 1:1, 1:n and m:n are implemented on the database side, feel free to jump straight to the practical example. This is not a exhaustive guide to the relational database model and should only set the stage for the practical example later. Note that I didn&amp;rsquo;t add any foreign key constraints on the database level to make it easier to follow along.&lt;/p&gt;

&lt;p&gt;If you work with a relational data model, and have a (more or less) &lt;a href=&#34;http://en.wikipedia.org/wiki/Database_normalization&#34;&gt;normalized&lt;/a&gt; schema, you need to find a way to model relationships between relations (speak &amp;ldquo;entities&amp;rdquo; or &amp;ldquo;tables&amp;rdquo;). In pratice, these relationships fall into three categories:&lt;/p&gt;

&lt;h2 id=&#34;1-1-relationships&#34;&gt;1:1 Relationships&lt;/h2&gt;

&lt;p&gt;Exactly one entity belongs to exactly one other entity. For example, think of a &lt;code&gt;people&lt;/code&gt; relation and you want to model
the relationship between married people. One husband can only belong to one wife and vice versa (depending from where you are reading this post this might be different ;)). In a physical database schema, it may look like this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; describe people;
+-----------+--------------+------+-----+---------+----------------+
| Field     | Type         | Null | Key | Default | Extra          |
+-----------+--------------+------+-----+---------+----------------+
| id        | int(11)      | NO   | PRI | NULL    | auto_increment |
| name      | varchar(255) | YES  |     | NULL    |                |
| spouse_id | int(11)      | YES  |     | NULL    |                |
+-----------+--------------+------+-----+---------+----------------+
3 rows in set (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;spouse_id&lt;/code&gt; references a different person (note that it is not important if you reference an entity in the same or a different table. Here&amp;rsquo;s some example data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from people;
+----+--------+-----------+
| id | name   | spouse_id |
+----+--------+-----------+
|  1 | Bob    |         2 |
|  2 | Alice  |         1 |
+----+--------+-----------+
4 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Bob&lt;/code&gt; and &lt;code&gt;Alice&lt;/code&gt; are married and their relationship is identified over the foreign key &lt;code&gt;spouse id&lt;/code&gt;. In Lithium, this type of relation is called &lt;code&gt;hasOne&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;1-n-relationships&#34;&gt;1:n Relationships&lt;/h2&gt;

&lt;p&gt;Exactly one entity belongs to zero or more other entites. This is easy: a user can write zero or more blog posts. Let&amp;rsquo;s model this accordingly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; describe posts;
+---------+--------------+------+-----+---------+----------------+
| Field   | Type         | Null | Key | Default | Extra          |
+---------+--------------+------+-----+---------+----------------+
| id      | int(11)      | NO   | PRI | NULL    | auto_increment |
| title   | varchar(255) | NO   |     | NULL    |                |
| user_id | int(11)      | NO   |     | NULL    |                |
+---------+--------------+------+-----+---------+----------------+
3 rows in set (0.01 sec)

mysql&amp;gt; describe users;
+-------+--------------+------+-----+---------+----------------+
| Field | Type         | Null | Key | Default | Extra          |
+-------+--------------+------+-----+---------+----------------+
| id    | int(11)      | NO   | PRI | NULL    | auto_increment |
| name  | varchar(255) | NO   |     | NULL    |                |
+-------+--------------+------+-----+---------+----------------+
2 rows in set (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s some example data to work with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from posts;
+----+--------------+---------+
| id | title        | user_id |
+----+--------------+---------+
|  1 | First post.  |       1 |
|  2 | Second post. |       1 |
+----+--------------+---------+
2 rows in set (0.00 sec)

mysql&amp;gt; select * from users;
+----+-----------+
| id | name      |
+----+-----------+
|  1 | Bob       |
|  2 | Alice     |
+----+-----------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s easy to see that Bob wrote two posts while Alice didn&amp;rsquo;t write a single one. We can look at these relations from two different angles (and can also answer two different questions): &amp;ldquo;What posts did Bob write?&amp;rdquo; and &amp;ldquo;Who is the author of the first post?&amp;rdquo;. To answer both questions
 orrectly, Lithium uses two different relation types for the models: &lt;code&gt;hasMany&lt;/code&gt; and &lt;code&gt;belongsTo&lt;/code&gt;. One user &lt;code&gt;hasMany&lt;/code&gt; blog posts, but one post &lt;code&gt;belongsTo&lt;/code&gt; only one user. The wording also implies where the foreign key is placed: in a &lt;code&gt;hasMany&lt;/code&gt; relationship, the foreign key is expected on the other model, while &lt;code&gt;belongsTo&lt;/code&gt; expects it in the current model. We&amp;rsquo;ll see shortly how this works out in practice.&lt;/p&gt;

&lt;h2 id=&#34;m-n-relationships&#34;&gt;m:n Relationships&lt;/h2&gt;

&lt;p&gt;Lastly, zero or more entities can belong to zero or more other entities. This is a bit tricky, because we need a third table to model this relationship efficiently. For example, a user can belong to zero or more groups and groups can have zero or more members.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; describe users;
+-------+--------------+------+-----+---------+----------------+
| Field | Type         | Null | Key | Default | Extra          |
+-------+--------------+------+-----+---------+----------------+
| id    | int(11)      | NO   | PRI | NULL    | auto_increment |
| name  | varchar(255) | NO   |     | NULL    |                |
+-------+--------------+------+-----+---------+----------------+
2 rows in set (0.02 sec)

mysql&amp;gt; describe groups;
+-------+--------------+------+-----+---------+----------------+
| Field | Type         | Null | Key | Default | Extra          |
+-------+--------------+------+-----+---------+----------------+
| id    | int(11)      | NO   | PRI | NULL    | auto_increment |
| name  | varchar(255) | YES  |     | NULL    |                |
+-------+--------------+------+-----+---------+----------------+
2 rows in set (0.02 sec)

mysql&amp;gt; describe users_groups;
+----------+---------+------+-----+---------+-------+
| Field    | Type    | Null | Key | Default | Extra |
+----------+---------+------+-----+---------+-------+
| group_id | int(11) | NO   |     | NULL    |       |
| user_id  | int(11) | NO   |     | NULL    |       |
+----------+---------+------+-----+---------+-------+
2 rows in set (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that we need a third table to &amp;ldquo;glue&amp;rdquo; the other two together. Here&amp;rsquo;s some example data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from users;
+----+-----------+
| id | name      |
+----+-----------+
|  1 | Alice     |
|  2 | John      |
|  3 | Tom       |
+----+-----------+
3 rows in set (0.00 sec)

mysql&amp;gt; select * from groups;
+----+----------------+
| id | name           |
+----+----------------+
|  1 | Administrators |
|  2 | Support        |
+----+----------------+
2 rows in set (0.00 sec)

mysql&amp;gt; select * from users_groups;
+----------+---------+
| group_id | user_id |
+----------+---------+
|        1 |       1 |
|        1 |       2 |
|        2 |       2 |
+----------+---------+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;John&lt;/code&gt; has access to both groups, while the &lt;code&gt;Administrator&lt;/code&gt; group has two members. Lithium doesn&amp;rsquo;t support this kind of relationship for now, but in CakePHP it is called &lt;code&gt;hasAndBelongsToMany&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;the-blog-example&#34;&gt;The Blog example&lt;/h1&gt;

&lt;p&gt;Now that we&amp;rsquo;ve got the basics settled, let&amp;rsquo;s get our hands on some code and implement the &amp;ldquo;Hello World 2.0&amp;rdquo; example -
a blog. Along the way we can reuse some of the tables above.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume we want to store blog posts and their authors. For simplicity, every author can belong to only one group and a group can only have one member. This way, we can practice 1:n and 1:1 relationships. Let&amp;rsquo;s create the appropriate data model using the MySQL DDL:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE groups (
    id integer auto_increment primary key,
    name varchar(255) not null
);

CREATE TABLE authors (
    id integer auto_increment primary key,
    firstname varchar(255) not null,
    lastname varchar(255) not null,
    group_id integer
);

CREATE TABLE posts (
    id integer auto_increment primary key,
    title varchar(255) not null,
    body text,
    author_id integer
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s insert some demo data to work with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;insert into groups (name) values (&#39;Admins&#39;);
insert into groups (name) values (&#39;Editors&#39;);

insert into authors (firstname, lastname, group_id) values (&#39;Johnnie&#39;, &#39;Walker&#39;, 1);
insert into authors (firstname, lastname, group_id) values (&#39;John&#39;, &#39;Jameson&#39;, 2);
insert into authors (firstname, lastname, group_id) values (&#39;Jack&#39;, &#39;Daniels&#39;, 2);

insert into posts (author_id, title, body) values (1, &#39;On whisky nosing&#39;, &#39;...&#39;);
insert into posts (author_id, title, body) values (2, &#39;Irish on the ROCKS&#39;, &#39;...&#39;);
insert into posts (author_id, title, body) values (2, &#39;Without fear.&#39;, &#39;...&#39;);
insert into posts (author_id, title, body) values (3, &#39;On drinking Bourbon&#39;, &#39;...&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, grab a fresh copy of Lithium and create a connection in &lt;code&gt;config/bootstrap/connections.php&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Connections::add(&#39;default&#39;, array(
    &#39;type&#39; =&amp;gt; &#39;database&#39;,
    &#39;adapter&#39; =&amp;gt; &#39;MySql&#39;,
    &#39;host&#39; =&amp;gt; &#39;localhost&#39;,
    &#39;login&#39; =&amp;gt; &#39;&amp;lt;USER&amp;gt;&#39;,
    &#39;password&#39; =&amp;gt; &#39;&amp;lt;PASSWORD&amp;gt;&#39;,
    &#39;database&#39; =&amp;gt; &#39;&amp;lt;DBNAME&amp;gt;&#39;,
    &#39;encoding&#39; =&amp;gt; &#39;UTF-8&#39;
));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let&amp;rsquo;s create three bare-bone models in &lt;code&gt;app\models&lt;/code&gt; to start with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
// Filename: /app/models/Posts.php
namespace app\models;

class Posts extends \lithium\data\Model {

}
?&amp;gt;

&amp;lt;?php
// Filename: /app/models/Authors.php
namespace app\models;

class Authors extends \lithium\data\Model {

}
?&amp;gt;

&amp;lt;?php
// Filename: /app/models/Groups.php
namespace app\models;

class Groups extends \lithium\data\Model {

}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To produce meaningful output in the browser, we&amp;rsquo;d better add a controller and a view template.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
// Filename: /app/controllers/PostsController.php
namespace app\controllers;

use app\models\Posts;
use app\models\Authors;
use app\models\Groups;

class PostsController extends \lithium\action\Controller {

    public function index() {

    }

}
?&amp;gt;


&amp;lt;!-- Filename: /app/views/posts/index.html.php --&amp;gt;
&amp;lt;h2&amp;gt;All Posts.&amp;lt;/h2&amp;gt;

More stuff will be here soon.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have everything in place, we can define our relationships in Lithium. Place the following snippets in their appropriate models:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Posts:
public $belongsTo = array(&#39;Authors&#39;);

// Authors:
public $hasMany = array(&#39;Posts&#39;);

// Groups:
public $hasOne = array(&#39;Authors&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As our database tables rely on conventional column names, we don&amp;rsquo;t have to provide more configuration params to Lithium. Now, let&amp;rsquo;s read all posts, their corresponding authors and print them in the template.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// PostsController:
public function index() {
    $posts = Posts::all(array(&#39;with&#39; =&amp;gt; &#39;Authors&#39;));
    return compact(&#39;posts&#39;);
}


// index.html.php:
&amp;lt;ul&amp;gt;
    &amp;lt;?php foreach($posts as $post): ?&amp;gt;
        &amp;lt;li&amp;gt;
            &amp;lt;strong&amp;gt;&amp;lt;?= $post-&amp;gt;title; ?&amp;gt;&amp;lt;/strong&amp;gt;, by 
            &amp;lt;?= $post-&amp;gt;author-&amp;gt;firstname; ?&amp;gt; &amp;lt;?= $post-&amp;gt;author-&amp;gt;lastname; ?&amp;gt;
        &amp;lt;/li&amp;gt;
    &amp;lt;?php endforeach; ?&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;with&lt;/code&gt; param controls what relationships you want to fetch. In this case, as a post belongs to one author, Lithium knows that only one &lt;code&gt;Record&lt;/code&gt; is returned and you can use the &lt;code&gt;author&lt;/code&gt; directly. If you don&amp;rsquo;t provide the appropriate class there, Lithium won&amp;rsquo;t call the associated model and an error will be raised (because &lt;code&gt;$post-&amp;gt;author&lt;/code&gt; isn&amp;rsquo;t set, PHP complains that you want to access &lt;code&gt;firstname&lt;/code&gt; from a non-object). This is a common mistake, so keep it in mind!&lt;/p&gt;

&lt;p&gt;Lithium is very flexible on the data layer, and you can write instance methods on your model and access them through the relation. Let&amp;rsquo;s say we want to provide the full name at the model layer, so that we don&amp;rsquo;t have to read both the first- and the lastname in the template.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Authors:
public function fullName($entity) {
    return $entity-&amp;gt;firstname.&amp;quot; &amp;quot;.$entity-&amp;gt;lastname;
}

// index.html.php:
&amp;lt;strong&amp;gt;&amp;lt;?= $post-&amp;gt;title; ?&amp;gt;&amp;lt;/strong&amp;gt;, by &amp;lt;?= $post-&amp;gt;author-&amp;gt;fullName(); ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also read all posts that belong to a particular author:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$posts = Authors::first(array(
    &#39;conditions&#39; =&amp;gt; array(&#39;posts.id&#39; =&amp;gt; $author_id), 
    &#39;with&#39; =&amp;gt; &#39;Posts&#39;
))-&amp;gt;posts;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To find data through our 1:1 relation, we can use the same mechanisms:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Find the author name for a group:
$name = Groups::first(array(
    &#39;conditions&#39; =&amp;gt; array(&#39;groups.id&#39; =&amp;gt; $group_id),
    &#39;with&#39; =&amp;gt; array(&#39;Authors&#39;)
))-&amp;gt;author-&amp;gt;fullName();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that if we want to find the name of the associated group for an author, we would need to add a foreign key to the &lt;code&gt;groups&lt;/code&gt; table (there is no real difference between &lt;code&gt;hasOne&lt;/code&gt; and &lt;code&gt;hasMany&lt;/code&gt;, just the fact that &lt;code&gt;hasOne&lt;/code&gt; returns exactly one entity instead of zero or more and therefore no &lt;code&gt;Collection&lt;/code&gt; is needed).&lt;/p&gt;

&lt;h1 id=&#34;wrapping-up&#34;&gt;Wrapping up&lt;/h1&gt;

&lt;p&gt;This post has covered the basics of model relationships and how to model the 1:1 and 1:n types in Lithium. We now set the stage for more advanced topics, including: form integration, faking the m:n relationship for relational databases, faking relationships for MongoDB and advanced relationship handling through the &lt;code&gt;Relationship&lt;/code&gt; class. If you have any other interesting topics that you want to read about soon, share your ideas!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RFC: li3_fixtures Rewrite</title>
      <link>http://nitschinger.at/RFC-li3_fixtures-Rewrite/</link>
      <pubDate>Fri, 24 Feb 2012 00:00:00 +0000</pubDate>
      
      <guid>http://nitschinger.at/RFC-li3_fixtures-Rewrite/</guid>
      <description>

&lt;p&gt;The &lt;a href=&#34;https://github.com/daschl/li3_fixtures&#34;&gt;li3_fixtures&lt;/a&gt; plugin was my first Lithium plugin ever, and while it works okay, I feel there is a lot I can do to make it better and more flexible. In this post I want to share my ideas for a new fixture plugin and also want to gather feedback from the community to make it even more awesome.&lt;/p&gt;

&lt;p&gt;As far as I can see, there are three big use cases for fixtures:&lt;/p&gt;

&lt;h2 id=&#34;unit-testing-models&#34;&gt;Unit-Testing Models&lt;/h2&gt;

&lt;p&gt;This seems to be the most common use case. To test models effectively, you need a bunch of demo data on which your tests rely on. This data includes both valid and invalid data to test if validations work as expected and how the application can handle large batches of data. The database itself is not mocked, but fixture data is used to populate it before or during the actual tests.&lt;/p&gt;

&lt;p&gt;This can be done without fixtures too, but you need to reinvent the wheel and store your demo data either in external files or directly in your code. When you store it in external files, you need to mess around with file loading and parsing. If you store it directly in your code it gets bloated and makes your code unreadable (and your data is always bound to the test class and can&amp;rsquo;t be reused). To make it as easy as possible, the &lt;code&gt;li3_fixtures&lt;/code&gt; plugin needs to provide the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;centralized storage of fixture data.&lt;/li&gt;
&lt;li&gt;transparent support for various data types (JSON, XML and YAML).&lt;/li&gt;
&lt;li&gt;easy loading of fixture datasets into the database.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mocking-models&#34;&gt;Mocking Models&lt;/h2&gt;

&lt;p&gt;When you test your controllers, you often need to work with data from your models. There are two different scenarios here: you can either write integration tests and populate your real database with data, or mock your models away and work with static data instead of touching the database (for unit-testing controller actions). This allows you to work independently on both layers and improves the performance of your tests.&lt;/p&gt;

&lt;p&gt;Lithium already uses Mocks extensively, so the plugin needs tight integration into them. It should be easy to load fixture data that acts like &amp;ldquo;real&amp;rdquo; data (like iterating over Document/RecordSets).&lt;/p&gt;

&lt;h2 id=&#34;mocking-web-services-and-apis&#34;&gt;Mocking Web-Services and APIs&lt;/h2&gt;

&lt;p&gt;The third use case is not really different from the two mentioned above, but works more with the &lt;code&gt;service&lt;/code&gt; than the the &lt;code&gt;data&lt;/code&gt; layer. As web services are often not inside the boundaries of the developer, the plugin should make it easy to provide demo data for mocks while testing web services.&lt;/p&gt;

&lt;h2 id=&#34;additional-functionality&#34;&gt;Additional Functionality&lt;/h2&gt;

&lt;p&gt;In terms of rapid application development, it would be great to generate fixture data automatically based on patterns or generation rules. There are great libraries like &lt;a href=&#34;https://github.com/fzaninotto/Faker&#34;&gt;Faker&lt;/a&gt; out there, and it would be great to have a feature like this integrated (accessible from the command line). Also, fixture file generation should happen automatically when new models are created from the command line.&lt;/p&gt;

&lt;h2 id=&#34;implementation-documentation&#34;&gt;Implementation &amp;amp; Documentation&lt;/h2&gt;

&lt;p&gt;I want to make extensive use of adapters and strategies, as they make a lot of sense in this context. I think it would be a good idea to use adapters for all input file types (JSON, XML and YAML) and strategies for their representation in the test classes (DocumentSets, RecordSets, Collections or plain arrays). This also makes it trivial to implement custom file types and representations.&lt;/p&gt;

&lt;p&gt;For documentation, I plan to use li3_docs for both the API docs and the actual manual. A current version of the manual will be found as a subdomain on my blog here (of course you&amp;rsquo;ll also have it in your app when you use li3_docs).&lt;/p&gt;

&lt;p&gt;Finally, the plugin will be usable through composer and uses it too to manage external dependencies (I plan to use the Symfony parser for the YAML format).&lt;/p&gt;

&lt;h2 id=&#34;next-steps&#34;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Now it&amp;rsquo;s your turn! Comment below and tell me wheter you like the ideas presented here or not. I&amp;rsquo;m open to every suggestion!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Playing with Composer and Lithium</title>
      <link>http://nitschinger.at/Playing-with-Composer-and-Lithium/</link>
      <pubDate>Mon, 23 Jan 2012 00:00:00 +0000</pubDate>
      
      <guid>http://nitschinger.at/Playing-with-Composer-and-Lithium/</guid>
      <description>

&lt;h2 id=&#34;about-composer&#34;&gt;About Composer&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://packagist.org/about-composer&#34;&gt;Composer&lt;/a&gt; is a command-line tool that helps you manage your application dependencies. It automatically
fetches packages, resolves dependencies and is easy to configure. The really good thing about Composer is that it isn&amp;rsquo;t bound to a specific framework and can be used with every kind of repository. Composer is similar to package managers like npm, so you may feel at home quickly.&lt;/p&gt;

&lt;p&gt;The default repository of Composer is &lt;a href=&#34;http://packagist.org/&#34;&gt;Packagist&lt;/a&gt;. If you want to use Composer in your project, you basically need two things: a &lt;code&gt;composer.json&lt;/code&gt; file in your application root and the &lt;code&gt;composer.phar&lt;/code&gt; application file itself. The easiest way to get it is to download it &lt;a href=&#34;http://getcomposer.org/composer.phar&#34;&gt;directly&lt;/a&gt; and drop it somewhere on your file system. A minimal &lt;code&gt;composer.json&lt;/code&gt; file looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;name&amp;quot;: &amp;quot;my-project&amp;quot;,
    &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
    &amp;quot;require&amp;quot;: {
        &amp;quot;monolog/monolog&amp;quot;: &amp;quot;1.0.0&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As Packagist acts as the default repository, this will fetch the &lt;a href=&#34;http://packagist.org/packages/monolog/monolog&#34;&gt;monolog&lt;/a&gt; library from there into the &lt;code&gt;vendor&lt;/code&gt; directory. There are a lot of configuration options that can be found &lt;a href=&#34;https://raw.github.com/composer/composer/master/doc/composer-schema.json&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s go through a quick example hands-on. Consider the following directory structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/web
    composer.phar
    /my-project
        composer.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you execute the following commands:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd my-project/
$ php path/to/composer.phar install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your directory structure will look like this afterwards:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/web
    composer.phar
    composer.lock
    /my-project
        composer.json
        /vendor
            /bin
            /monolog
                ....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you stick with the defaults, all your dependencies will be installed in the &lt;code&gt;vendor&lt;/code&gt; directory. Lithium uses the &lt;code&gt;libraries&lt;/code&gt; directory to store the dependencies instead, but composer makes it easy to change the default directory (as you&amp;rsquo;ll see shortly). You may also notice that there&amp;rsquo;s a &lt;code&gt;bin&lt;/code&gt; directory, which contains executable files (of course only if the installed  dependencies provide some).&lt;/p&gt;

&lt;p&gt;Composer also creates a &lt;code&gt;composer.lock&lt;/code&gt; file that contains a &amp;ldquo;frozen&amp;rdquo; state of the current dependency tree.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;hash&amp;quot;: &amp;quot;a725fb1bf93f5c534217bbce2897ddc9&amp;quot;,
    &amp;quot;packages&amp;quot;: [
        {
            &amp;quot;package&amp;quot;: &amp;quot;monolog\/monolog&amp;quot;,
            &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;managing-lithium&#34;&gt;Managing Lithium&lt;/h2&gt;

&lt;p&gt;Now that we know how to work with Composer, let&amp;rsquo;s manage a Lithium application with it. Currently, Lithium doesn&amp;rsquo;t provide Composer packages out of the box, but it&amp;rsquo;s easy to write one.&lt;/p&gt;

&lt;p&gt;The first thing you want to do is clone (or download) the &lt;code&gt;framework&lt;/code&gt; repository. You can also use the &lt;code&gt;li3 library extract&lt;/code&gt; command but then you&amp;rsquo;d have to change the &lt;code&gt;LITHIUM_LIBRARY_PATH&lt;/code&gt; back to the default location.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git://github.com/UnionOfRAD/framework.git composer-test
Cloning into composer-test...
remote: Counting objects: 29794, done.
remote: Compressing objects: 100% (8622/8622), done.
remote: Total 29794 (delta 18425), reused 29672 (delta 18332)
Receiving objects: 100% (29794/29794), 3.94 MiB | 1.52 MiB/s, done.
Resolving deltas: 100% (18425/18425), done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, instead of initializing the git submodules (which would fetch the Lithium core the good old way), add this &lt;code&gt;composer.json&lt;/code&gt; file to &lt;code&gt;/composer-test&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;name&amp;quot;: &amp;quot;composer-test&amp;quot;,
    &amp;quot;version&amp;quot;: &amp;quot;0.1.0&amp;quot;,
    &amp;quot;config&amp;quot;: {
        &amp;quot;vendor-dir&amp;quot;: &amp;quot;libraries&amp;quot;
    },


    &amp;quot;repositories&amp;quot;: {
        &amp;quot;UnionOfRAD&amp;quot;: {
            &amp;quot;package&amp;quot;: {
                &amp;quot;name&amp;quot;: &amp;quot;lithium&amp;quot;,
                &amp;quot;version&amp;quot;: &amp;quot;master&amp;quot;,
                &amp;quot;source&amp;quot;: {
                    &amp;quot;url&amp;quot;: &amp;quot;git://github.com/UnionOfRAD/lithium.git&amp;quot;,
                    &amp;quot;type&amp;quot;: &amp;quot;git&amp;quot;,
                    &amp;quot;reference&amp;quot;: &amp;quot;master&amp;quot;
                }
            }
        }
    },

    &amp;quot;require&amp;quot;: {
        &amp;quot;lithium&amp;quot;: &amp;quot;master&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;vendor-dir&lt;/code&gt; setting changes the default &lt;code&gt;vendor&lt;/code&gt; directory to &lt;code&gt;libraries&lt;/code&gt;, which is recognized automatically by the Lithium class loader. If you don&amp;rsquo;t like this approach, you could also change the &lt;code&gt;LITHIUM_LIBRARY_PATH&lt;/code&gt; and point it to the &lt;code&gt;vendor&lt;/code&gt; directory or create a symlink, but we stick with it for now. The &lt;code&gt;repositories&lt;/code&gt; setting
adds the git repository of the lithium core (if Lithium would provide a package on Packagist, then you wouldn&amp;rsquo;t have to do this). The &lt;code&gt;require&lt;/code&gt; setting is where all your application dependencies go into. The key &lt;code&gt;lithium&lt;/code&gt; here refers to the package name in the &lt;code&gt;repositories&lt;/code&gt; setting above.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s install the dependencies:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ php path/to/composer.phar install
Installing dependencies
Writing lock file
Generating autoload files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you look into the &lt;code&gt;/composer-test/libraries&lt;/code&gt; directory, you can see that the &lt;code&gt;lithium&lt;/code&gt; directory has been added successfully.&lt;/p&gt;

&lt;p&gt;If we now want to install &lt;a href=&#34;http://twig.sensiolabs.org/&#34;&gt;twig&lt;/a&gt;, we can modify our &lt;code&gt;composer.json&lt;/code&gt; file accordingly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;require&amp;quot;: {
    &amp;quot;lithium&amp;quot;: &amp;quot;master&amp;quot;,
    &amp;quot;twig/extensions&amp;quot;: &amp;quot;master-dev&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not that the twig library is already available on Packagist, so we don&amp;rsquo;t have to tell Composer where to find it. We can now run &lt;code&gt;composer.phar update&lt;/code&gt; to update our dependencies (and the &lt;code&gt;composer.lock&lt;/code&gt; file):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ php ../composer.phar update
Updating dependencies
- Package twig/twig (1.6.0-dev)
    Downloading
    Unpacking archive
    Cleaning up

- Package twig/extensions (master-dev)
    Downloading
    Unpacking archive
    Cleaning up

Writing lock file
Generating autoload files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, Composer has automatically downloaded all dependencies needed by &lt;code&gt;twig/extensions&lt;/code&gt; too!&lt;/p&gt;

&lt;p&gt;You can now start managing your dependencies through composer, regardless if they actually provide composer packages or not. There is an &lt;a href=&#34;https://github.com/UnionOfRAD/lithium/issues/285&#34;&gt;ongoing discussion&lt;/a&gt; on how Lithium will handle dependency management in the future, so stay tuned.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Session Encryption with Lithium</title>
      <link>http://nitschinger.at/Session-Encryption-with-Lithium/</link>
      <pubDate>Fri, 20 Jan 2012 00:00:00 +0000</pubDate>
      
      <guid>http://nitschinger.at/Session-Encryption-with-Lithium/</guid>
      <description>

&lt;h2 id=&#34;the-basics&#34;&gt;The Basics&lt;/h2&gt;

&lt;p&gt;If you check out the &lt;code&gt;master&lt;/code&gt; branch, you can use the new &lt;code&gt;Encrypt&lt;/code&gt; strategy to encrypt your session data automatically. This means that you can read and write session data in cleartext and they will be encrypted on the fly before getting stored (in a cookie, for example). You can read my post about &amp;ldquo;baking cookies like a chef&amp;rdquo; for  PHPAdvent 2011 &lt;a href=&#34;http://phpadvent.org/2011/bake-cookies-like-a-chef-by-michael-nitschinger&#34;&gt;here&lt;/a&gt;. The article covers both HMAC signatures and encryption, and is a good place to start. This post will go a little bit deeper in how to use and configure the &lt;code&gt;Encrypt&lt;/code&gt; strategy in Lithium. Note that you need to have the &lt;a href=&#34;http://php.net/manual/en/book.mcrypt.php&#34;&gt;mcrypt&lt;/a&gt; extension installed and enabled for this to work.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the simplest configuration you can start with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Session::config(array(&#39;default&#39; =&amp;gt; array(
    &#39;adapter&#39; =&amp;gt; &#39;Cookie&#39;,
    &#39;strategies&#39; =&amp;gt; array(&#39;Encrypt&#39; =&amp;gt; array(&#39;secret&#39; =&amp;gt; &#39;f00bar$l1thium&#39;))
)));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will store all your session data in a cookie. If you don&amp;rsquo;t change anything else, your data will be encrypted with &lt;a href=&#34;http://en.wikipedia.org/wiki/Advanced_Encryption_Standard&#34;&gt;AES&lt;/a&gt; in  &lt;a href=&#34;http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29&#34;&gt;CBC&lt;/a&gt; mode with a block size of 256 bits (32 byte). This is a secure and sensible default, so if you don&amp;rsquo;t need anything special just stick with the defaults.&lt;/p&gt;

&lt;p&gt;You can now read and write cleartext data and it will be encrypted on the fly for you. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Session::write(&#39;key&#39;, &#39;my secret value&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result will look like this on the client side:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;appcookie[__encrypted]=c3Rqv%2FFYnuwAevxeseII7lOvyoOTi2foMfB%2FCoO4l4FcutRvBn7qq%2BZrPVWC%2FzEYEiSSFMWv7EhEx4ew99%2FmPQ%3D%3D
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can then read the value again with &lt;code&gt;Session::read(&#39;key&#39;);&lt;/code&gt; or delete it with &lt;code&gt;Session::delete(&#39;key&#39;);&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it. If you don&amp;rsquo;t want to dig into the internals, you can safely stop reading now and implement it in your own application.&lt;/p&gt;

&lt;h2 id=&#34;further-discussion&#34;&gt;Further Discussion&lt;/h2&gt;

&lt;p&gt;Still here? Awesome!&lt;/p&gt;

&lt;p&gt;While the &lt;code&gt;mcrypt&lt;/code&gt; extension does the heavy lifting for us, the &lt;code&gt;Encrypt&lt;/code&gt; strategy abstracts necessary cruft like vector generation, key strengthening and resource management. While this is okay for most parts of the framework, in my opinion, when it comes to security, you should have a good understanding what is going on under the hood. Code ist not perfect, and it may contain semantical or design flaws that put your whole application (and customers) to risk. Also, security standards shift over time and what is now secure may not be in a few months.&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t override the default settings, Lithium encrypts your data with the &lt;code&gt;MCRYPT_RIJNDAEL_128&lt;/code&gt; cipher in &lt;code&gt;MCRYPT_MODE_CBC&lt;/code&gt; mode. What
most developers get wrong is the fact that the &lt;code&gt;128&lt;/code&gt; doesn&amp;rsquo;t represent the strength of the key size, but the block size that is used. Strictly
speaking, &lt;code&gt;MCRYPT_RIJNDAEL_256&lt;/code&gt; is not part of the AES standard (because AES has a fixed block size of 128 bits and a key size of 128, 192 or 256 bits). The key size is determined by the length of the key that you pass to the &lt;code&gt;mcrypt&lt;/code&gt; extension.&lt;/p&gt;

&lt;p&gt;So to make sure we use the longest key possible, we hash the given secret with &lt;code&gt;sha256&lt;/code&gt; and then substring the length we need. As &lt;code&gt;mcrypt&lt;/code&gt; tells us which key lengths are supported for which cipher (through &lt;a href=&#34;http://php.net/manual/en/function.mcrypt-enc-get-key-size.php&#34;&gt;mcrypt_enc_get_key_size&lt;/a&gt;), it is possible to determine the strongest key length. Note that this doesn&amp;rsquo;t mean that you should use weak keys in the first place just because they get hashed anyway. In practice, you will only create them once so make sure they contain enough entropy.&lt;/p&gt;

&lt;p&gt;As always, the Lithium core provides sensible defaults but also lets you outgrow the framework if you need to. You can specify your own cipher or mode like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Session::config(array(&#39;default&#39; =&amp;gt; array(
    &#39;adapter&#39; =&amp;gt; &#39;Cookie&#39;,
    &#39;strategies&#39; =&amp;gt; array(&#39;Encrypt&#39; =&amp;gt; array(
        &#39;cipher&#39; =&amp;gt; MCRYPT_RIJNDAEL_256,
        &#39;mode&#39;   =&amp;gt; MCRYPT_MODE_ECB, // Don&#39;t use ECB when you don&#39;t have to!
        &#39;secret&#39;     =&amp;gt; &#39;f00bar$l1thium&#39;
    ))
)));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s a list of &lt;a href=&#34;http://www.php.net/manual/en/mcrypt.ciphers.php&#34;&gt;ciphers&lt;/a&gt; and &lt;a href=&#34;http://www.php.net/manual/en/mcrypt.constants.php&#34;&gt;modes&lt;/a&gt; you can use. Of course you need to make sure that your custom cipher/mode combination is supported.&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t like how Lithium hashes your key or if you want to has it on your own, there&amp;rsquo;s also a way to do this. If the length of your key is equal or longer than the longest key size supported by the algorithm, it gets passed through unchanged. Here&amp;rsquo;s how it works:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected function _hashSecret($key) {
    $size = mcrypt_enc_get_key_size(static::$_resource);

    if (strlen($key) &amp;gt;= $size) {
        return $key;
    }

    return substr(hash(&#39;sha256&#39;, $key, true), 0, $size);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In my opinion, you should always encrypt your data if it gets stored on the client side. Lithium provides a convenient and transparent way to do it, so go ahead and use it in your own applications to make them more secure.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quick Tip: Lithium Redirect</title>
      <link>http://nitschinger.at/Quick-Tip-Lithium-Redirect/</link>
      <pubDate>Fri, 16 Sep 2011 00:00:00 +0000</pubDate>
      
      <guid>http://nitschinger.at/Quick-Tip-Lithium-Redirect/</guid>
      <description>&lt;p&gt;While migrating &lt;a href=&#34;https://github.com/UnionOfRAD/lithium_bin&#34;&gt;lithium_bin&lt;/a&gt; as part of research over to MongoDB (from CouchDB), I found the following snippet in the &lt;code&gt;routes.php&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Router::connect(&#39;/&#39;, array(), function($request) {
    $location = array(&#39;controller&#39; =&amp;gt; &#39;pastes&#39;, &#39;action&#39; =&amp;gt; &#39;add&#39;);
    return new Response(compact(&#39;location&#39;));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This means that when the user enters the application via the root url (&lt;code&gt;/&lt;/code&gt;), he instantly gets redirected to &lt;code&gt;/pastes/add&lt;/code&gt; (or a different URL if you have custom routes configured).&lt;/p&gt;

&lt;p&gt;This may seem ok at first, but there&amp;rsquo;s a problem. It doesn&amp;rsquo;t take URLs into account that don&amp;rsquo;t live directly under the document root. So if your application lives under &lt;code&gt;http://localhost/pastium/&lt;/code&gt;, it will redirect you to &lt;code&gt;http://localhost/pastes/add/&lt;/code&gt; which is not really what you want. Instead, do it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Router::connect(&#39;/&#39;, array(), function($request) {
    $location = Router::match(&#39;Pastes::add&#39;, $request);
    return new Response(compact(&#39;location&#39;));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this snippet, the &lt;code&gt;Router&lt;/code&gt; takes the current &lt;code&gt;Request&lt;/code&gt; into account and returns the correct location (based on the reverse routing information). Now it should redirect you correctly to &lt;code&gt;http://localhost/pastium/pastes/add/&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;By the way, this is extracted from the &lt;code&gt;Controller::redirect&lt;/code&gt; method, which is implemented in a similar way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function redirect($url, array $options = array()) {
    //...
    $this-&amp;gt;_filter(__METHOD__, $params, function($self, $params) use ($router) {
        $options = $params[&#39;options&#39;];
        $location = $options[&#39;location&#39;] ?: $router::match($params[&#39;url&#39;], $self-&amp;gt;request);
        $self-&amp;gt;render(compact(&#39;location&#39;) + $options);
    });
    //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you have any ideas on how to improve this further, feel free to comment below!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Letters from Lithium #2</title>
      <link>http://nitschinger.at/Letters-from-Lithium-2/</link>
      <pubDate>Mon, 05 Sep 2011 00:00:00 +0000</pubDate>
      
      <guid>http://nitschinger.at/Letters-from-Lithium-2/</guid>
      <description>

&lt;h2 id=&#34;about&#34;&gt;About&lt;/h2&gt;

&lt;p&gt;Letters from Lithium keeps you up to date about what happens in the Lithium core and community. If you have interesting news to share, comment below or ping me on &lt;a href=&#34;http://twitter.com/daschl&#34;&gt;twitter&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;core-news&#34;&gt;Core News&lt;/h2&gt;

&lt;p&gt;Routing got a bit more awesome with &lt;a href=&#34;https://github.com/UnionOfRAD/lithium/commit/792b916249052b87c368e2e25798a93dceaa0154#L3R636&#34;&gt;route continuations&lt;/a&gt;. They allow you match more routes in one request, which is very useful in many cases. Take a look at this test case:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
* Tests that continuation routes properly fall through and aggregate multiple route parameters.
*/
public function testRouteContinuations() {
    Router::connect(&#39;/{:locale:en|de|it|jp}/{:args}&#39;, array(), array(&#39;continue&#39; =&amp;gt; true));
    Router::connect(&#39;/{:controller}/{:action}/{:id:[0-9]+}&#39;);

    $request = new Request(array(&#39;url&#39; =&amp;gt; &#39;/en/posts/view/1138&#39;));
    $result = Router::process($request)-&amp;gt;params;
    $expected = array (
        &#39;controller&#39; =&amp;gt; &#39;posts&#39;, &#39;action&#39; =&amp;gt; &#39;view&#39;, &#39;id&#39; =&amp;gt; &#39;1138&#39;, &#39;locale&#39; =&amp;gt; &#39;en&#39;
    );
    $this-&amp;gt;assertEqual($expected, $result);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The data branch has been &lt;a href=&#34;https://github.com/UnionOfRAD/lithium/commit/107f596b3224b47cfe91a820bae5867a5e0aee6c&#34;&gt;merged&lt;/a&gt; recently, which should improve the overall stability of the model layer and add a few smaller features. Thanks to &lt;a href=&#34;https://github.com/vesln&#34;&gt;Veselin Todorov&lt;/a&gt;, you &lt;a href=&#34;https://github.com/UnionOfRAD/lithium/commit/0c35bef1a36f3ffd6baee3586bf8c3380dfabb81&#34;&gt;can now use&lt;/a&gt; the &amp;ldquo;last&amp;rdquo; option in validations. This lets you better control the validation stack.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mackstar&#34;&gt;Richard McIntyre&lt;/a&gt; added &lt;a href=&#34;https://github.com/UnionOfRAD/lithium/commit/427ee643e0725cceb42d6f1ee66cf5668d18effa&#34;&gt;console environment detection&lt;/a&gt; and Nate Abele improved the application detection process.&lt;/p&gt;

&lt;p&gt;Of course, various other bugs have been fixed (including the &lt;a href=&#34;https://github.com/UnionOfRAD/lithium/commit/cbd0c4d2c07837e2e5ea4f9e8ff8c6a0d1fa1c61&#34;&gt;HMAC bug&lt;/a&gt;) and small enhancements like &lt;a href=&#34;https://github.com/UnionOfRAD/lithium/commit/74514b870c13aac98236111c524ab5c1bc04656f&#34;&gt;collection sorting&lt;/a&gt; and &lt;a href=&#34;https://github.com/UnionOfRAD/lithium/commit/c0d4ff82b1b3bb662ed0e78ed9599437306ca068&#34;&gt;Form::error() filtering&lt;/a&gt; found their way into the core.&lt;/p&gt;

&lt;h2 id=&#34;plugins&#34;&gt;Plugins&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/eLod&#34;&gt;eLod&lt;/a&gt; (also known as &amp;ldquo;smoking_kiddo&amp;rdquo; on IRC) created a plugin called &lt;a href=&#34;https://github.com/eLod/li3_console&#34;&gt;li3_console&lt;/a&gt; which provides a fully functional PHP &lt;a href=&#34;http://en.wikipedia.org/wiki/Read-eval-print_loop&#34;&gt;REPL&lt;/a&gt; and also lets you interact with your Lithium environment (like models) from the command line.&lt;/p&gt;

&lt;p&gt;If you need to deploy your Lithium application to remote servers and are used to &lt;a href=&#34;https://github.com/capistrano/capistrano&#34;&gt;Capistrano&lt;/a&gt;, you should take a look at &lt;a href=&#34;https://github.com/mehlah/capium&#34;&gt;capium&lt;/a&gt;. It is a ruby gem that provides deploy recipes and rake tasks for Lithium.&lt;/p&gt;

&lt;h2 id=&#34;blogs-and-media&#34;&gt;Blogs and Media&lt;/h2&gt;

&lt;p&gt;For those new to Lithium, &lt;a href=&#34;http://www.davidgolding.net/&#34;&gt;David Golding&lt;/a&gt; recently published a very informative introduction &lt;a href=&#34;http://www.scribd.com/doc/62146078/New-to-Lithium-Part-1&#34;&gt;here&lt;/a&gt;. It gets you up and running quickly and walks you through the creation of models, controllers and views.&lt;/p&gt;

&lt;p&gt;Also, &lt;a href=&#34;http://www.jblotus.com/&#34;&gt;James Fuller&lt;/a&gt; released a few blog posts in the last weeks, covering various topics around Lithium. Head over to his blog and read about &lt;a href=&#34;http://www.jblotus.com/2011/08/17/adding-a-session-flash-message-to-your-site-in-lithium-php/&#34;&gt;Flash Messages&lt;/a&gt;, the &lt;a href=&#34;http://www.jblotus.com/2011/08/19/how-to-add-a-html-button-element-using-lithium-phps-formhelper/&#34;&gt;FormHelper&lt;/a&gt;, &lt;a href=&#34;http://www.jblotus.com/2011/08/20/super-simple-lithium-php-json-web-service-calls/&#34;&gt;Web Service Calls&lt;/a&gt;, &lt;a href=&#34;http://www.jblotus.com/2011/08/27/understanding-filters-in-lithium-php/&#34;&gt;Filters&lt;/a&gt; and &lt;a href=&#34;http://www.jblotus.com/2011/08/31/using-an-appcontroller-in-lithium-php-to-pass-data-to-the-layout/&#34;&gt;AppControllers&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;universe&#34;&gt;Universe&lt;/h2&gt;

&lt;p&gt;Recently, &lt;a href=&#34;http://www.engineyard.com/&#34;&gt;Engine Yard&lt;/a&gt; (mostly known for their knowledge and cloud platforms in the Ruby on Rails world) acquired &lt;a href=&#34;http://orchestra.io&#34;&gt;Orchestra&lt;/a&gt; to extend their language support. Orchestra is a great platform to deploy your PHP and Lithium applications on to, so give it a try (they also provide free accounts) if you haven&amp;rsquo;t already. The &lt;a href=&#34;http://lithify.me/docs/manual/cloud/readme.wiki&#34;&gt;manual&lt;/a&gt; also provides a short guide if you need help.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Ciaro&#34;&gt;Ciaro Vermeire&lt;/a&gt; started a (unofficial) community forum for Lithium, which you can find &lt;a href=&#34;http://lithium-framework.com/&#34;&gt;here&lt;/a&gt;. If you like this type of communication, feel free to register, ask for help and - most importantly - share what you know.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Letters from Lithium #1</title>
      <link>http://nitschinger.at/Letters-from-Lithium-1/</link>
      <pubDate>Tue, 02 Aug 2011 00:00:00 +0000</pubDate>
      
      <guid>http://nitschinger.at/Letters-from-Lithium-1/</guid>
      <description>

&lt;h2 id=&#34;about&#34;&gt;About&lt;/h2&gt;

&lt;p&gt;&amp;ldquo;Letters from Lithium&amp;rdquo; will be published on a regular basis to give you an update on what happens in the Lithium community. If you have interesting topics/plugins/stuff you want to read about, feel free to contact me through twitter or email.&lt;/p&gt;

&lt;h2 id=&#34;core-news&#34;&gt;Core News&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/UnionOfRAD/lithium/wiki/Roadmap&#34;&gt;Roadmap&lt;/a&gt; to 1.0 is going pretty well so far, and relationship support for relational databases has been already merged into master. For the impatient, there is also some documentation for it underway which can be found &lt;a href=&#34;https://github.com/UnionOfRAD/manual/blob/master/en/working-with-data/relationships.wiki&#34;&gt;here&lt;/a&gt;. As the docs are not finished yet, you&amp;rsquo;ll have to clone the repository locally to view them in their full glory (don&amp;rsquo;t forget to clone &lt;code&gt;li3_docs&lt;/code&gt; too). The core team is also working on relationship support for MongoDB, which will also ship before 1.0. For those who come from CakePHP: there won&amp;rsquo;t be a &lt;code&gt;hasAndBelongsToMany&lt;/code&gt; relationship, because we&amp;rsquo;ll add support for nested relationships which can be used to achieve the same result in a better and cleaner way.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re very excited to see more and more people contributing code to the core. &lt;a href=&#34;https://github.com/doobry&#34;&gt;Chris Beswick&lt;/a&gt; did an awesome job recently and refactored a significant part of the routing system (&lt;a href=&#34;https://github.com/UnionOfRAD/lithium/commits/master?author=doobry&#34;&gt;commits&lt;/a&gt;) which makes compiling routes significantly faster. Also there&amp;rsquo;s a huge &lt;a href=&#34;https://github.com/UnionOfRAD/lithium/pull/45&#34;&gt;pull request&lt;/a&gt; open that brings &lt;a href=&#34;http://www.postgresql.org/&#34;&gt;PostgreSQL&lt;/a&gt; integration to the Lithium core.&lt;/p&gt;

&lt;p&gt;Lithium wants to be a first-class citizen on Windows, so there&amp;rsquo;s a &lt;a href=&#34;https://github.com/UnionOfRAD/lithium/tree/windows&#34;&gt;branch&lt;/a&gt; open that tries to track, find and fix all bugs and test-cases on Windows. If you&amp;rsquo;re developing on Windows and have some spare time, contact one of the core members on IRC and we&amp;rsquo;ll get you started. We aim to make all test cases run on Windows before the 1.0 release.&lt;/p&gt;

&lt;h2 id=&#34;plugins&#34;&gt;Plugins&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve recently &lt;a href=&#34;http://nitschinger.at/Lithium-plugin-roundup&#34;&gt;compiled a list of plugins&lt;/a&gt; and readers also posted their additions in the comments below. There are plans to bring the &lt;a href=&#34;http://lab.lithify.me&#34;&gt;Lithium Lab&lt;/a&gt; up to date and integrate it even better with the Lithium framework so in the future you should be able to install and share plugins right from there. I&amp;rsquo;ll cover this in greater detail in one of the next letters.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/alkemann&#34;&gt;Alexander Morland&lt;/a&gt; is developing a &lt;a href=&#34;https://github.com/alkemann/li3_zmq&#34;&gt;plugin&lt;/a&gt; for &lt;a href=&#34;http://www.zeromq.org/&#34;&gt;ZeroMQ&lt;/a&gt; and is always searching for feedback and contributions. If you need message passing in your application (like queues or pub/sub), then you should definitely check it out.&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t know which plugins are available, try &lt;a href=&#34;https://github.com/search?langOverride=&amp;amp;language=PHP&amp;amp;q=li3_&amp;amp;repo=&amp;amp;start_value=1&amp;amp;type=Repositories&amp;amp;x=32&amp;amp;y=21&#34;&gt;this&lt;/a&gt; search on Github!&lt;/p&gt;

&lt;h2 id=&#34;blogs-media&#34;&gt;Blogs &amp;amp; Media&lt;/h2&gt;

&lt;p&gt;For those who don&amp;rsquo;t know yet, &lt;a href=&#34;http://raymondjulin.com/&#34;&gt;Raymond Julin&lt;/a&gt; did compile a list of useful resources back in January which can be found &lt;a href=&#34;http://blog.raymondjulin.com/2011/01/06/list-of-useful-lithium-li3-resources/&#34;&gt;here&lt;/a&gt;. In addition to that, &lt;a href=&#34;http://www.shift8creative.com/about&#34;&gt;Tom Maiaroto&lt;/a&gt; wrote a &lt;a href=&#34;http://www.shift8creative.com/blog/getting-started-with-minerva&#34;&gt;blog post&lt;/a&gt; that helps you to get up and running with &lt;a href=&#34;https://github.com/tmaiaroto/minerva&#34;&gt;Minerva&lt;/a&gt;, his CMS based on Lithium.&lt;/p&gt;

&lt;p&gt;Lithium now has &lt;a href=&#34;http://vimeo.com/channels/li3&#34;&gt;Vimeo Channel&lt;/a&gt; which also contains the &lt;a href=&#34;http://vimeo.com/26183322&#34;&gt;Introducing Lithium&lt;/a&gt; talk by Nate. You should definitely check that out if you&amp;rsquo;re new to Lithium and need a one-hour introduction.&lt;/p&gt;

&lt;h2 id=&#34;universe&#34;&gt;Universe&lt;/h2&gt;

&lt;p&gt;As a side note, the &lt;a href=&#34;http://www.union-of-rad.com/&#34;&gt;UnionOfRAD&lt;/a&gt; is looking for client work (preferrably in the NY area), so if you need talented developers that know Lithium and its surroundings from the inside out please contact &lt;a href=&#34;http://www.nateabele.com&#34;&gt;Nate Abele&lt;/a&gt; on &lt;a href=&#34;http://www.twitter.com/nateabele&#34;&gt;twitter&lt;/a&gt; or IRC.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using Environments in Lithium</title>
      <link>http://nitschinger.at/Using-Environments-in-Lithium/</link>
      <pubDate>Tue, 19 Jul 2011 00:00:00 +0000</pubDate>
      
      <guid>http://nitschinger.at/Using-Environments-in-Lithium/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Environments help you to manage multiple configurations for your application. Maybe you have a different database for testing than for production or you use file caching in development but &lt;a href=&#34;http://www.php.net/manual/en/intro.apc.php&#34;&gt;APC&lt;/a&gt; in production. If your framework does not support this (or a similar) concept, it can be a pain to code this overhead for yourself. Therefore, Lithium frees you from this by providing a &lt;code&gt;Environment&lt;/code&gt; class (in the &lt;code&gt;\lithium\core&lt;/code&gt; namespace) which handles everything for you automatically. Other concepts like &lt;code&gt;adapters&lt;/code&gt; integrate with your environments and give you a high flexibility while maintaining a set of sensible defaults.&lt;/p&gt;

&lt;p&gt;The next chapter is a whirlwind tour on how to use environments in many places in the framework. Once you know how to work with them, we&amp;rsquo;ll see how you can change the behavior and adapt it further to the needs of your application.&lt;/p&gt;

&lt;h2 id=&#34;using-environments&#34;&gt;Using environments&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s start with the most common use case of environments: define a separate database connection for &lt;code&gt;development&lt;/code&gt;, &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;production&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Connections::add(&#39;default&#39;, array(
    &#39;development&#39; =&amp;gt; array(
        &#39;type&#39; =&amp;gt; &#39;MongoDb&#39;,
        &#39;host&#39; =&amp;gt; &#39;localhost&#39;,
        &#39;database&#39; =&amp;gt; &#39;blog_dev&#39;
    ), 
    &#39;test&#39; =&amp;gt; array(
        &#39;type&#39; =&amp;gt; &#39;MongoDb&#39;,
        &#39;host&#39; =&amp;gt; &#39;localhost&#39;,
        &#39;database&#39; =&amp;gt; &#39;blog_test&#39;
    ),
    &#39;production&#39; =&amp;gt; array(
        &#39;type&#39; =&amp;gt; &#39;MongoDb&#39;,
        &#39;host&#39; =&amp;gt; &#39;localhost&#39;,
        &#39;database&#39; =&amp;gt; &#39;blog_prod&#39;
    )
));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, we don&amp;rsquo;t work with the &lt;code&gt;Environment&lt;/code&gt; class here directly. Instead, the &lt;code&gt;Adaptable&lt;/code&gt; class (from which the &lt;code&gt;Connections&lt;/code&gt; class derives) takes care for us. To understand what&amp;rsquo;s going on, investigate &lt;code&gt;_config()&lt;/code&gt; method inside the &lt;code&gt;Adaptable&lt;/code&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Gets an array of settings for the given named configuration in the current
 * environment.
 *
 * The default types of settings for all adapters will contain keys for:
 * `adapter` - The class name of the adapter
 * `filters` - An array of filters to be applied to the adapter methods
 *
 * @see lithium\core\Environment
 * @param string $name Named configuration.
 * @return array Settings for the named configuration.
 */
protected static function _config($name) {
    //...
    $env = Environment::get();
    $config = isset($settings[$env]) ? $settings[$env] : $settings;
    //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The important part is done in the middle of the method. The &lt;code&gt;Environment::get()&lt;/code&gt; method is called and based on the result it either uses the appropriate environment configuration or uses the whole array. This means that you are free to use environments or not.&lt;/p&gt;

&lt;p&gt;You can use the &lt;code&gt;Environment::get()&lt;/code&gt; method for yourself to check out the current environment.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use lithium\core\Environment;
echo Environment::get();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For most of you, this will return &lt;code&gt;development&lt;/code&gt; (if not, the next chapter will show you why). In addition to the &lt;code&gt;get()&lt;/code&gt; method, there is also the &lt;code&gt;is()&lt;/code&gt; method. This method takes a string as the param and returns either true or false if the environment matches your string. There are a lot of use cases for this, one can be found in your &lt;code&gt;routes.php&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
* Test routes.
*/
if (!Environment::is(&#39;production&#39;)) {
    Router::connect(&#39;/test/{:args}&#39;, array(&#39;controller&#39; =&amp;gt; &#39;lithium\test\Controller&#39;));
    Router::connect(&#39;/test&#39;, array(&#39;controller&#39; =&amp;gt; &#39;lithium\test\Controller&#39;));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code snippet only includes the &lt;code&gt;test&lt;/code&gt; routes if you&amp;rsquo;re not running a production setup. Here&amp;rsquo;s another one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(Environment::is(&#39;development&#39;)) {
    Libraries::add(&#39;li3_docs&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This only includes the &lt;code&gt;li3_docs&lt;/code&gt; library during development, because you generally won&amp;rsquo;t need it in production or testing. And the last one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$default = array(&#39;adapter&#39; =&amp;gt; &#39;File&#39;, &#39;strategies&#39; =&amp;gt; array(&#39;Serializer&#39;));

if ($apcEnabled &amp;amp;&amp;amp; Environment::is(&#39;production&#39;)) {
    $default = array(&#39;adapter&#39; =&amp;gt; &#39;Apc&#39;);
}
Cache::config(compact(&#39;default&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This snippet tells Lithium to use file caching in development and APC for production (this is a modified version of the code you can find by default in &lt;code&gt;app/config/cache.php&lt;/code&gt;). I won&amp;rsquo;t give another example here, I think you get the point.&lt;/p&gt;

&lt;h2 id=&#34;advanced-usage&#34;&gt;Advanced usage&lt;/h2&gt;

&lt;p&gt;Now that we know how to use environments, let&amp;rsquo;s see how we can tailor them to our needs. Most of the time you have either different environments or the default detection mechanism doesn&amp;rsquo;t work as expected.&lt;/p&gt;

&lt;p&gt;Before we start to modify the environment detection mechanism, we should look at how it is implemented by default:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected static function _detector() {
    return static::$_detector ?: function($request) {
        switch (true) {
            case (in_array($request-&amp;gt;env(&#39;SERVER_ADDR&#39;), array(&#39;::1&#39;, &#39;127.0.0.1&#39;))):
                return &#39;development&#39;;
            case (preg_match(&#39;/^test/&#39;, $request-&amp;gt;env(&#39;HTTP_HOST&#39;))):
                return &#39;test&#39;;
            default:
                return &#39;production&#39;;
        }
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that if the server address is &amp;ldquo;127.0.0.1&amp;rdquo; (which basically means you&amp;rsquo;re running on localhost) then the environment defaults to &amp;ldquo;devlopment&amp;rdquo;. If this isn&amp;rsquo;t the case, it tries to find &lt;code&gt;test&lt;/code&gt; in the &lt;code&gt;HTTP_HOST&lt;/code&gt; settings. This is also used by the testing framework so you may want to keep this as it is. If none of these checks match, you&amp;rsquo;re running in production mode.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say we want to add a &lt;code&gt;staging&lt;/code&gt; environment which is identified by its ip address &lt;code&gt;192.168.100.22&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use lithium\core\Environment;
Environment::is(function($request) {
    switch (true) {
        case (in_array($request-&amp;gt;env(&#39;SERVER_ADDR&#39;), array(&#39;::1&#39;, &#39;127.0.0.1&#39;))):
            return &#39;development&#39;;
        case ($request-&amp;gt;env(&#39;SERVER_ADDR&#39;) == &#39;192.168.100.22&#39;):
            return &#39;staging&#39;;
        case (preg_match(&#39;/^test/&#39;, $request-&amp;gt;env(&#39;HTTP_HOST&#39;))):
            return &#39;test&#39;;
        default:
            return &#39;production&#39;;
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Easy enough, so here&amp;rsquo;s a final example: assume we don&amp;rsquo;t want to rely on this detection mechanisms. Instead, we set the &lt;code&gt;LITHIUM_ENVIRONMENT&lt;/code&gt; variable in our apache config (maybe through &lt;code&gt;SetEnv LITHIUM_ENVIRONMENT &amp;quot;development&amp;quot;&lt;/code&gt;) and use it in our application. If no config variable is set, let&amp;rsquo;s default to &lt;code&gt;development&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use lithium\core\Environment;
Environment::is(function($request) {
    return $request-&amp;gt;env(&#39;lithium_environment&#39;) ?: &#39;development&#39;;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, you have to make sure that your custom environment routines get executed before the dependent parts get bootstrapped. You can either put it at the bottom of &lt;code&gt;app/config/boostrap/libraries.php&lt;/code&gt; or add a new config file that gets loaded afterwards.&lt;/p&gt;

&lt;h2 id=&#34;wrapping-up&#34;&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;After reading this post you should have a basic idea on how environments work in Lithium, how to use them and also how to tailor them to your needs. Keep in mind that they are also reused in other classes and patterns like &lt;code&gt;Adaptable&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Testing the Lithium core for fun and profit</title>
      <link>http://nitschinger.at/Testing-the-Lithium-core-for-fun-and-profit/</link>
      <pubDate>Sat, 09 Jul 2011 00:00:00 +0000</pubDate>
      
      <guid>http://nitschinger.at/Testing-the-Lithium-core-for-fun-and-profit/</guid>
      <description>

&lt;p&gt;In modern web frameworks, testing is one of the most important pillars that ensure a clean, stable and extendable codebase. Testing support in Lithium was built in from the beginning and therefore it already features a great code coverage. The Lithium project aims to work out of the box on many platforms, including Microsoft Windows and its IIS, which was often neglected in the past.&lt;/p&gt;

&lt;p&gt;The main purpose of this post is to show you how core tests work and were the core team needs help to improve things further. At the end of this post you should be able to write new and extend existing test cases. A side effect of this is that you&amp;rsquo;ll learn parts of the core from the inside out while you&amp;rsquo;re testing them.&lt;/p&gt;

&lt;h2 id=&#34;introducing-core-tests&#34;&gt;Introducing core tests&lt;/h2&gt;

&lt;p&gt;Before you start writing your own tests, make sure the existing cases work as expected (without any &lt;code&gt;Exceptions&lt;/code&gt; or &lt;code&gt;Errors&lt;/code&gt;). For developing directly in the core, I&amp;rsquo;d recommend you a slightly different setup than the default one. You should clone the &lt;code&gt;framework&lt;/code&gt; and the &lt;code&gt;lithium&lt;/code&gt; repository in different directories so you can quickly exchange functionality and symlink stuff if you have to. My setup looks similar to this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- web
    - framework
    - libraries
        - lithium
        - li3_docs
        - manual
        - lithium_qa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now tell your &lt;code&gt;framework&lt;/code&gt; to look at the right path, hop into &lt;code&gt;app/config/bootstrap/libraries.php&lt;/code&gt; and modify the &lt;code&gt;LITHIUM_LIBRARY_PATH&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(&#39;LITHIUM_LIBRARY_PATH&#39;, dirname(dirname(LITHIUM_APP_PATH)) . &#39;/libraries&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you haven&amp;rsquo;t already, make sure that the &lt;code&gt;app/resources&lt;/code&gt; folder is writable.&lt;/p&gt;

&lt;p&gt;Assuming you have your &lt;code&gt;DOCROOT&lt;/code&gt; pointing to &lt;code&gt;web&lt;/code&gt;, try to run the tests from the test dashboard located at &lt;code&gt;http://localhost/framework/test&lt;/code&gt;. Ideally, your test output should look something like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://nitschinger.at/img/core_testing_overview.png&#34; title=&#34;Test Dashboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you have any failing tests, try to track down if it is your setup or some test cases are not working correctly. If you&amp;rsquo;re unsure, you can always get feedback on #li3 at freenode.&lt;/p&gt;

&lt;h2 id=&#34;understanding-test-filters&#34;&gt;Understanding test filters&lt;/h2&gt;

&lt;p&gt;Now that existing tests are running as expected, take a look at the buttons on the top. The &lt;code&gt;Affected&lt;/code&gt;, &lt;code&gt;Complexity&lt;/code&gt;, &lt;code&gt;Coverage&lt;/code&gt; and &lt;code&gt;Profiler&lt;/code&gt; labeled buttons are called &amp;ldquo;test filters&amp;rdquo; and perform specific tasks on the selected group of test cases.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://nitschinger.at/img/core_testing_filters.png&#34; title=&#34;Test Filters&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As they are very important, let&amp;rsquo;s go through them in more detail. Note that you need to turn on &lt;a href=&#34;http://xdebug.org/&#34;&gt;Xdebug&lt;/a&gt; to use them, but you should install this extension anyway in your development environment.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Affected:&lt;/strong&gt; The &lt;code&gt;affected&lt;/code&gt; filter shows you what other tests depend on the currently tested class. This helps you to understand what impact a change to the current code would have and where to look out for possible errors.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Complexity:&lt;/strong&gt; The &lt;code&gt;complexity&lt;/code&gt; filter calculates the &lt;a href=&#34;http://en.wikipedia.org/wiki/Cyclomatic_complexity&#34;&gt;Cyclomatic Complexity&lt;/a&gt; for each executed method and shows you the worst offenders. According to best practices, a cyclomatic complexity greater than 10 is &amp;ldquo;very complex&amp;rdquo; and should be refactored if possible. This of course depends heavily on the type of code but it provides a good overview on how complex the class is in general and where to look first to decrease complexity.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Coverage:&lt;/strong&gt; The &lt;code&gt;coverage&lt;/code&gt; filters tries to find out which lines of the tested code got executed in your test. Lithium has the baseline of 85% test coverage for core classes which should ensure that most of the code is at least once tested somewhere. The current implementation of the coverage filter also shows some false-negatives so make sure to take the result with a grain of salt.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Profiler:&lt;/strong&gt; The &lt;code&gt;profiler&lt;/code&gt; filter tells you how long it took to execute the tests and how much memory was used. You can use this to measure the performance of the code and check the impact of code modifications.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Make sure to get familiar with these filters as they are crucial in verifying and investigating your written tests.&lt;/p&gt;

&lt;h2 id=&#34;investigating-core-tests&#34;&gt;Investigating core tests&lt;/h2&gt;

&lt;p&gt;The best way to get familiar with core tests is to look at existing ones. Let&amp;rsquo;s investigate one test case of the &lt;code&gt;ValidatorTest&lt;/code&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Tests that new methods can be called on Validator by adding rules using Validator::add().
 *
 * @return void
 */
public function testAddCustomRegexMethods() {
    $this-&amp;gt;assertNull(Validator::rules(&#39;foo&#39;));

    Validator::add(&#39;foo&#39;, &#39;/^foo$/&#39;);
    $this-&amp;gt;assertTrue(Validator::isFoo(&#39;foo&#39;));
    $this-&amp;gt;assertFalse(Validator::isFoo(&#39;bar&#39;));
    $this-&amp;gt;assertTrue(in_array(&#39;foo&#39;, Validator::rules()));
    $this-&amp;gt;assertEqual(&#39;/^foo$/&#39;, Validator::rules(&#39;foo&#39;));

    $this-&amp;gt;expectException(&amp;quot;Rule `bar` is not a validation rule.&amp;quot;);
    $this-&amp;gt;assertNull(Validator::isBar(&#39;foo&#39;));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you look closely, you can identify a pattern here that will come frequently. Before you test a specific functionality/value, make sure it isn&amp;rsquo;t already set. You can do this with &lt;code&gt;assertFalse&lt;/code&gt;, &lt;code&gt;assertNull&lt;/code&gt; or maybe &lt;code&gt;assertTrue(empty(..))&lt;/code&gt;. Next, perform the piece of code you want to test (like adding a custom regex rule here) and then perform checks on the entity again. A good rule of thumb is to test normal cases first and then exceptional cases (which often raise &lt;code&gt;Exceptions&lt;/code&gt;). You can also break down complicated tests in smaller ones and add helper methods that get called from the main test case.&lt;/p&gt;

&lt;p&gt;If your tests contain dependencies, make sure to initialize them in &lt;code&gt;setUp()&lt;/code&gt; and remove/reset them in &lt;code&gt;tearDown()&lt;/code&gt;. These methods get called before/after all tests in the test class and should leave the environment in a clean state. This prevents unexpected failures in later tests and also keeps the memory usage on a normal level. Here&amp;rsquo;s an example of the &lt;code&gt;MongoDb&lt;/code&gt; test class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function setUp() {
    Connections::config(array(&#39;lithium_mongo_test&#39; =&amp;gt; $this-&amp;gt;_testConfig));
    $this-&amp;gt;db = Connections::get(&#39;lithium_mongo_test&#39;);
    $model = $this-&amp;gt;_model;
    $model::config(array(&#39;key&#39; =&amp;gt; &#39;_id&#39;));
    $model::resetConnection(false);

    $this-&amp;gt;query = new Query(compact(&#39;model&#39;) + array(
        &#39;entity&#39; =&amp;gt; new Document(compact(&#39;model&#39;))
    ));
}

public function tearDown() {
    try {
        $this-&amp;gt;db-&amp;gt;delete($this-&amp;gt;query);
    } catch (Exception $e) {}
    unset($this-&amp;gt;query);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;setUp()&lt;/code&gt; method initializes a test connection to the database and &lt;code&gt;tearDown()&lt;/code&gt; makes sure that the test database gets deleted and the &lt;code&gt;$this-&amp;gt;query&lt;/code&gt; object is freed.&lt;/p&gt;

&lt;p&gt;There are a lot more patterns that you&amp;rsquo;ll learn while writing core tests, but this should give you a start.&lt;/p&gt;

&lt;h2 id=&#34;qa-your-code&#34;&gt;QA your code&lt;/h2&gt;

&lt;p&gt;To ensure a high-quality codebase, Lithium enforces a set of coding standards which can be found &lt;a href=&#34;https://github.com/UnionOfRAD/lithium/wiki/Coding-Standards&#34;&gt;here&lt;/a&gt;. You don&amp;rsquo;t have to know every part of the standard by heart, because Lithium provides a plugin called &lt;a href=&#34;https://github.com/UnionOfRAD/lithium_qa&#34;&gt;lithium_qa&lt;/a&gt;. This plugin checks your code if it complies to the standards and shows you what parts of it are wrong. I recommend you to clone it into the &lt;code&gt;libraries&lt;/code&gt; directory shown above. It is also a good idea to add the &lt;code&gt;li3&lt;/code&gt; command to your &lt;code&gt;PATH&lt;/code&gt; so your calls don&amp;rsquo;t get too verbose.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /usr/local/bin
$ sudo ln -s /path/to/lithium/console/li3 li3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s assume we want to check classes in the &lt;code&gt;lithium\core&lt;/code&gt; namespace:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd lithium_qa
$ li3 syntax ../lithium/core
[Passed ] syntax check of `core/Object.php`
[Passed ] syntax check of `core/Adaptable.php`
[Failed ] syntax check of `core/StaticObject.php`
59| 101| Maximum line length exceeded
[Passed ] syntax check of `core/Environment.php`
[Passed ] syntax check of `core/ConfigException.php`
[Passed ] syntax check of `core/ClassNotFoundException.php`
[Passed ] syntax check of `core/NetworkException.php`
[Passed ] syntax check of `core/ErrorHandler.php`
[Passed ] syntax check of `core/Libraries.php`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There you can see that each core class passed the test except the &lt;code&gt;StaticObject&lt;/code&gt; class which has one line (59) that is too long. Now you can edit that file and modify it accordingly. If you&amp;rsquo;re not sure what the output means, head back to the &lt;a href=&#34;https://github.com/UnionOfRAD/lithium/wiki/Coding-Standards&#34;&gt;official standard&lt;/a&gt; and look for the corresponding entry.&lt;/p&gt;

&lt;p&gt;Please make sure that all code you want to see in the core respects these standards. You can also use it to test your own code as well!&lt;/p&gt;

&lt;h2 id=&#34;getting-help&#34;&gt;Getting help&lt;/h2&gt;

&lt;p&gt;If you&amp;rsquo;re new to code testing in Lithium, make sure to read the official guide in the &lt;a href=&#34;http://lithify.me/docs/manual/10_testing/readme.wiki&#34;&gt;manual&lt;/a&gt; first. Next, check out the main &lt;a href=&#34;https://github.com/UnionOfRAD/lithium/issues/17&#34;&gt;testing ticket on GitHub&lt;/a&gt; which is constantly updated and shows what classes need testing. If you need help on testing the core, make sure to join #li3-core on freenode and ping one of the core developers. You can also contact me directly and I&amp;rsquo;ll make sure to help you out or point you in the right direction.&lt;/p&gt;

&lt;h2 id=&#34;wrapping-up&#34;&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;You should now be able to run the core tests, extend and write your own and also pass your code through the official code quality assurance tool. Please help out and fork the core, run it on your machine, check for errors, extend current tests, write new ones and correct QA issues. If we all work together, I&amp;rsquo;m sure we can make Lithium the best tested web framework out there. If you want to see more information regarding this topic on my blog, comment down below and I&amp;rsquo;ll see what I can provide.&lt;/p&gt;

&lt;p&gt;Keep on coding!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lithium plugin roundup</title>
      <link>http://nitschinger.at/Lithium-plugin-roundup/</link>
      <pubDate>Wed, 22 Jun 2011 00:00:00 +0000</pubDate>
      
      <guid>http://nitschinger.at/Lithium-plugin-roundup/</guid>
      <description>

&lt;p&gt;Note that this list is by no means complete. If you don&amp;rsquo;t find your own mentioned here, feel free to comment below. I&amp;rsquo;ve also tried to roughly group them so you can find them later more easily.&lt;/p&gt;

&lt;h2 id=&#34;authentication-security&#34;&gt;Authentication &amp;amp; Security&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/tmaiaroto/li3_access&#34;&gt;li3_access&lt;/a&gt;: Access control library by &lt;em&gt;tmaiaroto&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/weluse/li3_ids&#34;&gt;li3_ids&lt;/a&gt;: Intrusion detection integration (phpids) by &lt;em&gt;weluse&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/gwoo/li3_oauth&#34;&gt;li3_oauth&lt;/a&gt;: OAuth library by &lt;em&gt;gwoo&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;apis-and-externals&#34;&gt;APIs and Externals&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/cgarvis/li3_delayed_job&#34;&gt;li3_delayed_job&lt;/a&gt;: Ruby&amp;rsquo;s Delayed::Job port to Lithium by &lt;em&gt;cgarvis&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/tmaiaroto/li3_facebook&#34;&gt;li3_facebook&lt;/a&gt;: Facebook API wrapper by &lt;em&gt;tmaiaroto&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/JacopKane/li3_flickr&#34;&gt;li3_flickr&lt;/a&gt;: Flickr API wrapper by &lt;em&gt;jacopKane&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/greut/li3_swiftmailer&#34;&gt;li3_swiftmailer&lt;/a&gt;: Interface to the Swiftmailer library by &lt;em&gt;greut&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;view-layer-helpers&#34;&gt;View Layer &amp;amp; Helpers&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/greut/li3_analytics&#34;&gt;li3_analytics&lt;/a&gt;: Integrate Google Analytics easily by &lt;em&gt;greut&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/UnionOfRAD/li3_design&#34;&gt;li3_design&lt;/a&gt;: Useful things for designers like placeholder texts by &lt;em&gt;UnionOfRAD&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://rad-dev.org/li3_flash_message&#34;&gt;li3_flash_message&lt;/a&gt;: Flash message generation by &lt;em&gt;michaelhue&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://rad-dev.org/li3_gravatar&#34;&gt;li3_gravatar&lt;/a&gt;: Gravatar integration by &lt;em&gt;michaelhue&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/harikt/li3_htmlpurifier&#34;&gt;li3_htmlpurifier&lt;/a&gt;: Wrapper around the HTML filtering library by &lt;em&gt;harikt&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/indiefan/li3_injector&#34;&gt;li3_injector&lt;/a&gt;: DOM markup injection by &lt;em&gt;indiefan&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/glaszig/li3_less&#34;&gt;li3_less&lt;/a&gt;: Support for LESS CSS by &lt;em&gt;glaszig&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sandelius/li3_markdown&#34;&gt;li3_markdown&lt;/a&gt;: Wrapper for PHP Markdown by &lt;em&gt;sandelius&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/primetheus/li3_paginate&#34;&gt;li3_paginate&lt;/a&gt;: Pagination plugin by &lt;em&gt;primetheus&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/greut/li3_pdf&#34;&gt;li3_pdf&lt;/a&gt;: PDF generation plugin by &lt;em&gt;greut&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/masom/li3_sitemap&#34;&gt;li3_sitemap&lt;/a&gt;: Sitemap generator by &lt;em&gt;masom&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/henrikbjorn/li3_twig&#34;&gt;li3_twig&lt;/a&gt;: Twig templating support by &lt;em&gt;henrikbjorn&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;data-layer&#34;&gt;Data Layer&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/greut/li3_activerecord&#34;&gt;li3_activerecord&lt;/a&gt;: PHP ActiveRecord wrapper by &lt;em&gt;greut&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://rad-dev.org/li3_behaviors&#34;&gt;li3_behaviors&lt;/a&gt;: Model behavior support by &lt;em&gt;nateabele&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/weluse/li3_dateable&#34;&gt;li3_dateable&lt;/a&gt;: Adds timestamp to records/documents by &lt;em&gt;weluse&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://rad-dev.org/li3_doctrine&#34;&gt;li3_doctrine&lt;/a&gt;: Doctrine2 integration by &lt;em&gt;Richard McIntyre&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://rad-dev.org/li3_geo&#34;&gt;li3_geo&lt;/a&gt;: Geospatial querying for multiple databases by &lt;em&gt;nateabele&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/raisinbread/li3_simplesearch&#34;&gt;li3_simplesearch&lt;/a&gt;: SQLite3 based searching by &lt;em&gt;raisinbread&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jperras/li3_sqlsrv&#34;&gt;li3_sqlsrv&lt;/a&gt;: SQL Server datasource by &lt;em&gt;jperras&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/vogan/li3_tree&#34;&gt;li3_tree&lt;/a&gt;: Tree model behavior by &lt;em&gt;vogan&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;testing-documentation&#34;&gt;Testing &amp;amp; Documentation&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/UnionOfRAD/li3_docs&#34;&gt;li3_docs&lt;/a&gt;: Official documentation plugin by &lt;em&gt;UnionOfRAD&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/daschl/li3_fixtures&#34;&gt;li3_fixtures&lt;/a&gt;: Add Fixtures to your tests by &lt;em&gt;daschl&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://rad-dev.org/li3_junit&#34;&gt;li3_junit&lt;/a&gt;: JUnit integration by &lt;em&gt;Michael Harris&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;misc&#34;&gt;Misc&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/UnionOfRAD/li3_cldr&#34;&gt;li3_cldr&lt;/a&gt;: Query the Unicode CLDR by &lt;em&gt;UnionOfRAD&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Howard3/li3_config_loader&#34;&gt;li3_config_loader&lt;/a&gt;: Load configs on the fly during bootstrap by &lt;em&gt;Howard3&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Howard3/li3_debug&#34;&gt;li3_debug&lt;/a&gt;: Debugging Library by &lt;em&gt;Howard3&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/daschl/li3_rest&#34;&gt;li3_rest&lt;/a&gt;: adds REST support to your application by &lt;em&gt;daschl&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;I have to say that I&amp;rsquo;m very excited to see what the community is currently building and how Lithium as a whole evolves. Thanks to everyone who is participating and keep up the awesome work!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Securing Lithium Forms</title>
      <link>http://nitschinger.at/Securing-Lithium-Forms/</link>
      <pubDate>Wed, 08 Jun 2011 00:00:00 +0000</pubDate>
      
      <guid>http://nitschinger.at/Securing-Lithium-Forms/</guid>
      <description>&lt;p&gt;CSRF (Cross-Site-Request-Forgery) attacks work by sending arbitary (form) requests from a victim. Normally, the receiving site (in our case the &lt;code&gt;Controller&lt;/code&gt; who processes the form data) doesn&amp;rsquo;t know where the data comes from. The CSRF protection in Lithium aims to solve this problem in an elegant and secure way. You can read more about those attacks
&lt;a href=&#34;http://shiflett.org/articles/cross-site-request-forgeries&#34;&gt;here&lt;/a&gt;. Note that
you&amp;rsquo;ll need to clone the latest &lt;code&gt;master&lt;/code&gt; branch of Lithium if you want to
try it out now.&lt;/p&gt;

&lt;p&gt;CSRF protection in Lithium is twofold. First, you need to add a unique token to your forms and then check in your controller if the sent token is correct. As Lithium stores the generated &lt;code&gt;sessionKey&lt;/code&gt; in your session, make sure that you have session support enabled. If you don&amp;rsquo;t activate sessions, the &lt;code&gt;check&lt;/code&gt; method fails silently (which we&amp;rsquo;llsee later on). So uncomment the following line in &lt;code&gt;app/config/bootstrap.php&lt;/code&gt; (if you haven&amp;rsquo;t already):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * This file contains configuration for session (and/or cookie) storage, and user or web service
 * authentication.
 *
 */
//require __DIR__ . &#39;/bootstrap/session.php&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s look at the view layer first with a very simple form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?= $this-&amp;gt;form-&amp;gt;create(); ?&amp;gt;
    &amp;lt;?= $this-&amp;gt;security-&amp;gt;requestToken(); ?&amp;gt;
    &amp;lt;?= $this-&amp;gt;form-&amp;gt;field(&#39;title&#39;); ?&amp;gt;
    &amp;lt;?= $this-&amp;gt;form-&amp;gt;submit(&#39;Submit&#39;); ?&amp;gt;
&amp;lt;?= $this-&amp;gt;form-&amp;gt;end(); ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thanks to lazy loading, we don&amp;rsquo;t have to do anything special to
include our new &lt;code&gt;Security&lt;/code&gt; helper. The helper provides the
&lt;code&gt;requestToken()&lt;/code&gt; method that generates a unique token (a salted hash) and renders it in a hidden field. If you inspect your form, you should see
something like this (note that i&amp;rsquo;ve shortened the value attribute for better
readability):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;hidden&amp;quot; value=&amp;quot;$2a$1...Ay62/W&amp;quot; name=&amp;quot;security[token]&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we&amp;rsquo;ve adapted our form, we can work with it in our controller.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php

namespace app\controllers;

use lithium\security\validation\RequestToken;

class TasksController extends \lithium\action\Controller {

    public function add() {
        if($this-&amp;gt;request-&amp;gt;data) {
            if(!RequestToken::check($this-&amp;gt;request)) {
                RequestToken::get(array(&#39;regenerate&#39; =&amp;gt; true));
            } else {
                // work with the request as usual
            }
        }
    }

}

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are many ways how to handle security checks, so the code snippet above shows only one of them. Let&amp;rsquo;s tackle the important parts one by one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use lithium\security\validation\RequestToken;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll need to import the &lt;code&gt;RequestToken&lt;/code&gt; class into your namespace, as it is the responsible class for dealing with the tokens.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RequestToken::check($this-&amp;gt;request);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;check&lt;/code&gt; method reads the &lt;code&gt;sessionKey&lt;/code&gt; from your session and checks if it is identical to the requested one. You can also provide the key directly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$key = $this-&amp;gt;request-&amp;gt;data[&#39;security&#39;][&#39;token&#39;];
RequestToken::check($key);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can modify the key manually (set it to &lt;code&gt;foobar&lt;/code&gt; or so) and then see if the &lt;code&gt;check&lt;/code&gt; method fails. How you may handle security errors depends heavily on your application. In our example, we regenerate the token with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RequestToken::get(array(&#39;regenerate&#39; =&amp;gt; true));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you go down this route, you&amp;rsquo;ll also have to tell the user what happend in your view. A more secure route would be to raise an exception (or render a error template) and log what happened. In normal production environments this is clearly a exceptional behavior and therefore should be treated this way. If you need this more often in your controller, you can also move the checks to the &lt;code&gt;_init()&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class TasksController extends \lithium\action\Controller {

    public function _init() {
        parent::_init();

        if($this-&amp;gt;request-&amp;gt;data &amp;amp;&amp;amp; !RequestToken::check($this-&amp;gt;request)) {
            $host = $this-&amp;gt;request-&amp;gt;env(&#39;HTTP_HOST&#39;);
            Logger::error(&amp;quot;Possible CSRF attack from host $host&amp;quot;);
            $this-&amp;gt;redirect(&#39;/&#39;);
        }
    }

    public function add() {
        if($this-&amp;gt;request-&amp;gt;data) {
                // save your data as usual
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should give you a good starting point on how to work with the new
CSRF protection mechanisms. As of today, there is only one major feature left (namely MongoDB relationships) until Lithium reaches the &amp;ldquo;big one&amp;rdquo; so stay tuned for more announcements in the next weeks!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Custom Finders with Lithium</title>
      <link>http://nitschinger.at/Custom-Finders-with-Lithium/</link>
      <pubDate>Fri, 03 Jun 2011 00:00:00 +0000</pubDate>
      
      <guid>http://nitschinger.at/Custom-Finders-with-Lithium/</guid>
      <description>&lt;p&gt;Finders assist you with often-used database queries so you don&amp;rsquo;t have to write them over and over again. Out of the box, Lithium provides you with a bunch of them: &lt;code&gt;all&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; &lt;code&gt;list&lt;/code&gt; and &amp;ldquo;magic finders like&amp;rdquo;
&lt;code&gt;findById&lt;/code&gt; or &lt;code&gt;findFirstById&lt;/code&gt;. How these are constructed in the core is not
relevant for now, but Lithium provides you with a mechanism to write your own finders easily.&lt;/p&gt;

&lt;p&gt;To understand how we can implement our own finder, let&amp;rsquo;s take a look at the built-in &lt;code&gt;first&lt;/code&gt; one. If you want to dig deeper, look at the
&lt;a href=&#34;http://lithify.me/docs/lithium/data/Model::_findFilters%28%29&#34;&gt;_findFilters()&lt;/a&gt; method. The &lt;code&gt;_findFilters()&lt;/code&gt; method constructs the default finders and returns them to the &lt;code&gt;Model::config()&lt;/code&gt; method so that they are loaded when your model is initialized.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ... some php code ...
&#39;first&#39; =&amp;gt; function($self, $params, $chain) {
    $params[&#39;options&#39;][&#39;limit&#39;] = 1;
    $data = $chain-&amp;gt;next($self, $params, $chain);
    $data = is_object($data) ? $data-&amp;gt;rewind() : $data;
    return $data ?: null;
}
// ... more finders ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your custom finders will also take the same params, so they let&amp;rsquo;s investigate them:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$self&lt;/code&gt; contains the current model as a string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$params&lt;/code&gt; contains the find options that you already know like &lt;code&gt;order&lt;/code&gt;
or &lt;code&gt;conditions&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$chain&lt;/code&gt; contains filter chain.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As you may have recognized, this looks like our typical
&lt;a href=&#34;http://rad-dev.org/drafts/source/en/02_lithium_basics/02_filters.wiki&#34;&gt;Filters&lt;/a&gt; pattern in Lithium! In fact, all finders run through the filter system and this is good news for us: we can also adapt the default ones if we need to.&lt;/p&gt;

&lt;p&gt;Our code example first sets a &lt;code&gt;limit&lt;/code&gt; option and then lets the chain move on. At the end of the chain, it sets the returned data to the beginning if its an object or just returns the array. Now it&amp;rsquo;s time to write our own finder. To keep things simple at first, let&amp;rsquo;s say we want to find the first five datasets in our model. Just add it to your controller for now, we&amp;rsquo;ll see a bit later how to move it to your model.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Tasks::finder(&#39;firstFive&#39;, function($self, $params, $chain) {
    $params[&#39;options&#39;][&#39;limit&#39;] = 5;
    $data = $chain-&amp;gt;next($self, $params, $chain);
    return $data ?: null;       
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our example we have a &lt;code&gt;Tasks&lt;/code&gt; model who just has an &lt;code&gt;id&lt;/code&gt; and a task &lt;code&gt;name&lt;/code&gt; stored. Note that we use MySQL here so that noone can say I&amp;rsquo;m always using MongoDB ;). We can now run our finder with one of the following methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$tasks = Tasks::find(&#39;firstFive&#39;)
$tasks = Tasks::firstFive();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to check the results immediately, you can use the handy &lt;code&gt;to(&#39;array&#39;)&lt;/code&gt; method on the result set:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var_dump(Tasks::firstFive()-&amp;gt;to(&#39;array&#39;));

// Should print something like
array
    1 =&amp;gt; 
        array
            &#39;id&#39; =&amp;gt; string &#39;1&#39; (length=1)
            &#39;title&#39; =&amp;gt; string &#39;first task&#39; (length=10)
    2 =&amp;gt; 
        array
            &#39;id&#39; =&amp;gt; string &#39;2&#39; (length=1)
            &#39;title&#39; =&amp;gt; string &#39;second task&#39; (length=11)
    3 =&amp;gt; 
        array
            &#39;id&#39; =&amp;gt; string &#39;3&#39; (length=1)
            &#39;title&#39; =&amp;gt; string &#39;third task&#39; (length=10)
    4 =&amp;gt; 
        array
            &#39;id&#39; =&amp;gt; string &#39;4&#39; (length=1)
            &#39;title&#39; =&amp;gt; string &#39;fourth task&#39; (length=11)
    5 =&amp;gt; 
        array
            &#39;id&#39; =&amp;gt; string &#39;5&#39; (length=1)
            &#39;title&#39; =&amp;gt; string &#39;fifth task&#39; (length=10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you comment out the limit line in our filter, you can see that you get all results back from the database (just make sure you have more than five rows stored so you can see the difference).&lt;/p&gt;

&lt;p&gt;Recently, a new functionality was added to make custom finders a bit more flexible. You can now just hand over an array of params and you don&amp;rsquo;t need to provide a full closure. This comes in handy when you just want to add a &lt;code&gt;limit&lt;/code&gt; or a fixed set of &lt;code&gt;conditions&lt;/code&gt;. Note that this is currently only available in the &lt;code&gt;x-relationships&lt;/code&gt; branch. Once the whole relationship-related code gets merged into master, this feature will also be available.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Tasks::finder(&#39;myAwesomeFinder&#39;, array(
    &#39;fields&#39; =&amp;gt; array(&#39;id&#39;, &#39;name&#39;),
    &#39;conditions&#39; =&amp;gt; array(&#39;id&#39; =&amp;gt; 2)
));

$tasks = Tasks::myAwesomeFinder();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also add the custom finder in your model, so you don&amp;rsquo;t have to deal with it in the controller. According to the MVC pattern, I&amp;rsquo;d recomend you to place it there. You can override the &lt;code&gt;__init()&lt;/code&gt; method so that your finder will be loaded at runtime.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static function __init() {
    parent::__init();
    static::finder(&#39;firstFive&#39;, function($self, $params, $chain) {
        $params[&#39;options&#39;][&#39;limit&#39;] = 5;
        $data = $chain-&amp;gt;next($self, $params, $chain);
        return $data ?: null;
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I think this is enough for a short introduction into custom finders, if you want to find out more you should check out the &lt;a href=&#34;http://lithify.me/docs/lithium/data/Model::finder%28%29&#34;&gt;Model::finder&lt;/a&gt;
method and poke around in the &lt;a href=&#34;http://lithify.me/docs/lithium/data/Model::find%28%29&#34;&gt;Model::find&lt;/a&gt; source. Once the model part of the &lt;a href=&#34;http://rad-dev.org/drafts/source&#34;&gt;drafts&lt;/a&gt; is finished, you&amp;rsquo;ll finde more detailed documentation on this topic.&lt;/p&gt;

&lt;p&gt;With this tool in mind, interesting possibilities start to pop up. You can now easily add logging during development to your finders, add caching mechanisms and so on. Please cast your vote in the comments if you want to read more on this topic. So now go ahead and &lt;a href=&#34;http://de.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself&#34;&gt;DRY&lt;/a&gt; up your controllers and models!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Caching responses in Lithium</title>
      <link>http://nitschinger.at/Caching-responses-in-Lithium/</link>
      <pubDate>Mon, 30 May 2011 00:00:00 +0000</pubDate>
      
      <guid>http://nitschinger.at/Caching-responses-in-Lithium/</guid>
      <description>&lt;p&gt;If you need to cache full &lt;code&gt;Response&lt;/code&gt; objects in Lithium (which means that your controllers don&amp;rsquo;t even get called when there&amp;rsquo;s a cache hit), you can place this in your &lt;code&gt;app/config/bootstrap/cache.php&lt;/code&gt; file (note that this is certainly not &amp;ldquo;production ready&amp;rdquo;, but it should give you a starting point):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Cache full Responses
 */
Dispatcher::applyFilter(&#39;run&#39;, function($self, $params, $chain) {
    $key = md5(LITHIUM_APP_PATH) . &#39;.app.cache.&#39;.md5($params[&#39;request&#39;]-&amp;gt;url);
    if($cache = Cache::read(&#39;default&#39;, $key)) {
        return $cache;
    }

    $result = $chain-&amp;gt;next($self, $params, $chain);

    Cache::write(&#39;default&#39;, $key, $result, &#39;+1 day&#39;);
    return $result;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It filters the &lt;code&gt;Dispatcher&lt;/code&gt; and first checks if the &lt;code&gt;Response&lt;/code&gt; object is already stored in the cache. The cache key is based on the requested URL, so if your &lt;code&gt;/&lt;/code&gt; URL points to `&lt;code&gt;/posts/index&lt;/code&gt;, both requests will be cached seperately (you could modify the code snipped so that it talks to the &lt;code&gt;Router&lt;/code&gt; and checks for the corresponding controller/action object and cache on this key).&lt;/p&gt;

&lt;p&gt;Your filter chain returns the &lt;code&gt;Response&lt;/code&gt; object, so we can directly cache it. The serialization strategy takes care of correctly storing and retrieving our cached object.&lt;/p&gt;

&lt;p&gt;If you have alternative approaches to tackle this, please let me know!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Understanding the Lithium Router - Part 2</title>
      <link>http://nitschinger.at/Understanding-the-Lithium-Router-Part-2/</link>
      <pubDate>Thu, 24 Feb 2011 00:00:00 +0000</pubDate>
      
      <guid>http://nitschinger.at/Understanding-the-Lithium-Router-Part-2/</guid>
      <description>

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;Routes play an essential role in your request/response-cycle and therefore should also be tested like any other component that you develop. As the Lithium routing infrastructure also consists of classes and methods, we can run unit and integration tests against them.&lt;/p&gt;

&lt;p&gt;If we follow the testing conventions, we need to differentiate two distinct methods of testing. The first one (the so called &amp;ldquo;&lt;a href=&#34;http://en.wikipedia.org/wiki/Unit_testing&#34;&gt;Unit Test&lt;/a&gt;&amp;rdquo;), is used to test your routes one by one, isolated from your application and ideally all dependencies are mocked away. The second one (called &amp;ldquo;&lt;a href=&#34;http://en.wikipedia.org/wiki/Integration_testing&#34;&gt;Integration Test&lt;/a&gt;&amp;rdquo;), takes the state of your actual application into account and therefore tests the routes in a &amp;ldquo;real environment&amp;rdquo;. This way we can validate their functionality in isolation, and when we are confident with that we can check that no dependencies or other interfaces change the expected behavior.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s cover unit tests first and then move on to the integration tests. Afterwards, we&amp;rsquo;ll look at testing reverse routes (more on that later).&lt;/p&gt;

&lt;h3 id=&#34;unit-testing&#34;&gt;Unit Testing&lt;/h3&gt;

&lt;p&gt;Let me clarify one thing first: in general, you don&amp;rsquo;t need to unit test your routes (instead you only need to do integration testing, but more on that later). There core developers did an awesome job in unit testing the routing infrastructure for you, so there is no need for you to duplicate their tests.&lt;/p&gt;

&lt;p&gt;Nevertheless, learning  something about unit testing routes has two benefits. On the one hand, you get some practice in writing unit tests and on the other hand you get a better understand on how the routing system works internally. So i really recommend you to read through this section and play around with the code.&lt;/p&gt;

&lt;p&gt;If we don&amp;rsquo;t know how to implement unit tests, it is always a good idea to look at the core tests, as they show us how to do this properly and at the same time give us use cases that we can use in our own application. We can also copy and modify some tests, because often our own tests will be similar.&lt;/p&gt;

&lt;p&gt;Before we can unit test some routes, we need to add a unit test file. According to the namespace standard, let&amp;rsquo;s create the appropriate file (&lt;code&gt;RouteTest.php&lt;/code&gt;) in &lt;code&gt;app\tests\cases\net\http&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
namespace app\tests\cases\net\http;

use lithium\action\Request;
use lithium\net\http\Route;

class RouteTest extends \lithium\test\Unit {

}

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our first test, we want to make sure that the route &lt;code&gt;/foo&lt;/code&gt;, matches the &lt;code&gt;FooController&lt;/code&gt; and the &lt;code&gt;index&lt;/code&gt; action. Insert the following test case in your previously created class and run it through the test runner (&amp;ldquo;&lt;a href=&#34;http://example.com/test/app/tests/cases/net/http/RouteTest&amp;quot;&#34;&gt;http://example.com/test/app/tests/cases/net/http/RouteTest&amp;quot;&lt;/a&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function testFooRoute() {
    $params = array(&#39;controller&#39; =&amp;gt; &#39;foo&#39;, &#39;action&#39; =&amp;gt; &#39;index&#39;);
    $route = new Route(array(
        &#39;template&#39; =&amp;gt; &#39;/foo&#39;,
        &#39;params&#39; =&amp;gt; $params
    ));

    $request = new Request();
    $request-&amp;gt;url = &#39;/foo&#39;;

    $result = $route-&amp;gt;parse($request);
    $this-&amp;gt;assertEqual($params, $result-&amp;gt;params);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run &lt;code&gt;Router::connect()&lt;/code&gt;, the &lt;code&gt;Router&lt;/code&gt; basically creates a new &lt;code&gt;Route&lt;/code&gt; object and passes the arguments to its constructor. In our tests we do the same, but we initialize the Route directly. This way, we can test the route in isolation. When we create a new route, the &lt;code&gt;template&lt;/code&gt; param is the URL that our route will match (remember that it can also contain non-static identifiers). The params argument tells
the route what to return when the template matches the request. We then create a simple &lt;code&gt;Request&lt;/code&gt; object (that mimics a request by the browser) and hard-code a URL (in the real application, the &lt;code&gt;$request-&amp;gt;url&lt;/code&gt; will be dynamically assigned). Now we run &lt;code&gt;parse()&lt;/code&gt;,
that&amp;rsquo;s exactly what the Router does route for route when the &lt;code&gt;Dispatcher&lt;/code&gt; asks him to route the request. The parse method returns a &lt;code&gt;Request&lt;/code&gt; object with the params set accordingly when it matches, and false when it does not.&lt;/p&gt;

&lt;p&gt;To get more familiar, we&amp;rsquo;ll add some more assertions to this test, just append them after the last &lt;code&gt;assertEqual()&lt;/code&gt; and run the tests again. You can see that this route really matches only &lt;code&gt;/foo&lt;/code&gt; and nothing else:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$request-&amp;gt;url = &#39;/bar&#39;;
$result = $route-&amp;gt;parse($request);
$this-&amp;gt;assertFalse($result);

$request-&amp;gt;url = &#39;/foo/edit&#39;;
$result = $route-&amp;gt;parse($request);
$this-&amp;gt;assertFalse($result);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we wrote some basic tests, let&amp;rsquo;s move on to a slightly more complex example with a non-static routing template. The route &lt;code&gt;/users/{:id}&lt;/code&gt; matches with or without an ID given and passes it as a param in the returned request object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function testUserWithIdRoute() {
    $params = array(&#39;id&#39; =&amp;gt; null, &#39;action&#39; =&amp;gt; &#39;index&#39;, &#39;controller&#39; =&amp;gt; &#39;users&#39;);
    $route = new Route(array(
        &#39;template&#39; =&amp;gt; &#39;/users/{:id}&#39;,
        &#39;params&#39; =&amp;gt; $params
    ));
    $request = new Request();

    $request-&amp;gt;url = &#39;/users&#39;;
    $result = $route-&amp;gt;parse($request);
    $this-&amp;gt;assertEqual($params, $result-&amp;gt;params);
    $this-&amp;gt;assertNull($result-&amp;gt;params[&#39;id&#39;]);

    $request-&amp;gt;url = &#39;/users/4&#39;;
    $result = $route-&amp;gt;parse($request);
    $this-&amp;gt;assertEqual(4, $result-&amp;gt;params[&#39;id&#39;]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also test for various HTTP parameters like the request type (typically GET, PUT, POST and DELETE). Let&amp;rsquo;s assume we want to match &lt;code&gt;/cocktails/delete/{:id}&lt;/code&gt; only when the id is present (non-optional), it is numeric and the request method is &lt;code&gt;delete&lt;/code&gt;. The equivalent router call in our &lt;code&gt;routes.php&lt;/code&gt; file would be &lt;code&gt;Router::connect(&#39;/cocktails/delete/{:id:\d+}, array(&#39;controller&#39; =&amp;gt; &#39;cocktails&#39;, 
&#39;action&#39; =&amp;gt; &#39;delete&#39;, &#39;http:method&#39; =&amp;gt; &#39;DELETE&#39;));&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function testCocktailDeleteRoute() {
    $params = array(
        &#39;controller&#39; =&amp;gt; &#39;cocktails&#39;,
        &#39;action&#39; =&amp;gt; &#39;delete&#39;,
        &#39;http:method&#39; =&amp;gt; &#39;DELETE&#39;
    );
    $route = new Route(array(
        &#39;template&#39; =&amp;gt; &#39;/cocktails/delete/{:id:\d+}&#39;,
        &#39;params&#39; =&amp;gt; $params
    ));

    $request = new Request();
    $request-&amp;gt;url = &#39;/cocktails/delete/4&#39;;
    $result = $route-&amp;gt;parse($request);
    $this-&amp;gt;assertFalse($result);

    $request = new Request(array(&#39;env&#39; =&amp;gt; array(&#39;REQUEST_METHOD&#39; =&amp;gt; &#39;DELETE&#39;)));
    $request-&amp;gt;url = &#39;/cocktails/delete&#39;;
    $result = $route-&amp;gt;parse($request);
    $this-&amp;gt;assertFalse($result);

    $request = new Request(array(&#39;env&#39; =&amp;gt; array(&#39;REQUEST_METHOD&#39; =&amp;gt; &#39;DELETE&#39;)));
    $request-&amp;gt;url = &#39;/cocktails/delete/4&#39;;
    $result = $route-&amp;gt;parse($request);
    $this-&amp;gt;assertEqual(4, $result-&amp;gt;params[&#39;id&#39;]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As stated in the first lines of this section, you won&amp;rsquo;t need to do this in your application code, but writing this kind of tests has one more benefit: if something goes wrong, it is a great tool to understand the inner workings and also to test scenarios in isolation. If you encounter any bugs in the router, writing a unit test that shows the failure is also highly recommended, so that the core team is able to track down your problem and reproduce it in their environments. Also, writing failing test cases ensures that after a bug is fixed, it never happens again.&lt;/p&gt;

&lt;p&gt;A great way to inspect and debug routes is the &lt;code&gt;export()&lt;/code&gt; method. With this method, you can inspect the full state of an route and run assertions against it. Let&amp;rsquo;s try this in a test:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function testExport() {
    $params = array(&#39;controller&#39; =&amp;gt; &#39;posts&#39;, &#39;action&#39; =&amp;gt; &#39;index&#39;);
    $route = new Route(array(
        &#39;template&#39; =&amp;gt; &#39;/read&#39;,
        &#39;params&#39; =&amp;gt; $params
    ));

    $exported = $route-&amp;gt;export();
    $this-&amp;gt;assertEqual($params, $exported[&#39;params&#39;]);
    $this-&amp;gt;assertEqual(&#39;/read&#39;, $exported[&#39;template&#39;]);
    $this-&amp;gt;assertFalse($exported[&#39;handler&#39;]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s move on to something that we should really use in our applications, integration testing.&lt;/p&gt;

&lt;h3 id=&#34;integration-testing&#34;&gt;Integration Testing&lt;/h3&gt;

&lt;p&gt;Now that we&amp;rsquo;ve tested each route in isolation, it&amp;rsquo;s time to get a higher-level view of our application. When we test more than one class in isolation, we call that &amp;ldquo;Integration Testing&amp;rdquo;. Technically, these tests are similar to normal unit tests, so you don&amp;rsquo;t need to learn something new. In a typical framework request, the &lt;code&gt;Dispatcher&lt;/code&gt; calls the &lt;code&gt;Router&lt;/code&gt; with a &lt;code&gt;Request&lt;/code&gt;, and the router matches it against all connected routes and checks if there is a match.&lt;/p&gt;

&lt;p&gt;The following code snippets are suited for a default installation. Create a &lt;code&gt;RouterTest.php&lt;/code&gt; file in &lt;code&gt;app/tests/integration/net/http&lt;/code&gt;. Additionally, you may also need to create the appropriate subdirectories in there.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
namespace app\tests\integration\net\http;
use lithium\net\http\Router;

class RouterTest extends \lithium\test\Unit {

}

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can issue a request against the router and check that the output is correct. Let&amp;rsquo;s do that for a subset of our default routes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function testRootRoute() {
    $expected = array(&#39;controller&#39; =&amp;gt; &#39;pages&#39;, &#39;action&#39; =&amp;gt; &#39;view&#39;);

    $request = new Request();
    $request-&amp;gt;url = &#39;/&#39;;

    $result = Router::process($request);
    $this-&amp;gt;assertEqual($expected, $result-&amp;gt;params);
}

public function testPagesRoutes() {
    $request = new Request();

    $request-&amp;gt;url = &#39;/pages&#39;;
    $result = Router::process($request);
    $expected = array(
        &#39;controller&#39; =&amp;gt; &#39;pages&#39;,
        &#39;action&#39; =&amp;gt; &#39;view&#39;
    );
    $this-&amp;gt;assertEqual($expected, $result-&amp;gt;params);

    $request-&amp;gt;url = &#39;/pages/1&#39;;
    $result = Router::process($request);
    $expected = array(
        &#39;args&#39; =&amp;gt; array(&#39;1&#39;),
        &#39;controller&#39; =&amp;gt; &#39;pages&#39;,
        &#39;action&#39; =&amp;gt; &#39;view&#39;
    );
    $this-&amp;gt;assertEqual($expected, $result-&amp;gt;params);
}

public function testDefaultRoutes() {
    $request = new Request();

    $request-&amp;gt;url = &#39;/foo&#39;;
    $result = Router::process($request);
    $expected = array(
        &#39;controller&#39; =&amp;gt; &#39;foo&#39;,
        &#39;action&#39; =&amp;gt; &#39;index&#39;
    );
    $this-&amp;gt;assertEqual($expected, $result-&amp;gt;params);

    $request-&amp;gt;url = &#39;/foo/bar&#39;;
    $result = Router::process($request);
    $expected = array(
        &#39;controller&#39; =&amp;gt; &#39;foo&#39;,
        &#39;action&#39; =&amp;gt; &#39;bar&#39;
    );
    $this-&amp;gt;assertEqual($expected, $result-&amp;gt;params);

    $request-&amp;gt;url = &#39;/foo/bar/1&#39;;
    $result = Router::process($request);
    $expected = array(
        &#39;controller&#39; =&amp;gt; &#39;foo&#39;,
        &#39;action&#39; =&amp;gt; &#39;bar&#39;,
        &#39;args&#39; =&amp;gt; array(&#39;1&#39;)
    );
    $this-&amp;gt;assertEqual($expected, $result-&amp;gt;params);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most of the code should look familiar to you, the most interesting part is the call of &lt;code&gt;Router::process()&lt;/code&gt;. This method is also called by the dispatcher (but with the actual Request object). For every call to the Router, we simulate a request by the client browser. This code contains a high amount of duplication, so you may want to compact this and create a helper method in your test class that wraps and simplifies the duplicated code.&lt;/p&gt;

&lt;p&gt;Here is another example for a route that we can test:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use app\models\Post;

Router::connect(&#39;/{:slug:[\w\-]+}&#39;, array(&#39;Posts::show&#39;), function($request) {

    $conditions = array(
        &#39;conditions&#39; =&amp;gt; array(
            &#39;slug&#39; =&amp;gt; $request-&amp;gt;params[&#39;slug&#39;]
        )
    );

    if(Post::count($conditions)) {
        return $request;
    } else {
        return false;
    }

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When this route is placed right before the default routes, it should correctly match URLs like &lt;code&gt;/a-cool-article&lt;/code&gt;. The code inside the closure calls the database and checks if the given slug really exists in the database. If it does, it returns the request (and false if not). The router iterates over each route and when false is returned, he tries the next route. So when we return the &lt;code&gt;Request&lt;/code&gt;-object, we tell the router that our route is the one he has searched for. To ensure that everything works as expected, we can write some integration tests.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function testSlugRoute() {
    $request = new Request();

    // a correct slug (stored in the db)
    $request-&amp;gt;url = &#39;/a-correct-slug&#39;;
    $result = Router::process($request);
    $expected = array(
        &#39;controller&#39; =&amp;gt; &#39;posts&#39;,
        &#39;action&#39; =&amp;gt; &#39;show&#39;,
        &#39;slug&#39; =&amp;gt; &#39;a-correct-slug&#39;
    );
    $this-&amp;gt;assertEqual($expected, $result-&amp;gt;params);

    // not a correct slug, renders a default route
    $request-&amp;gt;url = &#39;/foobar-not-a-slug-here&#39;;
    $result = Router::process($request);
    $expected = array(
        &#39;controller&#39; =&amp;gt; &#39;posts&#39;,
        &#39;action&#39; =&amp;gt; &#39;show&#39;,
        &#39;slug&#39; =&amp;gt; &#39;foobar-not-a-slug-here&#39;
    );
    $this-&amp;gt;assertNotEqual($expected, $result-&amp;gt;params);
    $this-&amp;gt;assertFalse(isset($result-&amp;gt;params[&#39;slug&#39;]));

    // tests should always come first
    $request-&amp;gt;url = &#39;/test&#39;;
    $result = Router::process($request);
    $expected = array(
        &#39;controller&#39; =&amp;gt; &#39;lithium\test\Controller&#39;,
        &#39;action&#39; =&amp;gt; &#39;index&#39;,
    );
    $this-&amp;gt;assertEqual($expected, $result-&amp;gt;params);
    $this-&amp;gt;assertFalse(isset($result-&amp;gt;params[&#39;slug&#39;]));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code assumes that your database has a reproducible set of posts stored in it. I&amp;rsquo;d recommend you to load a set of posts with the &lt;a href=&#34;http://rad-dev.org/li3_fixtures&#34;&gt;li3_fixtures&lt;/a&gt; plugin and then populate the database in the &lt;code&gt;setUp()&lt;/code&gt; method. If you want to play around with it some more, I&amp;rsquo;d suggest you to check the current &lt;a href=&#34;http://lithify.me/docs/lithium/core/Environment&#34;&gt;Environment&lt;/a&gt; and test the different behavior for different environments.&lt;/p&gt;

&lt;p&gt;With this tools at hand, you should be able to test everything that has to do with your routes and make sure that they are connected in the correct order and return the response you&amp;rsquo;ve intended.&lt;/p&gt;

&lt;h3 id=&#34;reverse-routing&#34;&gt;Reverse Routing&lt;/h3&gt;

&lt;p&gt;As the router also handles reverse routing (which is used by the HTML helper to generate links), we can test it here too. Because we look at the router and its routes, reverse routing fits well into our router integration tests.&lt;/p&gt;

&lt;p&gt;Testing reverse routing is straightforward, so let&amp;rsquo;s start with some examples and work them through afterwards.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function testReverseRouting() {
    $expected = &#39;/foo/bar&#39;;
    $params = array(&#39;controller&#39; =&amp;gt; &#39;foo&#39;, &#39;action&#39; =&amp;gt; &#39;bar&#39;);
    $result = Router::match($params);
    $this-&amp;gt;assertEqual($expected, $result);

    $expected = &#39;/pages&#39;;
    $params = array(&#39;controller&#39; =&amp;gt; &#39;pages&#39;, &#39;action&#39; =&amp;gt; &#39;index&#39;);
    $result = Router::match($params);
    $this-&amp;gt;assertEqual($expected, $result);

    $expected = &#39;/pages/index/1&#39;;
    $params = array(&#39;controller&#39; =&amp;gt; &#39;pages&#39;, &#39;action&#39; =&amp;gt; &#39;index&#39;, &#39;args&#39; =&amp;gt; array(&#39;1&#39;));
    $result = Router::match($params);
    $this-&amp;gt;assertEqual($expected, $result);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, we test the opposite direction. We pass the router a set of arguments and get an URL back. As it&amp;rsquo;s the case with normal
routing, if two routes compete for the same URL, the first one wins. We call &lt;code&gt;Router::match()&lt;/code&gt; with our request params and get a URL as a string returned. This way, we can test that our HTML helper will return the desired URLs in our application. Of course, you can also add some tests to the HTML Helper (where you can make sure that the echoed HTML code is correct). If the router is not able to translate your params into a URL, it will raise an exception.&lt;/p&gt;

&lt;h3 id=&#34;wrapping-up&#34;&gt;Wrapping up&lt;/h3&gt;

&lt;p&gt;In part two of our series we&amp;rsquo;ve looked at unit testing routes, running integration tests against them and also testing the reverse routing
mechanism. Of course, these tests depend heavily on your application and will surely become more complex as the previous examples. The next higher level would be to do add some acceptance tests with &lt;a href=&#34;http://seleniumhq.org/&#34;&gt;Selenium&lt;/a&gt;, so that you can test routes in combination with links and forms on your page, to make sure that the data flow works as expected between pages. Also, I&amp;rsquo;m working on a BDD plugin for Lithium that works similar to &lt;a href=&#34;http://cukes.info/&#34;&gt;Cucumber&lt;/a&gt;, so stay tuned.&lt;/p&gt;

&lt;p&gt;I really hope that you&amp;rsquo;ve enjoyed the second part of this series. Also, thanks again to &lt;a href=&#34;http://twitter.com/#!/nateabele&#34;&gt;@nateabele&lt;/a&gt; for his helpful comments.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Understanding the Lithium Router - Part 1</title>
      <link>http://nitschinger.at/Understanding-the-Lithium-Router-Part-1/</link>
      <pubDate>Sat, 05 Feb 2011 00:00:00 +0000</pubDate>
      
      <guid>http://nitschinger.at/Understanding-the-Lithium-Router-Part-1/</guid>
      <description>

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;The router is an integral part of the framework and has two main purposes. The first one is to match a URL against a set of previously connected routes, the second one is to generate a URL from a set of arguments (reverse routing). The router itself is very flexible as we&amp;rsquo;ll see later on, but getting started is pretty easy. Lithium comes with a set of sensible default routes that help you to get on track immediately. While developing, you can always add, modify or remove routes and the application will instantly take these changes into account. When you are running in production mode, routes should be cached for performance reasons, because compiling and analyzing routes takes some time for every request. We&amp;rsquo;ll see how this works in one of the upcoming posts.&lt;/p&gt;

&lt;p&gt;At the time of writing, there is no full featured guide available. Nevertheless, Lithium provides an extensive API documentation that covers nearly every aspect of the routing system. For your convenience, here are some short links to &lt;a href=&#34;http://lithify.me/docs/lithium/net/http/Router&#34;&gt;the Router&lt;/a&gt; and &lt;a href=&#34;http://lithify.me/docs/lithium/net/http/Route&#34;&gt;the Route&lt;/a&gt; classes. Usually a good place for examples are unit tests, and the core developers worked hard to implement high code coverage and extensive unit tests. You can find them online &lt;a href=&#34;http://dev.lithify.me/lithium/source/libraries/lithium/tests/cases/net/http&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;the-request-response-cycle&#34;&gt;The Request/Response-Cycle&lt;/h4&gt;

&lt;p&gt;Before we dive into the router itself, it would be a good idea to take a look where the router is placed in the request/response-cycle and how it participates in the typical dispatching process.&lt;/p&gt;

&lt;p&gt;The index.php-Page creates a new request object and hands it over to the dispatcher. The dispatcher hands this request object over to the router, who matches it against his connected routes and returns parameters that tell the dispatcher which controller and action to execute. If no matching route is found, an exception is raised. The dispatcher then instantiates the correct Controller object, which returns - after processing the associated models, controller actions and views - a response object. The dispatcher then sends the headers
and the content of the response object back to the browser.&lt;/p&gt;

&lt;p&gt;After reading this, you may notice that the flow of the request and response objects is really straightforward. It is possible to modify or exchange every part of this dispatching process, so you have the full flexibility at your fingertips if you need it.&lt;/p&gt;

&lt;p&gt;The whole Lithium routing functionality is organized in separate classes that perform distinct operations. Two classes mainly participate in the routing process. The &lt;code&gt;lithium\net\http\Router&lt;/code&gt; has one or more  instances of &lt;code&gt;lithium\net\http\Route&lt;/code&gt; connected to itself. When the router has to route the request, it iterates over the connected routes and checks if one of them match. The routes are checked in the same order as they&amp;rsquo;re connected, so the first match wins the race. Therefore you need to be careful when designing your routes, as this may have some impact on your performance. When no matching routes are found (and no default routes are in place), then a &lt;code&gt;lithium\net\http\RoutingException&lt;/code&gt; is raised. We&amp;rsquo;ll use this behavior in the second part to render a 404-Page.&lt;/p&gt;

&lt;p&gt;Enough talk, let&amp;rsquo;s get started.&lt;/p&gt;

&lt;h3 id=&#34;basics-first&#34;&gt;Basics First&lt;/h3&gt;

&lt;p&gt;Usually, there is only one file you&amp;rsquo;ll need to modify when you want to add or modify your application routes. The &lt;code&gt;app/config/routes.php&lt;/code&gt; file is part of the bootstrap process and connects your routes to the router. If you open the file, you&amp;rsquo;ll see that there are already a few routes defined. We&amp;rsquo;ll look at them route by route, because they cover most of the syntax we&amp;rsquo;ll usually need.&lt;/p&gt;

&lt;p&gt;We always use the  &lt;code&gt;Router::connect()&lt;/code&gt; method if we want to bind a given URL to a set of parameters. The first route is also called the &amp;ldquo;root&amp;rdquo;, because this route will be used if the user hits your application with no additional parameters (like &lt;code&gt;http://www.example.com&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Router::connect(&#39;/&#39;, array(&#39;Pages::view&#39;, &#39;args&#39; =&amp;gt; array(&#39;home&#39;)));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Router::connect()&lt;/code&gt; method expects at least one argument, two more can also be specified. We&amp;rsquo;ll see more of them in later examples. The first argument is a string with the URL, the second one can be just a string or an array with information on how to map the URL to controllers and actions. For the first route, when the user hits the application with the root URL &amp;ldquo;/&amp;rdquo;, the &lt;code&gt;app\controllers\PagesController&lt;/code&gt; and its &lt;code&gt;view&lt;/code&gt; action is called. Additionally, a &amp;ldquo;args&amp;rdquo; param with the value &amp;lsquo;home&amp;rsquo; is passed to the controller. This argument is used afterwards in the controller action to render the &lt;code&gt;home&lt;/code&gt; view. Of course this is not necessary, but it showcases the flexibility of routes.&lt;/p&gt;

&lt;p&gt;The next route connects URLs like &lt;code&gt;/pages/foo&lt;/code&gt; or &lt;code&gt;/pages/bar&lt;/code&gt; to the PagesController and the view action.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Router::connect(&#39;/pages/{:args}&#39;, &#39;Pages::view&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you re-read the first route now, you should see obvious similarities. These two routes call the same controller and the same action, but the first route sets the &lt;code&gt;args&lt;/code&gt; param to a static value, while the second route sets it dynamically (based on the request). You can also pass an array as the second argument, which can give you more flexibility. The equal method call with an array passed as the second argument would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Router::connect(&#39;/pages/{:args}&#39;, array(&#39;controller&#39; =&amp;gt; &#39;pages&#39;, &#39;action&#39; =&amp;gt; &#39;view&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This way of calling &lt;code&gt;Router::connect()&lt;/code&gt;allows you to specify more arguments, but if you only need to route to a Controller/Action combination without further arguments, the first example is much shorter and as a result way easier to read.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;{:args}&lt;/code&gt; string acts as a placeholder, so let&amp;rsquo;s have a look at the controller and see how he uses the passed arguments (&lt;code&gt;app\controllers\PagesController&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function view() {
    $path = func_get_args();

    if (empty($path)) {
        $path = array(&#39;home&#39;);
    }
    $this-&amp;gt;render(array(&#39;template&#39; =&amp;gt; join(&#39;/&#39;, $path)));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;args&lt;/code&gt; keyword defined in the route is passed to the view action as a param. If no path was set, the action sets it to &amp;ldquo;home&amp;rdquo;. Afterwards, the correct template is rendered. This is just one way to use the passed arguments, we&amp;rsquo;ll see different methods in a minute.&lt;/p&gt;

&lt;p&gt;The next code snippet connects testing routes, but only when we are not in the production environment. You see that the routing system is flexible enough to take other conditions of the environment into account.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!Environment::is(&#39;production&#39;)) {
    Router::connect(&#39;/test/{:args}&#39;, array(&#39;controller&#39; =&amp;gt; &#39;lithium\test\Controller&#39;));
    Router::connect(&#39;/test&#39;, array(&#39;controller&#39; =&amp;gt; &#39;lithium\test\Controller&#39;));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default, Lithium searches for the controller in the &lt;code&gt;app\controllers&lt;/code&gt; namespace, so if you want to specify a controller in a different path, you&amp;rsquo;ll need to give Lithium the fully namespaced path (for example if you need to match a route against a controller in a plugin). These two routes match &lt;code&gt;/test&lt;/code&gt; and also &lt;code&gt;/test/lithium/tests/cases/action/ControllerTest&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The last routes you&amp;rsquo;ll find in the &lt;code&gt;routes.php&lt;/code&gt; file are the so called &amp;ldquo;default routes&amp;rdquo;. Because of the fact that route matching occurs in the same order as they are connected, they need to be connected at last (otherwise these routes would always match every request).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Router::connect(&#39;/{:controller}/{:action}/{:id:[0-9]+}.{:type}&#39;, array(&#39;id&#39; =&amp;gt; null));
Router::connect(&#39;/{:controller}/{:action}/{:id:[0-9]+}&#39;);
Router::connect(&#39;/{:controller}/{:action}/{:args}&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;{:controller}&lt;/code&gt;, &lt;code&gt;{:action}&lt;/code&gt;and &lt;code&gt;{:type}&lt;/code&gt; keywords are treated specially. These three keywords are used by the router to dynamically find and match the correct Controller/Action combination and render the result as the correct &lt;code&gt;lithium\net\http\Media&lt;/code&gt;-type. If a optional &lt;code&gt;{:id}&lt;/code&gt; is given, it is also passed down to the action. By convention, if no action is given &lt;code&gt;YourController::index()&lt;/code&gt; is assumed. The default routes also make it easy to define a separate output type (like JSON or XML), which can be used to render the data in an other format instead of HTML. If you want to learn more about this feature, be sure to read my blog post about &lt;a href=&#34;http://nitschinger.at/Add-an-RSS-Feed-to-your-blog-with-Lithium&#34;&gt;&amp;ldquo;Adding an RSS Feed to your blog with Lithium&amp;rdquo;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;These default routes match nearly everything, like &lt;code&gt;/posts&lt;/code&gt;, &lt;code&gt;/posts/show/4&lt;/code&gt; or &lt;code&gt;/posts/index.json&lt;/code&gt;. This default routes work perfectly with ids generated by MySQL auto increment (or anything similar), but it doesn&amp;rsquo;t work with MongoDB-IDs. Check out my blog post about &lt;a href=&#34;http://nitschinger.at/Lithium-Routes-And-Mongo-DB&#34;&gt;&amp;ldquo;Lithium Routes And MongoDB&amp;rdquo;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To understand the routing process full-stack, we also need to investigate how we can access the &lt;code&gt;Request&lt;/code&gt;-object and its params. In the next snippet you&amp;rsquo;ll find various examples of routes and how their params can be used in your controller. They always follow the same schema, so once you get used to it you should not need to look up the documentation again.&lt;/p&gt;

&lt;p&gt;The slug-route is a bit more complex for now, but we&amp;rsquo;ll cover these kind of routes in the next part.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * connects the root URL to the PostsController and the &amp;quot;index&amp;quot;-action.
 */
Router::connect(&#39;/&#39;, array(&#39;Posts::index&#39;));

/**
 * connects login and logout shorthand URLs to the UsersController.
 */
Router::connect(&#39;/login&#39;, array(&#39;Users::login&#39;));
Router::connect(&#39;/logout&#39;, array(&#39;Users::logout&#39;));

/**
 * connects slug URLs in my blog to the PostsController.
 */
Router::connect(&#39;/{:slug:[\w\-]+}&#39;, array(&#39;Posts::show&#39;));

/**
 * the corresponding Posts::show() action (the slug is passed in the request object).
 * the show-action can be called with an id (default route), or with a slug (previous route)
 */
public function show() {
    if(isset($this-&amp;gt;request-&amp;gt;id)) {
        $post = Post::first($this-&amp;gt;request-&amp;gt;id);
    } elseif(isset($this-&amp;gt;request-&amp;gt;params[&#39;slug&#39;])) {
        $post = Post::first(array(&#39;conditions&#39; =&amp;gt; array(&#39;slug&#39; =&amp;gt; $this-&amp;gt;request-&amp;gt;params[&#39;slug&#39;])));
    }
    if(!count($post)) {
        $this-&amp;gt;redirect(&#39;Posts::index&#39;);
    }
    return compact(&#39;post&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;generating-urls&#34;&gt;Generating URLs&lt;/h4&gt;

&lt;p&gt;As said previously, the routing infrastructure is not only capable of matching URLs to routes, but also matching a set of given parameters and generate a URL out of them. This technique is called &amp;ldquo;reverse routing&amp;rdquo;. The HTML-Helper for example does this for if you use its &lt;a href=&#34;http://lithify.me/docs/lithium/template/helper/Html::link%28%29&#34;&gt;&amp;ldquo;link&amp;rdquo;&lt;/a&gt;-method. If you want to trigger the reverse routing functionality manually, you can do this by querying the &lt;code&gt;Router::match()&lt;/code&gt; method. Here is an example from the Lithium documentation that illustrates this behavior. Both &lt;code&gt;Router::match()&lt;/code&gt; queries return the URL &amp;ldquo;/login&amp;rdquo; as a result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Router::connect(&#39;/login&#39;, array(&#39;controller&#39; =&amp;gt; &#39;users&#39;, &#39;action&#39; =&amp;gt; &#39;login&#39;));
// params as an array
$url = Router::match(array(&#39;controller&#39; =&amp;gt; &#39;users&#39;, &#39;action&#39; =&amp;gt; &#39;login&#39;));
// a more compact syntax
$url = Router::match(&#39;User::login&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By using this method to generate URLs, you also make sure that your application is portable and works even if you place the application under a subdirectory on the server.&lt;/p&gt;

&lt;h3 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h3&gt;

&lt;p&gt;After reading this post you should have a basic understanding on how the router works and how it participates in the whole request/response cycle. The next posts will cover more advanced topics like testing routes,
&lt;a href=&#34;http://en.wikipedia.org/wiki/Representational_State_Transfer&#34;&gt;REST&lt;/a&gt;ful routes, namespaces/prefixes, bypassing the framework altogether, catching exceptions and even various production deployment considerations.&lt;/p&gt;

&lt;p&gt;If you want to read about a specific topic, feel free to comment below. Any feedback would be also greatly appreciated. Lastly, special thanks to &lt;a href=&#34;http://twitter.com/#!/nateabele&#34;&gt;@nateabele&lt;/a&gt; for reading through this post and providing important feedback.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>